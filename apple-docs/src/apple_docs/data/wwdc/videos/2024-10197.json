{
  "id": "10197",
  "year": "2024",
  "url": "https://developer.apple.com/videos/play/wwdc2024/10197/",
  "title": "Go small with Embedded Swift",
  "speakers": [],
  "duration": "",
  "topics": [
    "Swift"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "Hello and welcome. My name is Kuba Mracek, and as you know, Swift is a powerful language that can be used to build applications both for Apple platforms and beyond. Today, we‚Äôre going to take it to new and exciting, but smaller, places ‚Äî embedded devices. I‚Äôll start by introducing Embedded Swift. Then I‚Äôm going to show you in a demo how it can be used to build something practical. I‚Äôll go over how Embedded Swift is different from the Swift you use to write desktop and mobile applications, and finally I‚Äôll share resources that you can explore to learn more. Let‚Äôs jump in! Today, you can use Swift to build many different types of software: You can target mobile devices, desktop computers, servers.\n\nIn this session, we‚Äôre going to talk about using Swift in a new area: on embedded devices, which we are surrounded by in our daily lives ‚Äî smart lights, thermostats, alarms, smart fans, music devices, light strips, and many other common gadgets are built using programmable microcontrollers. Today, I would like to show how you ‚Äî as either a hobbyist or even a more serious developer ‚Äî can use Swift to program these embedded devices. For that, we‚Äôre introducing Embedded Swift ‚Äî a new compilation mode specifically suited for constrained embedded devices. Historically, C and C++ were the commonly used languages in this area. But now, we‚Äôre enabling using Swift in these places, and that brings to embedded developers the benefits of Swift, like its ergonomics, safety features, and ease of use. Embedded Swift is of course suitable to program microcontrollers in embedded devices, but also kernel-level code and other low-level library code that might be, for example, sensitive to not gaining new dependencies. Apple devices use Embedded Swift on the Secure Enclave Processor, and Swift‚Äôs memory safety is a huge benefit for the platform. Embedded Swift is a subset of Swift, covering most of the language you know and love ‚Äî it‚Äôs a full-featured subset that includes support for value and reference types, closures, optionals, error handling, generics, and more. Now, let‚Äôs take a look at Embedded Swift in a live demo. Before we start: Embedded Swift is currently an experimental feature, it‚Äôs not source stable, yet. It‚Äôs under active development, and the best way to use it is with a preview toolchain from swift.org. In this demo, I‚Äôm going to build a prototype of a very simple HomeKit accessory. A color LED light. I‚Äôll start by having a working HomeKit setup ‚Äî that means a WiFi network, and some existing Apple devices all connected to it. I‚Äôm going to take a programmable embedded device, concretely an ESP32C6 development board, which has a RISC-V microcontroller. And, it‚Äôll have a color LED attached to it. I‚Äôll use a Mac to connect to the device over a USB cable, and I‚Äôll write a program in Embedded Swift that implements a HomeKit accessory, which I will then flash onto the device. The device will then join my WiFi and the HomeKit network, and it can be controlled from the Home app on any of the Apple devices.\n\nLet‚Äôs get started. I‚Äôm using Neovim and CMake, and right now, this is just a template project to show the very basics and to get our Embedded Swift code up and running. The project is using a 3rd party SDK, which I got from my device vendor it‚Äôs an SDK written in C. And because I don‚Äôt want to modify that SDK, I can simply use a bridging header, to import all the SDK‚Äôs APIs into Swift.\n\nI need some simple CMake logic to be able to build my Swift code on top of the vendor‚Äôs SDK and their build system, which also requires a few more boilerplate files: Like the YAML file, the CSV file and the ‚Äúsdkconfig‚Äù file.\n\nThese are needed for any project built on top of this SDK, and I have set those up based on existing examples from the vendor, and just added Swift on top of that.\n\nLet‚Äôs go back to my Swift source code. My editor has LSP integration, so it show me the definitions and documentation for functions and types I‚Äôm using.\n\nIt can can give me rich and semantical autocompletion.\n\nAnd if I write code that doesn‚Äôt make sense...\n\nI get immediate errors and warnings telling me what‚Äôs wrong. Let me now plug-in the device.\n\nI‚Äôm going to be programming this device over USB, but my breadboard also has a separate battery, so once its programmed we will be able to unplug the device and still use it. But first, let‚Äôs get the most basic Swift application working and running on the device. The SDK I‚Äôm using provides tools for that.\n\nI‚Äôm going to run this convenient Python script that the vendor is providing. It allows me to build, flash, and monitor the device, all with a single command.\n\nAs I run it, we can observe that the firmware is being built, then uploaded to the device, and then we receive logs back from the device. And with that, we now have signs of life of our first Embedded Swift application running on an embedded device. Now, let‚Äôs add code that does something more useful. Swift‚Äôs interoperability gives us access to all the APIs in the vendor‚Äôs SDK. If I want to control the LED on the device, I can use the existing C APIs in the SDK for that.\n\nLet‚Äôs call these APIs with values that mean ‚Äúblue color‚Äù, ‚Äú100% saturation‚Äù, ‚Äú80%‚Äù brightness.\n\nAnd let‚Äôs save and upload this version of our code to the device.\n\nI‚Äôll run the same command as last time.\n\nIn a few seconds, once the firmware is uploaded and the device reboots, we can now control the color and brightness of the LED.\n\nNow, using Swift to just call C APIs for everything would defeat the whole purpose. It‚Äôs very useful that we can do that, but it‚Äôs even better to build some wrappers and abstractions over those, so that we can write our application in clean, intuitive, and ergonomic Swift code. In this version, I have prepared an LED object. Let‚Äôs jump to its definition.\n\nThis is some helper code I wrote earlier, and it wraps the C APIs into a nice Swift layer. It provides useful properties with some ergonomic types, for example the enabled property is a boolean, the brightness property is an integer. Let‚Äôs go back to the file with the main application logic. Using the LED object, we can now write really straightforward and intuitive code.\n\nOn start, let‚Äôs set the color to red.\n\nAnd brightness to 80%.\n\nCode like this is extremely readable and clear. Let‚Äôs add some more.\n\nIn a loop, we‚Äôll wait 1 second, flip the state of the LED. And if we‚Äôre turning it on, then we‚Äôll ask for a new color expressed by a hue and a saturation value. The hue will be random, and saturation will be 100%. All of this Embedded Swift code really feels just like writing regular Swift. Most of the language is simply available. I‚Äôll upload the firmware one more time Let‚Äôs see if the result works. Once the program boots and runs, our device should be blinking its LED with a randomly changing color.\n\nGreat! This is exactly what we wanted. Building the layer for the LED object is what really gives us the power of Swift: High-level APIs that let us write clean, readable code. So far, we‚Äôve seen how Embedded Swift can nicely integrate into your workflows. You can use it with a vendor-provided SDK, and you can get your IDE or text editor to provide full autocompletion, show definitions, and documentation. Using Swift‚Äôs interoperability, you can call existing C APIs from the SDK directly in Swift code. But often it‚Äôs valuable to wrap C APIs into a layer that provides ergonomic and intuitive APIs for our core application logic.\n\nNow that we have the basics working, let‚Äôs continue building an actual HomeKit accessory. For that, we‚Äôre going to use ‚ÄúMatter‚Äù protocol. Matter is an open standard for building smart home accessories. It‚Äôs described in depth in a WWDC session from 2021, I encourage you to watch it if you‚Äôd like to know more. In the SDK I‚Äôm using, Matter is provided as C++ APIs, and we can use Swift‚Äôs interop again to use this functionality that will gives us all the infrastructure pieces, like device discovery and commissioning, for free. And as soon as we have a device that implements the Matter protocol, it will automatically work in HomeKit, because it supports Matter accessories natively. Let‚Äôs start again with just an empty application that doesn‚Äôt do anything. And to work with Matter, we need to know a little bit about its data model and terminology. This is the rough high-level task list that we‚Äôll have to do, to implement a Matter device. We‚Äôll need to create what‚Äôs called a root node, which represents the entire Matter accessory. Then we‚Äôll need an endpoint, in our case that‚Äôs going to be the color LED light, and that‚Äôs also going to be the object that has a state, for example the color and brightness, and can receive commands, for example to turn the light on or off. Then we‚Äôll connect the endpoint to the node, and the node to an ‚Äúapplication‚Äù object. I already wrote a simple wrapper layer around the C++ Matter APIs that‚Äôs what I have in this ‚ÄúMatter‚Äù subdirectory.\n\nIt‚Äôs exactly the same approach we used to give ourselves nice APIs for working with the LED light. Using that, we can fill in the top-level logic easily.\n\nFirst we create the root node.\n\nThen we create and configure the endpoint.\n\nThis is our color light, and notably it has an eventHandler ‚Äî a closure that is triggered every time an event from HomeKit is sent to this endpoint. A closure is a very natural mechanism for a callback. We don‚Äôt have to deal with unsafe function pointers or untyped context arguments which are a common solution for callbacks in C. Next, let‚Äôs register the endpoint. And finally, set up and start a Matter application.\n\nFor now, the logic just prints all the events, but we‚Äôve now built a valid Matter application. So let‚Äôs flash this application to the device.\n\nIt will take a while to start up. Now normally, you would go through a setup process for a new accessory. I have already previously done that, and I have registered this device in my HomeKit network already, so it already knows which WiFi network to join. As soon as it does that, it‚Äôll shows up in the Home app on my Mac, and on my other devices as a ‚ÄúMatter Accessory‚Äù. It shows up as a smart light, and I can control it right here from the Home app on my Mac. I can turn the light on and off, and as I do that, we receive events for those commands that show up in our device logs.\n\nSo far, we have just been logging the incoming events. Let‚Äôs make them really do something! And let‚Äôs wire them up to our LED object that we‚Äôve used previously. Inside the event handler, we‚Äôll want to react to different attributes being set. And because the attribute is a Swift enum, we can use a switch statement, and the autocompletion will tell use which cases we have to handle. Let‚Äôs fill in the code for the different attributes. Based on which event we receive, we will want to set the enabled property if we need to turn the light on or off. Or we‚Äôll set the brightness property, where we also need to scale the value appropriately. And very similarly, we can handle color changes, setting a new hue, a new saturation, or a new color temperature. This should be all we need. Let‚Äôs flash this program to the device and test it out! While the program is starting, I‚Äôd like to point out how useful and ergonomic Swift enums are.\n\nIn the simplest case, enums just represent one choice out of a set. For example the .onOff case or the .levelControl case of the attribute.\n\nBut they can also have associated values. For example the .colorControl case has a payload, and thanks to Swift‚Äôs pattern matching, I don‚Äôt need a second nested switch statement. I can just match the enum case together with the payload.\n\nI‚Äôm also using enums to represent the color property, which can either be hue plus saturation or a temperature.\n\nThese cases even have different payload types, the first one has two integers as the payload, and the other one needs just one integer. This altogether makes Swift enums really powerful and expressive, and they allow us to write this simple, concise, readable logic. Now that the device has started, I can unplug the USB cable and use the battery to power it.\n\nAnd we can control this device wirelessly from the Home app. Let‚Äôs turn the light on.\n\nAnd off. Let‚Äôs see if we can change the brightness.\n\nOr choose a different color temperature.\n\nOr perhaps customize the color completely. Let‚Äôs try a few different ones.\n\nAwesome, I think our prototype of a smart light works great! We have successfully built a HomeKit-enabled smart light using Embedded Swift. And if you‚Äôd like, this demo project, and setup instructions are available on GitHub. We‚Äôve seen how we can get a basic prototype of a HomeKit-enabled device up and running very quickly, by leveraging Swift‚Äôs interop capabilities. There is no need to re-implement the entire Matter protocol in Swift. We can just use the existing implementation from Swift. Swift encourages clean and intuitive design and implementation of your code, and it improves readability and safety over C and C++, as we‚Äôve seen, for example, when using closures as an ergonomic solution for callbacks. In the demo, we‚Äôve seen how Embedded Swift feels like regular Swift, and it does indeed include most of Swift‚Äôs language features, but there are some differences. Embedded environments are commonly very constrained, and they need small and simple binaries for programs to fit. Memory, storage, and CPU performance are typically very limited. Because of that, Embedded Swift disallows certain features to meet these requirements. As an example, let‚Äôs consider how runtime reflection works. To inspect the children of a type, it needs to access the metadata record for the type. This includes the fields‚Äô names, offsets, and types, which in turn reference other metadata records, and so on and so on. These records all add up and can have an unacceptable codesize cost for embedded devices.\n\nTo avoid that, runtime reflection using the Mirror APIs is disallowed in Embedded Swift, and it‚Äôs only available in full Swift. For the same reason, to avoid needing metadata at runtime, metatypes and ‚Äúany‚Äù types are also disallowed. But don‚Äôt be alarmed, the vast majority of the Swift language is available in Embedded Swift. Embedded Swift is strictly a subset compared to full Swift, and not a variant or a dialect. So there won‚Äôt be any differences in behavior between Embedded Swift and full Swift. All code that works in Embedded Swift will also work in full Swift.\n\nWhen you try to use a feature that‚Äôs not available in Embedded Swift, the compiler will tell you. In this example, I have tried to use an any type.\n\nTo avoid that, I can replace this use of any Countable with generics instead. In this code snippet, it‚Äôs as simple as swapping any Countable for some Countable, which turns this function into a generic function. Generics are fully supported in Embedded Swift, as the compiler can specialize generic functions. And the result of that is code that does not need expensive runtime support or type metadata. There‚Äôs so much more to explore about Embedded Swift. As part of the Swift Evolution process, a vision document for Embedded Swift has been published and accepted. This document describes the high-level design, requirements, and approach of Embedded Swift, and it‚Äôs a great introduction into the compilation mode and the language subset. If you‚Äôre trying out Embedded Swift, I recommend reading the ‚ÄúEmbedded Swift -- User Manual‚Äù. It describes how to get started, what you should and shouldn‚Äôt expect, and also some details that you will likely need to know when interacting with your vendor‚Äôs SDK and build system, for example, which compiler flags to use and which dependencies you will need to satisfy.\n\nWe have published a set of example projects written in Embedded Swift on GitHub, and they cover a range of embedded devices that have ARM or RISC-V microcontrollers. This includes popular embedded development boards, as well as some other devices like the Playdate gaming console. The examples also show how to use various build systems and integration options. They can give you a sense of what all can Embedded Swift do, but also serve as templates for your own ideas. When writing code that runs on an embedded device, you often need to interact with low-level hardware registers. To help you with that, we have published ‚ÄúSwift MMIO‚Äù, a library that provides APIs for safe, structured, and ergonomic operations on memory mapped registers. And finally, the Swift forums now have a new ‚ÄúEmbedded‚Äù subcategory and that‚Äôs the right place to take your experiments, questions, and discussions next.\n\nWe have seen how to use the new compilation mode ‚Äî Embedded Swift ‚Äî to program embedded devices. It‚Äôs currently available as a preview, and works best with nightly toolchains from swift.org. Currently, ARM and RISC-V chips of both 32-bit and 64-bit variants are supported, but Embedded Swift is not really hardware specific and it‚Äôs quite easy to bring it to new instruction sets. Go try out Embedded Swift, build some cool electronics projects and share your experience and feedback on the Swift forums. Thanks for watching, and have a great WWDC.",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "3:50",
      "title": "Empty Embedded Swift application",
      "language": "swift",
      "code": "@_cdecl(\"app_main\")\nfunc app_main() {\n  print(\"üèéÔ∏è   Hello, Embedded Swift!\")\n}"
    },
    {
      "timestamp": "6:48",
      "title": "Turning on LED to blue color",
      "language": "swift",
      "code": "@_cdecl(\"app_main\")\nfunc app_main() {\n  print(\"üèéÔ∏è   Hello, Embedded Swift!\")\n  var config = led_driver_get_config()\n  let handle = led_driver_init(&config)\n  led_driver_set_hue(handle, 240) // blue\n  led_driver_set_saturation(handle, 100) // 100%\n  led_driver_set_brightness(handle, 80) // 80%\n  led_driver_set_power(handle, true)  \n}"
    },
    {
      "timestamp": "8:32",
      "title": "Using an LED object",
      "language": "swift",
      "code": "let led = LED()\n\n@_cdecl(\"app_main\")\nfunc app_main() {\n  print(\"üèéÔ∏è   Hello, Embedded Swift!\")\n\n  led.color = .red\n  led.brightness = 80\n\n  while true {\n    sleep(1)\n    led.enabled = !led.enabled\n    if led.enabled {\n      led.color = .hueSaturation(Int.random(in: 0 ..< 360), 100)\n    }\n  }\n}"
    },
    {
      "timestamp": "12:44",
      "title": "Matter application controlling an LED light",
      "language": "swift",
      "code": "let led = LED()\n\n@_cdecl(\"app_main\")\nfunc app_main() {\n  print(\"üèéÔ∏è   Hello, Embedded Swift!\")\n  \n  // (1) create a Matter root node\n  let rootNode = Matter.Node()\n  rootNode.identifyHandler = {\n    print(\"identify\")\n  }\n  \n  // (2) create a \"light\" endpoint, configure it\n  let lightEndpoint = Matter.ExtendedColorLight(node: rootNode)\n  lightEndpoint.configuration = .default\n  lightEndpoint.eventHandler = { event in\n    print(\"lightEndpoint.eventHandler:\")\n    print(event.attribute)\n    print(event.value)\n\n    switch event.attribute {\n    case .onOff:\n      led.enabled = (event.value == 1)\n    \n    case .levelControl:\n      led.brightness = Int(Float(event.value) / 255.0 * 100.0)\n    \n    case .colorControl(.currentHue):\n      let newHue = Int(Float(event.value) / 255.0 * 360.0)\n      led.color = .hueSaturation(newHue, led.color.saturation)\n    \n    case .colorControl(.currentSaturation):\n      let newSaturation = Int(Float(event.value) / 255.0 * 100.0)\n      led.color = .hueSaturation(led.color.hue, newSaturation)\n    \n    case .colorControl(.colorTemperatureMireds):\n      let kelvins = 1_000_000 / event.value\n      led.color = .temperature(kelvins)\n    \n    default:\n      break\n    }\n  }\n  \n  // (3) add the endpoint to the node\n  rootNode.addEndpoint(lightEndpoint)\n  \n  // (4) provide the node to a Matter application, start the application\n  let app = Matter.Application()\n  app.eventHandler = { event in\n    print(event.type)\n  }\n  app.rootNode = rootNode\n  app.start()\n  \n}"
    },
    {
      "timestamp": "18:03",
      "title": "Reflection example",
      "language": "swift",
      "code": "// Reflection needs metadata records\n\nlet mirror = Mirror(reflecting: s)\nmirror.children.forEach { ‚Ä¶ }\n\nstruct MyStruct {\n  var count: Int\n  var name: String\n}"
    },
    {
      "timestamp": "18:57",
      "title": "Unavailable features will produce errors",
      "language": "swift",
      "code": "// Unavailable features will produce errors\n\nprotocol Countable {\n  var count: Int { get }\n}\n\nfunc count(countable: any Countable) {\n  print(countable.count)\n}"
    },
    {
      "timestamp": "19:24",
      "title": "Prefer generics over ‚Äúany‚Äù types",
      "language": "swift",
      "code": "// Prefer generics over ‚Äúany‚Äù types\n\nprotocol Countable {\n  var count: Int { get }\n}\n\nfunc count(countable: some Countable) {\n  print(countable.count)\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Forum: Programming Languages",
        "url": "https://developer.apple.com/forums/topics/programming-languages-topic?cid=vf-a-0010"
      },
      {
        "title": "Swift Forums Embedded Discussion",
        "url": "https://forums.swift.org/c/development/embedded/107"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2024/10197/4/61F8D9DD-2B91-4545-AA09-253E16642E98/downloads/wwdc2024-10197_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2024/10197/4/61F8D9DD-2B91-4545-AA09-253E16642E98/downloads/wwdc2024-10197_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10298",
      "year": "2021",
      "title": "Add support for Matter in your smart home app",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10298"
    }
  ],
  "extractedAt": "2025-07-18T10:47:24.012Z"
}