{
  "id": "10221",
  "year": "2020",
  "url": "https://developer.apple.com/videos/play/wwdc2020/10221/",
  "title": "Get your test results faster",
  "speakers": [],
  "duration": "",
  "topics": [
    "Developer Tools"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "♪ Voiceover: Hello, and welcome to WWDC.\n\nSean Olszewski: Hi there, and welcome to my session: Get Your Test Results Faster.\n\nMy name is Sean, and I'm an engineer in the Developer Technologies Group at Apple, working on the XC Test Framework and its Xcode integrations.\n\nThis session is grounded in a concept called the Testing Feedback Loop, and if case this concept is new to you, I wanted to briefly take you through it.\n\nAfter this, we'll be going over some techniques and features within Xcode that you can use to speed up getting results from your tests.\n\nIf you've ever written an automated test before, there's a good chance that you have an intuition of what the testing feedback loop is, and this is because writing a test is the beginning of the loop.\n\nThe loop then continues into you running those tests, usually alongside some other tests, and then ends up with you interpreting the results and making some decisions based on what's in your test report.\n\nDepending on your report, you may decide to write more tests because there are cases or features you're interested in covering.\n\nOr you may decide that you've written enough tests, and the results give you confidence your code behaves as you expect.\n\nThis confidence lets you move on to other tasks.\n\nHaving short feedback loops is important because that means you get results from your tests faster.\n\nIf your tests are faster, than you can get confidence in your code is faster, which that means you can ship features to your users faster.\n\nNow, having gone over the Test Feedback Loop, I wanted to let you know what will be going on for today.\n\nWe're first going to discuss some features in Xcode 12 that will ensure your tests always complete.\n\nWe'll also talk about how to use some diagnostics these features surface to figure out what may be breaking your feedback loops.\n\nThen we're going to talk about how you can get even faster results from your tests by using the Test Paralyzation Options available to you in Xcode 12.\n\nNow let's ground this discussion in a real world example.\n\nImagine you're at work looking at the results from a CI job that you kicked off on Friday before leaving the office.\n\nWith a hot beverage in hand, tou realize that your long-running test suite never finished.\n\nYou'd probably feel like how this person looks: frustrated and a little upset that you need to start the week understanding why your tests aren't working.\n\nIf we don't investigate this problem, our tests will continue to take longer and will intermittently not finish, which is going to ruin our confidence in our tests and application code, and that's going to hurt our ability to quickly deliver new features to our users.\n\nThis is a very unfortunate situation to be in.\n\nBut lucky for us, there are some features in Xcode 12 to help us out.\n\nSo let's look into it.\n\nWe're going to start with fixing the hang in our test suite so we can always get feedback from our tests.\n\nRight now, the feedback loop is broken.\n\nBecause our tests hung and never finished running, we never got our results, and so we can't interpret them.\n\nWe're left to cancel the tests and forfeit getting a complete understanding of our codebase's codebase's quality.\n\nThis image is from a result bundle from that CI job, which never finished.\n\nIt has an error message that says testing was canceled because we had to cancel the CI job, which isn't exactly actionable.\n\nI'm left wondering what exactly went wrong in the first place.\n\nWithout much in terms of diagnostics to understand why our tests are hung, we can try thinking of a few causes offhand.\n\nA classic example is a deadlock, where two sections of code are waiting for the other to make forward progress and therefore neither does.\n\nThough even if our tests aren't stalled, their rate of progress may be so low that they're effectively stuck.\n\nAlternatively, this could just be due to poorly chosen timeout values in some application code.\n\nOr it could be due to large amounts of CPU work that we're doing on the main thread of our app or framework for testing.\n\nAvailable in Xcode 12 though, is a solution to our problem of hung tests.\n\nIt's a new test plan option called Execution Time Allowance.\n\nExecution Time Allowance is a customizable feature that you can opt into when running your tests.\n\nWhen enabled, Xcode enforces a limit on the amount of time each individual test can take.\n\nWhen a test exceeds this limit, Xcode will first capture spindump, then kill the test that hung, then, restart the test runner, so that the rest of the suite can execute.\n\nWe know it's not a great experience to try to guess at what could be causing our tests to hang.\n\nAfter all, our code base could be large and complex, and that doesn't lend itself to being easily reasoned about.\n\nInstead, we'd benefit from having some better diagnostics given to us, so we can understand the cause a bit better.\n\nA spin dump can help us out here a lot.\n\nAnd this is why Execution Time Allowance attaches them to your test report.\n\nA spin dump shows you which functions each thread is spending the most time in.\n\nIf our tests are stalled, a spin dump would help us see what functions the issue may lie in.\n\nIt's also possible to manually capture spin dump from Terminal using the spin dump command or from within Activity Monitor if you prefer a GUI.\n\nBy default, each and every test will get 10 minutes.\n\nIf a test successfully finishes before that 10 minutes elapses, the timer will get reset for the next test.\n\nIf you need more time for all tests, you can customize the default allowance in your test plan's configuration.\n\nAnd if you need more time for a specific test or test class, you can use the executionTimeAllowance API to special case a particular test or subclass.\n\nExecution time allowance is represented as a time interval property on XCTestCase.\n\nIt's important to note that time allowance values will be rounded to the nearest minute.\n\nFor values under 60 seconds, they'll be rounded up to 60 seconds, and for a value like 100 seconds, it would be rounded up to 120 since that's the nearest whole minute.\n\nHaving gone over the new Execution Time Allowance feature let's go through a quick demo of turning it on and using the spin dump it attaches to fix our hung test.\n\nI have here in Xcode 12 the test that was hanging in CI.\n\nIt's a test called TestUpdatingSmoothiesFromServer and it's a test of a method called FetchSynchronouslyFromServer.\n\nI'm going to try to reproduce the issue at my desk here, and I'm going to do that by pressing the play button in the Source Editor Gutter.\n\nNow when I do this, I see the activity indicator in the test navigator spinning.\n\nIf this test was working and not hung, it would execute immediately.\n\nI'm going to stop the tests because there's no use in waiting for it to stall.\n\nNow, I want to turn on the Execution Time Allowance feature to get a spin dump, so let's do that.\n\nI can do that by opening the test plan menu, clicking the edit plan item, selecting configurations, turning test time-outs on, and then rerunning my test by pressing the Play button again in the Test Navigator.\n\nThis will generate a new report for me that I can use, and I can view that report in the Navigator.\n\nIf I go ahead, and I open up the report that it just generated, I'm going to see the same test is failing, but its failure reason is different.\n\nIt's going to say that it exceeded the test execution time allowance of 10 minutes, which is the default.\n\nAnd it's also going to attach a spin dump.\n\nYou can open that spin dump by double-clicking it, and it will open inside an editor tab.\n\nSpin dumps are generally broken up into two sections: a preamble, which contains metadata, and then a series of stack traces for each thread within the process that was sampled.\n\nSince we're sampling our test runner process, I know that my test name should be somewhere in that spin dump If I do a quick find, I can rapidly find my test within the stack trace and see that it's calling the method under test as well as a private helper method.\n\nAfter that, I can see that it's acquiring a lock, and then it's waiting.\n\nThis suggests to me that the issue is in that helper method that we have.\n\nI'm going to look at the code, and I'm going to navigate to the code by opening up the Smoothy.Swift file.\n\nUpon looking at this code, I can see that in this second method, it's acquiring the same lock as our method under test: FetchSynchronouslyFromServer.\n\nIt seems questionable to me that this helper method, which is just for performing a get request, is acquiring a lock, and so I'm going to try deleting this lock acquisition code from here to see if that fixes our deadlock.\n\nI'm going to reopen the test navigator by selecting the test navigator icon and clicking the Play button for our tests.\n\nWe see that the test immediately executes, indicating that we fixed the hang.\n\nHaving demoed turning on time allowances for our project, let's talk about some ways you can customize them.\n\nThere are two ways you can customize the default time allowance.\n\nThe first is using the Test plan setting, which is available in Xcode 12.\n\nAnd the second is using the Xcodebuild option.\n\nOnce you've enabled Time Allowances, there's a precedence order the configurations follow.\n\nThis is so that you can set course grain defaults and finer grain values for special cases such as CI jobs or long-running tests suites.\n\nThe TimeAllowance API has the highest precedence.\n\nWhile Xcodebuilds TimeAllowance option has the second-highest precedence.\n\nA Test Plan setting has the third-highest precedence.\n\nAnd the the system default of 10 minutes, has the lowest precedence, and will be overridden by any of the other three options.\n\nWith all of these ways to set a time allowance, a question emerges which is: What happens if a test requests unlimited time? There's a way to prevent this from happening, and that's by enforcing a maximum allowance.\n\nYour test is guaranteed not to exceed this value, regardless of the configuration you set and test plans or through API calls.\n\nYou can enforce a maximum allowance either via a setting in the Test Plan or through an Xcodebuild option.\n\nHaving gone over how to use the new Time Allowance features, we wanted to offer a couple of recommendations for how to get the most out of them.\n\nFor starters, use time allowances specifically to guard against test hangs and ensure you get diagnostics when they do.\n\nIf you're concerned about keeping your tests fast, we recommend using XCTest's performance APIs to automate testing for regressions in the performance of your code.\n\nAnd if you need to identify what parts of your code are slow we recommend using Instruments to profile and understand your app's performance.\n\nInstruments provides a rich set of tools that will give you a lot of info that can help you figure out where to begin adding perf tests to your app code.\n\nIf you're interested in learning how to use Instruments, check out this talk from WWDC 2019 entitled Getting Started with Instruments.\n\nNow, having adopted Time Allowances, our feedback loop has gone from being broken during the running tests phase to being complete, and what's more is that we will now always get results if our tests unexpectedly hang or stall.\n\nWe now have the ability to turn our attention to the fact that our tests take a lot of time.\n\nSo let's dig into how we can speed up for this test suite.\n\nXcode 12 can help us shorten the loop even more by letting us run tests on multiple devices.\n\nThis is a test report from Fruita.\n\nWe see the results of about a dozen tests that took between a few hundred milliseconds to several minutes to run.\n\nOverall, our tests are just about 13 minutes to run with many of these tests taking time on the order of minutes to complete running.\n\nThis is a clue that we would benefit from parallel testing.\n\nRight now Fruita is using non-distributed testing.\n\nThat means each and every testcase defined is executed serially on a run destination, and that will always take the most amount of time.\n\nYou've likely experienced this if you have ever pressed command-U in Xcode with paralyzation disabled.\n\nA solution to speed this up is to use a feature we call Parallel Distributed Testing.\n\nIn the case of Parallel Distributed Testing, Xcode build will distribute tests to each run destination by class.\n\nEach device will then run a single test class at a time.\n\nOnce a run destination has finished running a class, Xcode build continues to give it a new one, until there aren't any left.\n\nIt's very important to note that the allocation of test classes to run destinations is non-deterministic.\n\nIf you're testing logic that is device or OS specific, this can lead to unexpected failures or skipped tests.\n\nWhen we first added support for Parallel Distributed Testing to Xcode 10, this supported  configuration matrix looked like unit tests some MacOS and unit and UI tests on iOS and tvOS simulators.\n\nStarting with Xcode 12, the matrix now looks like this.\n\nYou have the ability to run tests in parallel on physical iOS and tvOS devices via Xcodebuild.\n\nTo enable parallel distributed testing, set the parallel-testing-enabled flag to Yes.\n\nThen set the parallelize-tests among-destinations flag.\n\nThis makes Xcodebuild divide your tests over the destinations you specify.\n\nWith just two devices, XCTest own test suites achieved a speed up of 30 percent.\n\nJust imagine what this would do for the Fruita app or your app with more devices.\n\nBy adopting distributed testing, we've been able to take our long feedback loops on XCTest and shorten them, enabling us to write, run, and analyze our tests faster.\n\nNow we wanted to offer you a few recommendations for how you can leverage distributed testing in your own tests.\n\nSince test allocation is non-deterministic, it's ideal to use a device pool of identical devices and OS versions.\n\nThis is so you can avoid difficult-to-reproduce test failures that may have been driven out due to the particular destination allocation Xcodebuild made.\n\nIf you're using a device pool of different devices and OS versions, then we recommend you prefer distributing tests that are agnostic to the devices and OSs they would be running on.\n\nFor example, tests for a framework of pure business logic are less likely to encounter issues since they wouldn't be running code that depended on destination-specific details.\n\nLastly, if you're interested in testing your code against more Oss and devices, for example, to prove your app works with both iOS 13 and 14, then we recommend you use Parallel Destination testing.\n\nDestination testing runs the entirety of a test suite on a given destination and does not distribute the individual tests across destinations.\n\nIf you're interested in learning more about destination testing and how tests are allocated, check out What's New in Testing. from WWDC 2018.\n\nNow as a result of focusing on our test report and using Xcode 12, our tests will no longer hang or stall; they'll give us more diagnostic should a test take an unexpected amount of time, and they're faster.\n\nIn conclusion, we recommend you use Execution Time Allowances to ensure your tests always complete in the event they hang.\n\nUse spin dumps for diagnosing application stalls and hangs both for when your tests and app-stall.\n\nUse Parallel Distributed Testing to speed up your tests for running portions of your suite on different run destinations.\n\nAnd use Parallel Destination Testing to simultaneously run your tests on more OS versions and devices.\n\nDo this to get faster feedback on whether your code is behaving as expected between different OSs and devices.\n\nThank you all so very much for joining me during the session.\n\nWe hope your test suites are fast, that their feedback is actionable, and that you enjoy the rest of WWDC 2020.\n\n♪",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "6:12",
      "title": "testUpdatingSmoothiesFromServer Sample",
      "language": "swift",
      "code": "import XCTest\n@testable import Fruta\n\nclass SmoothieNetworkingTests: XCTestCase {\n    func testUpdatingSmoothiesFromServer() throws {\n        let originalSmoothies = Smoothie.all\n        try Smoothie.fetchSynchronouslyFromServer()\n        XCTAssertNotEqual(originalSmoothies, Smoothie.all)\n    }\n}"
    },
    {
      "timestamp": "7:56",
      "title": "Interesting Spindump Content",
      "language": "swift",
      "code": "11  __26-[XCTestCase performTest:]_block_invoke_2 + 43 (XCTest + 167518) [0x105a70e5e] 1-11\n  11  -[XCTestCase invokeTest] + 1069 (XCTest + 161187) [0x105a6f5a3] 1-11\n    11  -[XCTestCase(XCTIssueHandling) _caughtUnhandledDeveloperExceptionPermittingControlFlowInterruptions:caughtInterruptionException:whileExecutingBlock:] + 183 (XCTest + 535831) [0x105acad17] 1-11\n      11  __24-[XCTestCase invokeTest]_block_invoke.239 + 129 (XCTest + 162434) [0x105a6fa82] 1-11\n        11  +[XCTSwiftErrorObservation observeErrorsInBlock:] + 69 (XCTest + 811868) [0x105b0e35c] 1-11\n          11  __24-[XCTestCase invokeTest]_block_invoke_2 + 52 (XCTest + 162709) [0x105a6fb95] 1-11\n            11  ??? [0x7fff20438bf6] 1-11\n              11  ??? [0x7fff2043b73c] 1-11\n                11  @objc SmoothieNetworkingTests.testUpdatingSmoothiesFromServer() + 74 (<compiler-generated> in Fruta Unit Tests + 23882) [0x105d35d4a] 1-11\n                  11  SmoothieNetworkingTests.testUpdatingSmoothiesFromServer() + 132 (Networking.swift:12,22 in Fruta Unit Tests + 22756) [0x105d358e4] 1-11\n                    11  static Smoothie.fetchSynchronouslyFromServer() + 163 (Smoothie.swift:61,26 in Fruta + 374563) [0x10532f723] 1-11\n                      11  static Smoothie.performGETRequest(to:) + 179 (Smoothie.swift:73,31 in Fruta + 375475) [0x10532fab3] 1-11\n                        11  -[PKAppleAccountInformation appleID] + 6 (PassKitCore + 1577496) [0x7fff5bc14218] 1-11\n                          11  -[PKNFCTagReaderSession delegate] + 8 (PassKitCore + 1348766) [0x7fff5bbdc49e] 1-11\n                           *11  psynch_mtxcontinue + 0 (pthread + 9627) [0xffffff800365a59b] (blocked by turnstile waiting for this thread) 1-11"
    },
    {
      "timestamp": "8:23",
      "title": "Helper Methods",
      "language": "swift",
      "code": "extension Smoothie {\n    \n    enum Errors: Error {\n        case noData\n    }\n    \n    static var serverIsAvailable: Bool { false }\n    static var smoothieEndpoint: URL {\n        URL(string: \"https://smoothies.food.com\")!\n    }\n    \n    static func fetchSynchronouslyFromServer() throws {\n        fetchSmoothieLock.lock()\n        defer { fetchSmoothieLock.unlock() }\n        \n        guard let data = performGETRequest(to: smoothieEndpoint) else {\n            throw Errors.noData\n        }\n        \n        let smoothies = try JSONDecoder().decode([Smoothie].self, from: data)\n        Smoothie.all += smoothies\n    }\n\n    static func performGETRequest(to url: URL) -> Data? {\n        defer { fetchSmoothieLock.unlock() }\n        \n        if url == smoothieEndpoint {\n            fetchSmoothieLock.lock()\n        }\n        \n        return performNetworkRequest(method: .get, url: url)\n    }\n}"
    },
    {
      "timestamp": "8:43",
      "title": "Update performGETRequest function",
      "language": "swift",
      "code": "extension Smoothie {\n  \n    // Omitted for brevity. See previous code snippet for content.\n  \n    static func performGETRequest(to url: URL) -> Data? {\n        return performNetworkRequest(method: .get, url: url)\n    }\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2020/10221/2/6B07FDD7-B950-4B25-BA94-E07A733F537F/wwdc2020_10221_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2020/10221/2/6B07FDD7-B950-4B25-BA94-E07A733F537F/wwdc2020_10221_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "110361",
      "year": "2022",
      "title": "Author fast and reliable tests for Xcode Cloud",
      "url": "https://developer.apple.com/videos/play/wwdc2022/110361"
    },
    {
      "id": "10220",
      "year": "2020",
      "title": "Handle interruptions and alerts in UI tests",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10220"
    },
    {
      "id": "10687",
      "year": "2020",
      "title": "Triage test failures with XCTIssue",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10687"
    },
    {
      "id": "10091",
      "year": "2020",
      "title": "Write tests to fail",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10091"
    },
    {
      "id": "10164",
      "year": "2020",
      "title": "XCTSkip your tests",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10164"
    },
    {
      "id": "411",
      "year": "2019",
      "title": "Getting Started with Instruments",
      "url": "https://developer.apple.com/videos/play/wwdc2019/411"
    }
  ],
  "extractedAt": "2025-07-18T09:43:48.640Z"
}