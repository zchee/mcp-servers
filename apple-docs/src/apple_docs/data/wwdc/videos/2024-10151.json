{
  "id": "10151",
  "year": "2024",
  "url": "https://developer.apple.com/videos/play/wwdc2024/10151/",
  "title": "Create custom visual effects with SwiftUI",
  "speakers": [],
  "duration": "",
  "topics": [
    "Design",
    "Graphics & Games"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "Hello, and welcome to Create Custom Visual Effects in SwiftUI. My name is Philip, and I'll be joined in a bit by Rob. Together, we're going to share how you can create visual effects, to make apps that are more expressive and pleasant to use. Building a great app experience is often the result of making many small improvements. Small details, that in aggregate make a big difference. Visual effects can play an outsized role and how an app is used and perceived. They can show that a feature is working as expected. Add personality to your app surface, and focus attention on something important that's happening. When I'm creating a new visual effect, I'm often not sure what will work, until I start building. I need to experiment, tinker, and play with ideas until things feel right. In this session, Rob and I are going to build out a number of examples and explore how using SwiftUI, you can create custom scroll effects, bring rich color treatment to your apps with mesh gradients, compose custom view transitions, create beautiful text transitions using text renders, and write metal shaders to create advanced graphic effects. We're going to start with something we're all probably familiar with, scrolling. So much of our app experiences, are collections of items that we scroll through. Whether they be photos, videos, or text blocks. Scroll views are everywhere.\n\nHere, I have a simple collection of photos inside a horizontal scrollview. In SwiftUI, scroll views provide a lot of automatic support for common use cases.\n\nHere, I'm using a paging behavior to get a pagination effect. This is fine for a standard scroll view. But I'd like to create something a bit more unique.\n\nLet's take a look at a single photo.\n\nSwiftUI's scroll transition modifier, can be used to change a standard collection of elements into something custom.\n\nScroll transition exposes the content I'd like to transition, as well as a phase.\n\nI can use these values to change the rotation, and offset of each photo in my scroll view. Based on its position.\n\nAs I scroll, the photos on the leading and trailing edges are rotated, creating a circular carousel effect.\n\nI can use the value property to determine how far off screen my images is and use that for rotation. And if my view is fully on screen, the isIdentity property will be true.\n\nThis rotation effect is nice, but it doesn't really fit the metaphor I'd like to use here. I'd like each of these cards to feel as if they're a window, that you can look through.\n\nBy changing the modifiers, my scrollTransition is updating. I have the ability to completely change the feel of this scrollview to create a parallax effect.\n\nHere Iâ€™m using the scrollTransition to change the xOffset of the image but not the shape thatâ€™s clipping it. scrollTransition can be used to manipulate this content in tons of different ways! I can take this modifier and put it on any content that I want to update based on the scroll value. Here Iâ€™ve added a scroll transition to a text caption, underneath my image so that it fades out and offsets to amplify the momentum of the scrollview.\n\nScrollTransitions are a great way to build interesting, unique scroll experiences. Sometimes though you need a bit more control over how a views position or size affects its visual appearance.\n\nHere I have a simple collection of grocery items that I can scroll through. Right now, each item is the same color, which looks monotonous.\n\nI can add a visualEffect modifier which provides access to a content placeholder and a proxy. The content placeholder works the same as in the scrollTransition. The proxy can give me the geometry values of the view.\n\nI can use the location of the view from the proxy and use it to change the hue of my view which creates a nice gradient effect. The lower the view on my device, the stronger the hue rotation.\n\nThe visual effect modifier lets you change visual properties based on the view position and size in a performant way, which means itâ€™s great for use in scrollviews.\n\nInstead of changing the color, I could change other visual properties. Here Iâ€™m taking the same y position of my shape, and using it to offset, scale, fade, and blur an element as it gets to the top of the scrollview. The ScrollTransition and VisualEffect modifiers are great ways to create custom scrollview effects.\n\nYou can use them to create scrollviews that adjust scale based on the position of an element on the screen.\n\nYou could use them to change the perspective, by using different transforms like rotation and skew.\n\nUse offsets to create stacking behavior, or adjust color properties like brightness, saturation and hue to create emphasis and provide clarity.\n\nItâ€™s not always clear though if an effect is right for your app, or if itâ€™s distracting. Itâ€™s helpful to spend time living with visual experiments. Visual effects should be pleasant to use well after the novelty has worn off. Testing your effects over time, and in different contexts will help reinforce if an effect is working, or where it still needs improvement. Next, letâ€™s talk about how you can bring color effects to your app. Color plays an important role in an interface. It can help give your app an identity, focus attention, or clarify intent. SwiftUI has a lot of tools for bringing color into your app. Thereâ€™s support for different gradient types, color controls, blend modes and much more.\n\nNew in SwiftUI is support for Mesh Gradients. Mesh gradients are useful when you want a dynamic background, or need to add some visual distinction to a surface.\n\nMesh Gradients are made from a grid of points. Each of these of these points has a color associated with it.\n\nSwiftUI interpolates between these colors on the grid to create a color fill.\n\nThese points can be moved to create beautiful color effects. The colors blend together smoothly, and points that are closer together have sharper color transition.\n\nIn order to create a Mesh Gradient, Iâ€™ll use the new MeshGradient view.\n\nIâ€™ll define the rows and columns of my grid using the width and height parameters. In this case, Iâ€™ll use a 3 by 3 grid.\n\nNext, weâ€™re going to define where the X and Y coordinates on this 3x3 grid are located. Points in the grid are defined using SIMD2 float values. When used as a view, these floats take a value from 0 to 1 on the X and Y axis.\n\nFinally, Iâ€™ll add a corresponding color for each of these points.\n\nThis creates our mesh gradient! Right now it looks a bit like a linear gradient. If I move the X and Y coordinates of the center point, the colors move to match the new position! Mesh gradients are a nice way to add color effects to your app, and you can use them to create all sorts of visual effects. They can be purely decorative, but you can also use them to match a surface with imagery, or even signal that something has changed through a mesh gradient animation! Play around with values, like the position of control points, grid size, and color palette. Tweaking parameters, and exploring the edges of whatâ€™s visually possible will lead you far beyond any ideas you have at the beginning, so be bold! Turn the dials up to 100 and make something new! Next letâ€™s talk about creating custom transitions. Our interfaces are a portal into what are app is doing behind the scenes, and transitions are a useful way to communicate the changes that are happening.\n\nTransitions are useful when you want to show new views, or remove views that arenâ€™t needed anymore.\n\nThey can help provide context as to what changed and why the change occurred. Sometimes these transitions are due to the tap of a button, or the drag of an element. Sometimes they are triggered by the behavior of someone else using an app.\n\nI have an Avatar View that shows and hides based on that persons online status. If they are online, Iâ€™d like their avatar to show, and otherwise it should be hidden. Right now, it just appears and disappears. This is a bit jarring, so let's add a transition.\n\nWe can apply one of SwiftUI's standard transitions, like scale, to have it scale up and down as it enters and exits.\n\nIf we want to change multiple transitions, we can use the combined method to add another. Letâ€™s combine our scale transition with opacity.\n\nThis is looking better, but what if we want something more custom? In order to create a custom transition, Iâ€™ll create a new Struct. I'll call it Twirl. This will conform to the Transition protocol.\n\nThe Transition body function takes a content and phase parameter. The content parameter works the same as what I shared for the scrollviews, as a placeholder for the content I want to transition. I can use the phase value to check if a view is currently being shown and use that to conditionally style my view. For scale, Iâ€™d like it to be at full scale when itâ€™s shown, and at half the scale when itâ€™s not For opacity, Iâ€™d like my element to toggle between fully visible and hidden.\n\nI can attach my custom transition to my view and check out the result.\n\nBack in my custom transition, Iâ€™d like to add blur so that it looks like the avatar is coming in and out of focus. And also add some rotation so that it spins.\n\nI can check my phase value for whether or not a view will appear, or did disappear. This will let me continue rotating the same direction on exit, by using a negative value.\n\nFinally, Iâ€™ll add a brightness modifier, so that when the view is entering it has a bit of shine and catches attention.\n\nWith a few small adjustments, we're able to make our interface element respond to changes in a graceful way.\n\nTransitions can be used in many types of scenarios. To ease an element into view as itâ€™s loading, introduce an important piece of information. Or make a graphical element feel dynamic.\n\nA good transition will fit naturally within its larger context, and not feel like it was tacked on. Looking at your app holistically, can help you decide what transitions are the right fit for your app. Speaking of transitions, Iâ€™ll hand it off to Robb to talk about text transitions.\n\nThanks, Phillip. Let's dive in.\n\nPhilip already explained how to use the built-in SwiftUI transitions to animate in Views, like this opacity transition. While I could definitely spice it up using the built-in modifiers, I'd like to try animating the Text in line-by-line.\n\nTo do this, I'll use TextRenderer. A new API introduced in iOS 18 and aligned releases. TextRenderer is a powerful new protocol that allows you to customize, how SwiftUI Text is drawn for an entire View tree. This enables a whole new range of custom Text drawing possibilities, but the one I'm most excited about is animation.\n\nThe core of the TextRenderer protocol is the draw(layout:in:) method. Its arguments are a Text.Layout and a GraphicsContext. Text.Layout is what allows us to access the individual components of the Text, its Lines, Runs and Glyphs. The GraphicsContext is the same type that is used by the Canvas view. Check out Add rich graphics to your SwiftUI app, if you'd like to know more about how to draw with it.\n\nFor a minimal TextRenderer, I only need to iterate over the individual lines of the layout using a for-loop and draw them into the context. This will give me the default rendering behavior.\n\nTo drive my transition, I add three properties to my TextRenderer, elapsedTime: how much time has passed so far. elementDuration: how much time should be spent animating an individual line or character. and totalDuration: How much time the entire transition will take. To have SwiftUI automatically animate the elapsedTime value for me, I implement the Animatable protocol. It's simple to adopt in this case by forwarding the animatableData property to elapsedTime.\n\nNow I can start iterating on my animation. First, I'll try animating line by line. To distribute the available time evenly across the animation, I need to calculate the amount of delay, between two consecutive lines using this helper function I called, elementDelay(count:). Next, I enumerate all lines and calculate their relative start time, based on their index and that delay value. The time that has passed for an individual line is the overall elapsed time, minus the element's individual time offset. I also clamp this value. Next, I create a copy of the current graphics context. This will make sure that individual calls to my helper function will not affect each other since GraphicsContext has value semantics. Finally I call my helper function to draw the individual line.\n\nThis is where the magic happens. Before I draw the line, I update the properties of the GraphicsContext that I want to animate. To make this easier, I also calculate fractional progress value.\n\nFirst, I want the line to fade-in so I calculate a quick opacity ramp.\n\nAt the same time, I decrease its blur radius to 0 to give the impression the line manifests from a diffuse state.\n\nThe initial blurRadius is based on the height of the line that I read from the line's typographicBounds property.\n\nLastly, I animate a translation on the y axis using a spring.\n\nI start at a y position that is shifted upwards based on the length of the line's descender. Finally, I draw the line using the new draw options method.\n\nBy opting out of subpixel quantization, I can avoid jitter as my spring settles.\n\nIn order to use the Renderer to animate in Text, I implement a custom Transition like Philip explained earlier. By experimenting, I found that 0.9 seconds feels like a good duration for my use case. However, I need to consider that there could already be an animation on the current transaction. For example, when this transition was triggered from a call to withAnimation.\n\nUsing the transaction body view modifier, I can override the animation when appropriate. This way, I can ensure an even, linear pacing for every line. Then, I use the new textRenderer view modifier and set my custom renderer on the view being transitioned in or out.\n\nHere's the Transition in action.\n\nI like it, but I don't love it. It's dependent on the number of lines, which can change based on locale or Dynamic Type size. Also, it doesn't quite capture my excitement for Visual Effects. Let's try animating every glyph individually.\n\nTo do that, I need iterate over the Text.Layout's run slices. They represent the smallest unit of layout, like glyphs or embedded images.\n\nA Text.Layout is a Collection of lines. A line is a Collection of Runs and a Run is a collection of RunSlices.\n\nTherefore, using this helper method called flattenedRunSlices, I just need to iterate over the RunSlices instead and get to keep almost all of my logic.\n\nI also need to revisit my helper function, but all I need to do here its change the type and name of its Line argument, to a RunSlice.\n\nHere's the result in action. I think that's better, but now I have the opposite problem. There's very little time left in the animation to dedicate to an individual glyph. This reduces the overall impact, making the transition feel less fun and a little same-y? I think I need to dial it back a little. Instead of animating everything the same way, I'll focus only on the words Visual Effects.\n\nThat way I can use the Transition, not only to bring in the content but also to emphasize what's important.\n\nTo do that, I'm using the new TextAttribute protocol introduced alongside TextRenderer in iOS 18 and aligned releases. By implementing this protocol, I can pass data from my Text, to my TextRenderer.\n\nApplying the attribute is very simple. Using the customAttribute Text modifier, I mark the words Visual Effects using my custom EmphasisAttribute. Because it's only used to mark a range of text, I don't actually need to add any member variables to my TextAttribute struct.\n\nRevisiting the draw method one last time, I now iterate over the flattened runs of my layout. I check the presence of the EmphasisAttribute on the run using a subscript with the Attribute-Type as its key. If the attribute is present, I iterate over the slices in the exact same manner as I did before. If the attribute is absent, I'll quickly fade in the run over the course of 0.2 seconds.\n\nHere's the final result. This is much better. The Transition now really emphasizes Visual Effects.\n\nTextRenderer opens a whole range of new possibilities. By breaking a View into smaller components that animate individually, you can build more expressive animations and visual effects. And there's another powerful graphics API in SwiftUI, that offers even more fine-grained control, Shaders. Shaders are small programs that calculate various rendering effects, directly on your device's GPU. SwiftUI uses shaders internally to implement many of the visual effects Philip showed you earlier, like the new Mesh Gradients. With SwiftUI Shaders introduced in iOS 17 and aligned releases, you'll be able to unlock the same level of performance and write your own impressive effects.\n\nYou instantiate a Shader in SwiftUI by calling a function with its name on ShaderLibrary. Here, you can also pass additional parameters to your Shader function, like colors, numbers, or an image. When you apply this effect to a view using the layerEffect view modifier, SwiftUI will call your shader function for every single pixel of your view.\n\nThat's a lot of pixels. To make this possible in real time, Shaders run on your device's GPU which is optimized for highly parallel tasks such as this. However, because of the specialized nature of GPU programming, the Shaders themselves cannot be written in Swift. Instead, they are written in the Metal Shading Language, or Metal for short.\n\nHere's the corresponding Metal file of the Shader I showed you earlier. The name of the Shader function matches the invocation on ShaderLibrabry.\n\nThis is the function that SwiftUI will execute, on the GPU, for each of your views pixels and when it does, the position argument refers to that pixel's location. The layer argument meanwhile is a representation of your views content. You can sample the layer to obtain its contents, but you must stay within the maxSampleOffset that the shader was instantiated with, relative to position.\n\nSwiftUI also resolves and converts types, such as Color to representations that can be used in Metal. Here, my pink color gets converted to a half4. Metal makes heavy use of vector types like this, a half4 is a four-component vector of 16-bit floating point numbers. This type encodes the red, green, blue and alpha components of the color. Similarly, float2 is a two-component vector of 32-bit floating point numbers and frequently used for 2D points or dimensions.\n\nIn SwifUI, Shaders can be used for Custom Fills and 3 kinds of Effects: Color Effects, Distortion Effects, and Layer Effects. Of the three Effects, Layer Effects are the most powerful and effectively a superset of the other two, so I'll show you how to write a Layer Effect.\n\nCurrently, I have this PushEffect installed on my view that is triggered whenever I tap it. The view scales down using a spring, then immediately pops back up. This gives me direct feedback for my interaction, but the animation does not respond to where I touch it. This makes it feel lifeless and stiff.\n\nInstead, I would like it to look more like this. Whenever I touch the view, the scale effect spreads outwards from the touch location. Affecting every pixel of my view differently. With SwiftUI Shaders, I now have the tools I need to make an effect like this reality.\n\nTo implement this effect, I add a new Shader function to my metal file that I call Ripple. I add the two arguments required by the layer effect API, position and Layer.\n\nI've already worked out the formula that describes each pixel's output. It's a function of the point at which the view was touched, how much time has passed as well as these four parameters.\n\nI calculate the distortion for this pixel, leaving me with this newPosition value. This is where I sample the view.\n\nAfter some tweaking based on the strength of the distortion, I return the modified color. Next, I need to call this Shader Function from SwiftUI.\n\nTo do that, I create this ViewModifier called RippleModifier, exposes all the parameters of the Shader function to SwiftUI. In its body(content:) method, it instantiates the shader and applies it to its content.\n\nBecause Shaders have no concept of time, we also need to drive the animation from SwiftUI.\n\nHere's how I do that, I wrote a second ViewModifier called RippleEffect. The keyframeAnimator view modifier makes it easy, to run animations based on external changes, like gestures. I animate the elapsedTime from zero to its final duration value, whenever the trigger value updates. This way, at every step of the animation, RippleModifier will be passed the current time and the origin point at which I touched the view.\n\nBut wait, I never assigned values to the four parameters I showed you earlier. And I'll be honest, I have no idea what values would look good here. I'll just have to experiment, so I built myself this debug UI.\n\nBecause RippleModifier does perform any animation itself, I can use it to scrub forwards and backwards, through the animation interactively. This way, I can dial in the right parameters for my shader function on my Phone or inside an Xcode preview.\n\nBuilding great experiences requires a lot of trial and error, and Debug UI is a great way to iterate on complex animations. This can mean exposing parameters or drawing an overlay, that visualizes intermediate values. Getting immediate feedback like this is incredibly powerful and makes it easier to quickly iterate. And thatâ€™s important because there are so many possibilities, for what you can create with Shaders.\n\nYou can use Shaders to create an animated fill to add texture to your app. You can combine Shaders and TextRenderer to apply distortion to Text, or use them to create gradient maps for unique photo effects.\n\nIn this video we looked at a number of ways to create visual effects with SwiftUI. And we encourage you to put your own spin on these ideas.\n\nExperiment with custom scroll effects to set your app apart. Add a splash of color with mesh gradients. Treat your app to some custom view transitions. Make text come alive with the new text renderer API. Build a wild new experience with a Metal shader.\n\nUse these tools to invent something new! Thank you for watching.",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "1:45",
      "title": "Scroll view with pagination",
      "language": "swift",
      "code": "ScrollView(.horizontal) {\n    LazyHStack(spacing: 22) {\n        ForEach(animals, id: \\.self) { animal in\n            AnimalPhoto(image: animal)\n        }\n    }.scrollTargetLayout()\n    \n}\n.contentMargins(.horizontal, 44)\n.scrollTargetBehavior(.paging)"
    },
    {
      "timestamp": "2:30",
      "title": "Rotation effect",
      "language": "swift",
      "code": "AnimalPhoto(image: animal)\n    .scrollTransition(\n        axis: .horizontal\n    ) { content, phase in\n        content\n            .rotationEffect(.degrees(phase.value * 2.5))\n            .offset(y: phase.isIdentity ? 0 : 8)\n    }"
    },
    {
      "timestamp": "3:14",
      "title": "Parallax Effect",
      "language": "swift",
      "code": "ScrollView(.horizontal) {\n    LazyHStack(spacing: 16) {\n        ForEach(animals, id: \\.self) { animal in\n            VStack(spacing: 8) {\n                ZStack {\n                    AnimalPhoto(image: animal)\n                        .scrollTransition(\n                            axis: .horizontal\n                        ) { content, phase in\n                            return content\n                                .offset(x: phase.value * -250)\n                        }\n                }\n                .containerRelativeFrame(.horizontal)\n                .clipShape(RoundedRectangle(cornerRadius: 32))\n        }\n        \n    }.scrollTargetLayout()\n}\n.contentMargins(.horizontal, 32)\n.scrollTargetBehavior(.paging)"
    },
    {
      "timestamp": "4:41",
      "title": "Visual effect hue rotation",
      "language": "swift",
      "code": "RoundedRectangle(cornerRadius: 24)\n    .fill(.purple)\n    .visualEffect({ content, proxy in\n        content\n            .hueRotation(Angle(degrees: proxy.frame(in: .global).origin.y / 10))\n            \n    })"
    },
    {
      "timestamp": "7:30",
      "title": "Mesh gradient",
      "language": "swift",
      "code": "MeshGradient(\n    width: 3,\n    height: 3,\n    points: [\n        [0.0, 0.0], [0.5, 0.0], [1.0, 0.0],\n        [0.0, 0.5], [0.9, 0.3], [1.0, 0.5],\n        [0.0, 1.0], [0.5, 1.0], [1.0, 1.0]\n    ],\n    colors: [\n        .black,.black,.black,\n        .blue, .blue, .blue,\n        .green, .green, .green\n    ]\n)"
    },
    {
      "timestamp": "10:36",
      "title": "Custom transition",
      "language": "swift",
      "code": "struct Twirl: Transition {\n    func body(content: Content, phase: TransitionPhase) -> some View {\n        content\n            .scaleEffect(phase.isIdentity ? 1 : 0.5)\n            .opacity(phase.isIdentity ? 1 : 0)\n            .blur(radius: phase.isIdentity ? 0 : 10)\n            .rotationEffect(\n                .degrees(\n                    phase == .willAppear ? 360 :\n                        phase == .didDisappear ? -360 : .zero\n                )\n            )\n            .brightness(phase == .willAppear ? 1 : 0)\n    }\n}"
    },
    {
      "timestamp": "13:29",
      "title": "The Minimum Viable TextRenderer",
      "language": "swift",
      "code": "// The Minimum Viable TextRenderer\n\nstruct AppearanceEffectRenderer: TextRenderer {\n    func draw(layout: Text.Layout, in context: inout GraphicsContext) {\n        for line in layout {\n            context.draw(line)\n        }\n    }\n}"
    },
    {
      "timestamp": "14:01",
      "title": "A Custom Text Transition",
      "language": "swift",
      "code": "import SwiftUI\n\n#Preview(\"Text Transition\") {\n    @Previewable @State var isVisible: Bool = true\n\n    VStack {\n        GroupBox {\n            Toggle(\"Visible\", isOn: $isVisible.animation())\n        }\n\n        Spacer()\n\n        if isVisible {\n            let visualEffects = Text(\"Visual Effects\")\n                .customAttribute(EmphasisAttribute())\n                .foregroundStyle(.pink)\n                .bold()\n\n            Text(\"Build \\(visualEffects) with SwiftUI ðŸ§‘â€ðŸ’»\")\n                .font(.system(.title, design: .rounded, weight: .semibold))\n                .frame(width: 250)\n                .transition(TextTransition())\n        }\n\n        Spacer()\n    }\n    .multilineTextAlignment(.center)\n    .padding()\n}\n\nstruct EmphasisAttribute: TextAttribute {}\n\n/// A text renderer that animates its content.\nstruct AppearanceEffectRenderer: TextRenderer, Animatable {\n    /// The amount of time that passes from the start of the animation.\n    /// Animatable.\n    var elapsedTime: TimeInterval\n\n    /// The amount of time the app spends animating an individual element.\n    var elementDuration: TimeInterval\n\n    /// The amount of time the entire animation takes.\n    var totalDuration: TimeInterval\n\n    var spring: Spring {\n        .snappy(duration: elementDuration - 0.05, extraBounce: 0.4)\n    }\n\n    var animatableData: Double {\n        get { elapsedTime }\n        set { elapsedTime = newValue }\n    }\n\n    init(elapsedTime: TimeInterval, elementDuration: Double = 0.4, totalDuration: TimeInterval) {\n        self.elapsedTime = min(elapsedTime, totalDuration)\n        self.elementDuration = min(elementDuration, totalDuration)\n        self.totalDuration = totalDuration\n    }\n\n    func draw(layout: Text.Layout, in context: inout GraphicsContext) {\n        for run in layout.flattenedRuns {\n            if run[EmphasisAttribute.self] != nil {\n                let delay = elementDelay(count: run.count)\n\n                for (index, slice) in run.enumerated() {\n                    // The time that the current element starts animating,\n                    // relative to the start of the animation.\n                    let timeOffset = TimeInterval(index) * delay\n\n                    // The amount of time that passes for the current element.\n                    let elementTime = max(0, min(elapsedTime - timeOffset, elementDuration))\n\n                    // Make a copy of the context so that individual slices\n                    // don't affect each other.\n                    var copy = context\n                    draw(slice, at: elementTime, in: &copy)\n                }\n            } else {\n                // Make a copy of the context so that individual slices\n                // don't affect each other.\n                var copy = context\n                // Runs that don't have a tag of `EmphasisAttribute` quickly\n                // fade in.\n                copy.opacity = UnitCurve.easeIn.value(at: elapsedTime / 0.2)\n                copy.draw(run)\n            }\n        }\n    }\n\n    func draw(_ slice: Text.Layout.RunSlice, at time: TimeInterval, in context: inout GraphicsContext) {\n        // Calculate a progress value in unit space for blur and\n        // opacity, which derive from `UnitCurve`.\n        let progress = time / elementDuration\n\n        let opacity = UnitCurve.easeIn.value(at: 1.4 * progress)\n\n        let blurRadius =\n            slice.typographicBounds.rect.height / 16 *\n            UnitCurve.easeIn.value(at: 1 - progress)\n\n        // The y-translation derives from a spring, which requires a\n        // time in seconds.\n        let translationY = spring.value(\n            fromValue: -slice.typographicBounds.descent,\n            toValue: 0,\n            initialVelocity: 0,\n            time: time)\n\n        context.translateBy(x: 0, y: translationY)\n        context.addFilter(.blur(radius: blurRadius))\n        context.opacity = opacity\n        context.draw(slice, options: .disablesSubpixelQuantization)\n    }\n\n    /// Calculates how much time passes between the start of two consecutive\n    /// element animations.\n    ///\n    /// For example, if there's a total duration of 1 s and an element\n    /// duration of 0.5 s, the delay for two elements is 0.5 s.\n    /// The first element starts at 0 s, and the second element starts at 0.5 s\n    /// and finishes at 1 s.\n    ///\n    /// However, to animate three elements in the same duration,\n    /// the delay is 0.25 s, with the elements starting at 0.0 s, 0.25 s,\n    /// and 0.5 s, respectively.\n    func elementDelay(count: Int) -> TimeInterval {\n        let count = TimeInterval(count)\n        let remainingTime = totalDuration - count * elementDuration\n\n        return max(remainingTime / (count + 1), (totalDuration - elementDuration) / count)\n    }\n}\n\nextension Text.Layout {\n    /// A helper function for easier access to all runs in a layout.\n    var flattenedRuns: some RandomAccessCollection<Text.Layout.Run> {\n        self.flatMap { line in\n            line\n        }\n    }\n\n    /// A helper function for easier access to all run slices in a layout.\n    var flattenedRunSlices: some RandomAccessCollection<Text.Layout.RunSlice> {\n        flattenedRuns.flatMap(\\.self)\n    }\n}\n\nstruct TextTransition: Transition {\n    static var properties: TransitionProperties {\n        TransitionProperties(hasMotion: true)\n    }\n\n    func body(content: Content, phase: TransitionPhase) -> some View {\n        let duration = 0.9\n        let elapsedTime = phase.isIdentity ? duration : 0\n        let renderer = AppearanceEffectRenderer(\n            elapsedTime: elapsedTime,\n            totalDuration: duration\n        )\n\n        content.transaction { transaction in\n            // Force the animation of `elapsedTime` to pace linearly and\n            // drive per-glyph springs based on its value.\n            if !transaction.disablesAnimations {\n                transaction.animation = .linear(duration: duration)\n            }\n        } body: { view in\n            view.textRenderer(renderer)\n        }\n    }\n}"
    },
    {
      "timestamp": "22:55",
      "title": "A simple ripple effect Metal shader",
      "language": "swift",
      "code": "// Insert #include <metal_stdlib>\n#include <SwiftUI/SwiftUI.h>\nusing namespace metal;\n\n[[ stitchable ]]\nhalf4 Ripple(\n    float2 position,\n    SwiftUI::Layer layer,\n    float2 origin,\n    float time,\n    float amplitude,\n    float frequency,\n    float decay,\n    float speed\n) {\n    // The distance of the current pixel position from `origin`.\n    float distance = length(position - origin);\n    // The amount of time it takes for the ripple to arrive at the current pixel position.\n    float delay = distance / speed;\n\n    // Adjust for delay, clamp to 0.\n    time -= delay;\n    time = max(0.0, time);\n\n    // The ripple is a sine wave that Metal scales by an exponential decay\n    // function.\n    float rippleAmount = amplitude * sin(frequency * time) * exp(-decay * time);\n\n    // A vector of length `amplitude` that points away from position.\n    float2 n = normalize(position - origin);\n\n    // Scale `n` by the ripple amount at the current pixel position and add it\n    // to the current pixel position.\n    //\n    // This new position moves toward or away from `origin` based on the\n    // sign and magnitude of `rippleAmount`.\n    float2 newPosition = position + rippleAmount * n;\n\n    // Sample the layer at the new position.\n    half4 color = layer.sample(newPosition);\n\n    // Lighten or darken the color based on the ripple amount and its alpha\n    // component.\n    color.rgb += 0.3 * (rippleAmount / amplitude) * color.a;\n\n    return color;\n}"
    },
    {
      "timestamp": "23:36",
      "title": "A Custom Ripple Effect",
      "language": "swift",
      "code": "import SwiftUI\n\n#Preview(\"Ripple\") {\n    @Previewable @State var counter: Int = 0\n    @Previewable @State var origin: CGPoint = .zero\n\n    VStack {\n        Spacer()\n\n        Image(\"palm_tree\")\n            .resizable()\n            .aspectRatio(contentMode: .fit)\n            .clipShape(RoundedRectangle(cornerRadius: 24))\n            .onPressingChanged { point in\n                if let point {\n                    origin = point\n                    counter += 1\n                }\n            }\n            .modifier(RippleEffect(at: origin, trigger: counter))\n            .shadow(radius: 3, y: 2)\n\n        Spacer()\n    }\n    .padding()\n}\n\n#Preview(\"Ripple Editor\") {\n    @Previewable @State var origin: CGPoint = .zero\n    @Previewable @State var time: TimeInterval = 0.3\n    @Previewable @State var amplitude: TimeInterval = 12\n    @Previewable @State var frequency: TimeInterval = 15\n    @Previewable @State var decay: TimeInterval = 8\n\n    VStack {\n        GroupBox {\n            Grid {\n                GridRow {\n                    VStack(spacing: 4) {\n                        Text(\"Time\")\n                        Slider(value: $time, in: 0 ... 2)\n                    }\n                    VStack(spacing: 4) {\n                        Text(\"Amplitude\")\n                        Slider(value: $amplitude, in: 0 ... 100)\n                    }\n                }\n                GridRow {\n                    VStack(spacing: 4) {\n                        Text(\"Frequency\")\n                        Slider(value: $frequency, in: 0 ... 30)\n                    }\n                    VStack(spacing: 4) {\n                        Text(\"Decay\")\n                        Slider(value: $decay, in: 0 ... 20)\n                    }\n                }\n            }\n            .font(.subheadline)\n        }\n\n        Spacer()\n\n        Image(\"palm_tree\")\n            .resizable()\n            .aspectRatio(contentMode: .fit)\n            .clipShape(RoundedRectangle(cornerRadius: 24))\n            .modifier(RippleModifier(origin: origin, elapsedTime: time, duration: 2, amplitude: amplitude, frequency: frequency, decay: decay))\n            .shadow(radius: 3, y: 2)\n            .onTapGesture {\n                origin = $0\n            }\n\n        Spacer()\n    }\n    .padding(.horizontal)\n}\n\nstruct PushEffect<T: Equatable>: ViewModifier {\n    var trigger: T\n\n    func body(content: Content) -> some View {\n        content.keyframeAnimator(\n            initialValue: 1.0,\n            trigger: trigger\n        ) { view, value in\n            view.visualEffect { view, _ in\n                view.scaleEffect(value)\n            }\n        } keyframes: { _ in\n            SpringKeyframe(0.95, duration: 0.2, spring: .snappy)\n            SpringKeyframe(1.0, duration: 0.2, spring: .bouncy)\n        }\n    }\n}\n\n/// A modifer that performs a ripple effect to its content whenever its\n/// trigger value changes.\nstruct RippleEffect<T: Equatable>: ViewModifier {\n    var origin: CGPoint\n\n    var trigger: T\n\n    init(at origin: CGPoint, trigger: T) {\n        self.origin = origin\n        self.trigger = trigger\n    }\n\n    func body(content: Content) -> some View {\n        let origin = origin\n        let duration = duration\n\n        content.keyframeAnimator(\n            initialValue: 0,\n            trigger: trigger\n        ) { view, elapsedTime in\n            view.modifier(RippleModifier(\n                origin: origin,\n                elapsedTime: elapsedTime,\n                duration: duration\n            ))\n        } keyframes: { _ in\n            MoveKeyframe(0)\n            LinearKeyframe(duration, duration: duration)\n        }\n    }\n\n    var duration: TimeInterval { 3 }\n}\n\n/// A modifier that applies a ripple effect to its content.\nstruct RippleModifier: ViewModifier {\n    var origin: CGPoint\n\n    var elapsedTime: TimeInterval\n\n    var duration: TimeInterval\n\n    var amplitude: Double = 12\n    var frequency: Double = 15\n    var decay: Double = 8\n    var speed: Double = 1200\n\n    func body(content: Content) -> some View {\n        let shader = ShaderLibrary.Ripple(\n            .float2(origin),\n            .float(elapsedTime),\n\n            // Parameters\n            .float(amplitude),\n            .float(frequency),\n            .float(decay),\n            .float(speed)\n        )\n\n        let maxSampleOffset = maxSampleOffset\n        let elapsedTime = elapsedTime\n        let duration = duration\n\n        content.visualEffect { view, _ in\n            view.layerEffect(\n                shader,\n                maxSampleOffset: maxSampleOffset,\n                isEnabled: 0 < elapsedTime && elapsedTime < duration\n            )\n        }\n    }\n\n    var maxSampleOffset: CGSize {\n        CGSize(width: amplitude, height: amplitude)\n    }\n}\n\nextension View {\n    func onPressingChanged(_ action: @escaping (CGPoint?) -> Void) -> some View {\n        modifier(SpatialPressingGestureModifier(action: action))\n    }\n}\n\nstruct SpatialPressingGestureModifier: ViewModifier {\n    var onPressingChanged: (CGPoint?) -> Void\n\n    @State var currentLocation: CGPoint?\n\n    init(action: @escaping (CGPoint?) -> Void) {\n        self.onPressingChanged = action\n    }\n\n    func body(content: Content) -> some View {\n        let gesture = SpatialPressingGesture(location: $currentLocation)\n\n        content\n            .gesture(gesture)\n            .onChange(of: currentLocation, initial: false) { _, location in\n                onPressingChanged(location)\n            }\n    }\n}\n\nstruct SpatialPressingGesture: UIGestureRecognizerRepresentable {\n    final class Coordinator: NSObject, UIGestureRecognizerDelegate {\n        @objc\n        func gestureRecognizer(\n            _ gestureRecognizer: UIGestureRecognizer,\n            shouldRecognizeSimultaneouslyWith other: UIGestureRecognizer\n        ) -> Bool {\n            true\n        }\n    }\n\n    @Binding var location: CGPoint?\n\n    func makeCoordinator(converter: CoordinateSpaceConverter) -> Coordinator {\n        Coordinator()\n    }\n\n    func makeUIGestureRecognizer(context: Context) -> UILongPressGestureRecognizer {\n        let recognizer = UILongPressGestureRecognizer()\n        recognizer.minimumPressDuration = 0\n        recognizer.delegate = context.coordinator\n\n        return recognizer\n    }\n\n    func handleUIGestureRecognizerAction(\n        _ recognizer: UIGestureRecognizerType, context: Context) {\n            switch recognizer.state {\n                case .began:\n                    location = context.converter.localLocation\n                case .ended, .cancelled, .failed:\n                    location = nil\n                default:\n                    break\n            }\n        }\n    }"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Creating visual effects with SwiftUI",
        "url": "https://developer.apple.com/documentation/SwiftUI/Creating-visual-effects-with-SwiftUI"
      },
      {
        "title": "Forum: UI Frameworks",
        "url": "https://developer.apple.com/forums/topics/ui-frameworks?cid=vf-a-0010"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2024/10151/4/8FDE6F53-E002-4F16-B401-64D22DFD6889/downloads/wwdc2024-10151_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2024/10151/4/8FDE6F53-E002-4F16-B401-64D22DFD6889/downloads/wwdc2024-10151_sd.mp4?dl=1"
  },
  "extractedAt": "2025-07-18T09:35:59.567Z"
}