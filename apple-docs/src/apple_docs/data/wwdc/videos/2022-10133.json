{
  "id": "10133",
  "year": "2022",
  "url": "https://developer.apple.com/videos/play/wwdc2022/10133/",
  "title": "Build a productivity app for Apple Watch",
  "speakers": [],
  "duration": "",
  "topics": [
    "Essentials"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "Anne: Hello, and welcome! I'm Anne Hitchcock, and I'm a watchOS software engineer. Today, I want to show you how to create a productivity app on watchOS. Since the introduction of SwiftUI and Independent Watch apps in watchOS 6, you've been able to do more in your Watch apps. Each year, SwiftUI on watchOS gets more capabilities. At the same time, watchOS has gotten new features, like the keyboard, that let you build whole new kinds of apps for Watch. I'd like to show you how to knit together some of those features to build an app to track a list of things to get done. We're going to create a new Watch app, add a simple list of items to display, Let people add items to the list, and then edit the items.\n\nAs we add these features, we'll talk about common app navigation strategies in Watch apps and how to pick the correct one.\n\nWe'll share items with a friend to share the load.\n\nThen we'll add a chart to our app to help us spot productivity trends and keep us motivated.\n\nAnd we'll use the Digital Crown to make our chart scrollable to show a larger data range.\n\nLet's get started by creating a new app.\n\nCreate a new project in Xcode.\n\nIn the watchOS tab, choose App and click Next.\n\nAfter choosing a product name, you have a couple of choices. The most important one is whether to create a Watch-only App or to create a Watch app with a companion iOS app. Let's talk about what makes a great Watch app and when you want a companion iOS app.\n\nGreat Watch apps enable quick interaction, like the interface in Workout that allows you to start your favorite workouts quickly. No one wants to stand around, holding up their arm, tapping through to try to find something. Great Watch apps make it easy to access important information and features.\n\nGreat Watch apps focus on the essential purpose of the app.\n\nFor example, the Weather app displays the forecast for today, relevant current conditions, and a simple 10-day forecast.\n\nFocus on the essentials in your app so people can easily find the information and actions they need.\n\nA great Watch app is designed to be used independently of the companion iPhone. The Contacts app, for example, synchronizes with your phone, but doesn't require your iPhone to be nearby to access contact information on your Apple Watch.\n\nThere are many reasons you might also want a companion iOS app for your Watch app, including providing a historical record of data captured by Apple Watch or detailed analysis of trends, as in the Fitness app.\n\nSince our app has a focused feature set, quick interaction, and limited data, we're going to create a Watch-only app.\n\nAt this point, I want to spend a few minutes talking about the targets that are created.\n\nIf you've built a Watch app in the past, your project has two targets for Watch: a WatchKit App target with a storyboard, assets, and perhaps some localization-related files, and a WatchKit Extension target with all of your app code. These dual targets are a holdover from the early days of watchOS, and there really isn't a good reason for multiple Watch targets anymore.\n\nStarting in Xcode 14, new Watch apps have a single Watch app target. All of the code, assets, localizations, and Siri Intent and Widget extensions associated with your Watch app belong in this target.\n\nThe great news is that single-target Watch apps are supported back to watchOS 7! You can simplify your project structure and reduce confusion and duplication while still supporting customers who aren't running the latest watchOS.\n\nIf you have an existing app with a WatchKit Extension target, it will continue to work, and you can continue to update your app using Xcode and publish your app through the App Store.\n\nIf you already have a Watch app that uses the SwiftUI lifecycle, transitioning to a single target is easy using the migration tool in Xcode 14. Select your target and choose Validate Settings from the Editor menu. The target collapsing option will be offered if your deployment target is watchOS 7 or later.\n\nIf you haven't already made the leap, now is a good time to start the process of converting your app to use the SwiftUI life cycle to enjoy the simplicity of a single-target Watch app and all of the features of SwiftUI.\n\nThe targets aren't the only thing we simplified in Xcode 14! We've also made it a lot easier to add an icon for your app by only requiring a single 1024x1024 pixel image.\n\nThe app icon image will be scaled for display on all Watch devices.\n\nBe sure to test with your app icon on devices on the home screen, in notifications, and in the settings for your app in the Watch app on the iPhone.\n\nYou can add custom images for specific smaller sizes if necessary. For example, if your app icon has details in the image that get lost at smaller sizes, you can add specific icon images for those sizes with the image details removed. Now let's add some functionality to our app by adding a list of task items. We'll start by creating a data model for our list of tasks. The ListItem struct will be Identifiable and Hashable, and we'll give it a description to display.\n\nThen, create a simple model to store our data and publish the array of list items.\n\nAnd finally, add the model as an environment object so our views can access our model.\n\nNow let's create a List in SwiftUI with our data model. Since there are no tasks yet, when we preview this, we get an empty list.\n\nWe need to do something about that. We should give people a way to add some tasks to their list.\n\nWe'd like to add a Button that people can tap to add a new item to the list. Text field link, new in watchOS 9, lets you invoke text input options from a button, and offers several styling options to make it feel right at home in your app.\n\nYou can create a TextFieldLink with a simple string or use a Label for a more custom button.\n\nModify the button's appearance with view modifiers, including foregroundColor, foregroundStyle, and buttonStyle.\n\nWe'll create an AddItemLink view to encapsulate the styling and behavior of the TextFieldLink we're using in our app.\n\nWe'll use a custom label for the button, and when someone enters text, we'll add the new item to our list.\n\nNow that we've decided to use TextFieldLink to add a button to add a new list item, we need to think about where to put the TextFieldLink.\n\nWhen adding actions to lists in Watch apps, we have a couple of options. Use a button, navigation link, or TextFieldLink at the end of the list for primary actions in short lists. Adding an action as an item at the end of a list is a good choice for a primary action in a short list of items like the list of cities in World Clock. However, if you anticipate a long list of items, people will have to keep scrolling to the end of the list each time they want to do the action. For commonly used actions with longer lists, use a toolbar item.\n\nTo add a toolbar item, add the toolbar modifier to the list, and use your action view as the content. This will add a single toolbar item to the list with automatic toolbar item placement. While I'd like to think I'll always keep my to-do list short, I'm fairly sure that I won't. So I'm going to put the text field links in a toolbar item to make it easy to access.\n\nLet's take a moment to review what we've accomplished. We've created a model for our list items, stored it as an environment object, created a list to display the items, and added a text field link to add new items.\n\nCreating an item with only a description is simple, but it isn't very useful. We're going to need to mark the item as complete, and we might want a way to set a priority or add an estimate of the amount of work for a task. To do this, we'll add a detail view. Before we do this, I want to review the options for app navigation structure in SwiftUI on Watch. Hierarchical navigation is used for views with a list-detail relationship. Starting in watchOS 9, use the SwiftUI NavigationStack to create interfaces with this type of navigation structure.\n\nPage-based navigation is used for views with a flat structure, where all of the views are peers.\n\nA great example of page-based navigation is the in-workout view of the Workout app, where people can easily swipe between the workout controls, metrics, and playback controls during a workout.\n\nA full-screen app has a single view that uses the entire display. This is generally used for apps like games and other apps that have a single main view.\n\nFor a full-screen view, use the ignoresSafeArea modifier to extend your content to the edges of the display, and the toolbar modifier with a visibility value of hidden to hide the navigation bar.\n\nA modal sheet is a full-screen view that slides over the current view. It should be used for important tasks that should be completed as part of the current workflow.\n\nIt's important to differentiate when to use a hierarchical flow versus when to use a modal sheet.\n\nMail uses a hierarchical style to display the list of messages and show each message or thread as a detail view. There are actions you can do from the message detail, but there is nothing you must do before returning to the list.\n\nIf you go back to the list, and tap New Message, Mail uses a modal sheet to show the New Message view.\n\nA modal sheet is the right choice because you need to fill in the details of the new message, or cancel, before continuing.\n\nTo display a modal sheet, create a property to control the sheet presentation state. Set the property based on an action in the user interface, and use the sheet modifier to display the custom modal sheet content when the presentation state property is true.\n\nTo add custom toolbar items to the modal sheet, add a toolbar with your items. Note that your toolbar items should use modal placements like confirmationAction, cancellationAction, and destructiveAction.\n\nWe're going to use the modal sheet for our detail view because we're editing an item and we want to focus on this single task until we've finished and tapped Done.\n\nTo learn more about navigation in SwiftUI, including more details about NavigationStack and programmatic navigation, check out \"The SwiftUI cookbook for navigation.\" Now that we've decided how to navigate to our detail view, we'll update our list item struct. We have new properties to store estimated work, creation date, and completion date.\n\nLet's give people a way to view and edit these details.\n\nWe'll create a detail view with a TextField to edit the description and a toggle to mark the task as complete or not. But what should we do with the estimated work? We know the values will all be numbers, and we can specify a range of valid values.\n\nBeginning in watchOS 9, we can use the Stepper. The Stepper is a great option when you want to provide granular control to edit sequential values.\n\nYou can specify a range of values and optionally provide a step.\n\nYou can also use the Stepper to edit logically sequential, but not necessarily numeric values.\n\nFor example, maybe we want to note the estimated stress level for an item.\n\nWe could create an array of emoji to indicate the stress level, then create a Stepper, binding the value to the selected index in the stress level emoji array and setting the range to the range of emoji indices. Stepping through the values increases or decreases the stress level we're estimating for the item.\n\nPreparing a WWDC session is fun, but sharing great Watch app development with all of you is a party. When I have stressful items on my list, or just a lot of items on my list that are making me feel stressed, I'd like to share an item from my list with a friend to ask for help.\n\nWe're going to add a button to our detail view to allow people to share an item using the share sheet. I want to be able to tap a button on my detail view to share the item, pick from a list of friends to ask for help, edit my message, and send it.\n\nTo do this, we're going to use a new tool available to us in SwiftUI on watchOS 9: ShareLink. We can share our list item by creating a ShareLink with our item. We can optionally customize the initial text of the message with a subject and message. And provide a Preview to display in the Share Sheet when someone shares the item. You can use ShareLink to share from your SwiftUI app in iOS, macOS, and watchOS.\n\nBe sure to check out \"Meet Transferable\" to learn more details and options for ShareLink. Now that I can track when I completed items and call for help to get things done, I'd also like to add a chart to see my productivity. I've chosen to use a bar chart because I have a single data series and distinct data values.\n\nA bar chart will clearly show this data on a Watch display as long as I limit the amount of data I display at one time. We're going to start by adding the chart view to our app's navigation structure. I've chosen a page-based navigation strategy because there is no list-detail relationship between the item list and the chart. Someone can swipe between the list and the chart at any time.\n\nTo add the page-based navigation for our list and chart, let's start by creating an ItemList struct to encapsulate the list view.\n\nI moved the entire content of the content view to this new item list. Encapsulating the item list here will allow us to have simple, easy-to-read tab view code in the content view.\n\nWe also need to create a struct for our chart view.\n\nI'll temporarily put in a placeholder so we can focus on our navigation structure before we build our chart.\n\nNow we'll set up a content view with a page-style tab view with 2 tabs: the item list and the chart.\n\nSince we've set up our navigation structure, let's talk about how to build this chart. I know I could use a SwiftUI Canvas and draw a chart, but starting in watchOS 9, we have an easier answer: Swift Charts. Swift Charts are also available on iOS, macOS, and tvOS, so you can reuse your charts anywhere you're using SwiftUI.\n\nWe'll aggregate the data we want to chart and then let Swift Charts display it for us.\n\nFor our chart, we want to show the number of items completed by date. We'll create a struct to store the aggregate data for the chart.\n\nThen we'll write a small method to aggregate our list item data into chart data elements.\n\nDisplay a simple chart by specifying the data to display and defining the series from the data. We're using the date as the x-value and the number of items completed as the y-value.\n\nTo achieve the appearance I want on my Watch display, I'm customizing the x-axis using the Chart's chartXAxis modifier. I'm specifying a format style for the axis value labels. I also don't want vertical gridlines, so I omitted an AxisGridLine mark. I'm also customizing the y-axis using the chartYAxis modifier. I specify a gridline style that looks good with my chart on Watch. I'm formatting the axis value labels as integers and omitting the top label to prevent it from being clipped at the top of the chart. To learn more about the amazing things you can achieve with Swift Charts, check out \"Hello Swift Charts\" and \"Swift Charts: Raise the bar.\" Our chart looks pretty good, but I'd like to show a little more data but still keep a great Watch experience, so I'm going to make it scrollable. To accomplish this, we're going to use a new digitalCrownRotation modifier that allows us to set a callback for digital crown events, and we're going to implement a custom scrolling behavior for our chart.\n\nLet's get ready to add the digitalCrownRotation modifier by adding some properties to store the state as someone scrolls across the chart.\n\nThe highlightedDateIndex is the index of the data point for the current scroll position.\n\nWe'll store the crown offset so we can display the current crown position as the person is scrolling across the chart. This is an intermediate value, on or between data points, while the crown is moving.\n\nTo keep track of whether someone is actively scrolling, we'll store the the idle state. We'll use this information to add a little animation as crown scrolling stops and starts.\n\nNow that we have the properties to store values, we can add the digitalCrownRotation modifier.\n\nWe'll bind the detent value to the highlightedDateIndex property.\n\nIn mechanical terms, a detent is a mechanism that holds something in a position until enough force is applied to move it. For instance, when I open my car door, there is a \"stop\" position where the door will settle. I can push a little harder and open the door wider to another \"stop.\" To close it, I need to pull hard enough to overcome the resistance to pull it out of the \"stop.\" Otherwise, it will spring back into that resting position. This is a detent. The stop for the car door helps us understand detent in this API. The detent is the resting notch position of the crown on your view.\n\nIn the handler for the onChange callback, we'll set the value for isCrownIdle to false, since we know that the crown is scrolling, and we'll set the crownOffset value to the current value to let us show the current position on the chart during scrolling.\n\nIn the handler for the onIdle callback, we'll set the value for isCrownIdle to true.\n\nNow we can display the position of the crown as we scroll on the chart.\n\nTo do this, we can use the RuleMark from Swift Charts. A RuleMark is a straight line on your chart. You can use it to display a horizontal or vertical line, to display a threshold, for example, or to display a sloped line.\n\nWe're going to create a RuleMark with the crown offset date value to display the current location of crown scrolling.\n\nJust to make this look a little better, I'd like to have the crown position line fade when the crown stops moving. It's simple to animate this using the isCrownIdle property we added.\n\nWe'll add a property to store the opacity for the color we're using in the foregroundStyle for the RuleMark.\n\nAnd add an onChange modifier to the chart to animate the crownPositionOpacity value change when the isCrownIdle value changes.\n\nThen update the foregroundStyle for the RuleMark to use the opacity.\n\nTo display the value next to the bar on the chart as we scroll, we can add an annotation to the BarMark. We'll position the annotation on the top leading side of the bar when it's the last bar. Otherwise, we'll position it on the top trailing side.\n\nLet's take a moment to see what we've accomplished with just the digitalCrownRotation modifier, the RuleMark in Swift Charts, and a simple SwiftUI animation.\n\nThe final step to creating our custom scrollable chart is adjusting the data range for the chart as someone scrolls. Create a property to store the visible range.\n\nCreate the chartData variable to provide the data in the range to the chart. When the highlightedDateIndex changes, call a method to check the chartDataRange and update it if necessary.\n\nAs someone scrolls across the chart using the Digital Crown, the chart will scroll to display the available data.\n\nNow we've finished implementing all the features we had planned.\n\nTo learn more about the new SwiftUI features available in watchOS 9, check out \"What's New in SwiftUI.\" As you're planning your Watch app, or your new Watch app features, think about what makes a great Watch app experience.\n\nWhile you're designing your app, consider your app navigation strategy to ensure that your app is easy and intuitive. And use SwiftUI for simpler and richer development options. Keep building great Watch apps. And remember, because of you, there's an app for that!",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "6:12",
      "title": "Initial ListItem struct",
      "language": "swift",
      "code": "struct ListItem: Identifiable, Hashable {\n    \n    let id = UUID()\n    var description: String\n    \n    init(_ description: String) {\n        self.description = description\n    }\n}"
    },
    {
      "timestamp": "6:24",
      "title": "ItemListModel",
      "language": "swift",
      "code": "class ItemListModel: NSObject, ObservableObject {\n    @Published var items = [ListItem]()\n}"
    },
    {
      "timestamp": "6:30",
      "title": "Add the ItemListModel as an EnvironmentObject",
      "language": "swift",
      "code": "@main\nstruct WatchTaskListSampleApp: App {\n    \n    @StateObject var itemListModel = ItemListModel()\n    \n    @SceneBuilder var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .environmentObject(itemListModel)\n        }\n    }\n}"
    },
    {
      "timestamp": "6:37",
      "title": "Create a simple SwiftUI List",
      "language": "swift",
      "code": "struct ContentView: View {\n    @EnvironmentObject private var model: ItemListModel\n    \n    var body: some View {\n        List {\n            ForEach($model.items) { $item in\n                ItemRow(item: $item)\n            }\n            \n            if model.items.isEmpty {\n                Text(\"No items to do!\")\n                    .foregroundStyle(.gray)\n            }\n        }\n        .navigationTitle(\"Tasks\")\n    }\n}"
    },
    {
      "timestamp": "7:11",
      "title": "TextFieldLink with a simple String",
      "language": "swift",
      "code": "struct ContentView: View {\n    @EnvironmentObject private var model: ItemListModel\n    \n    var body: some View {\n        VStack {\n            TextFieldLink(\"Add\") {\n                model.items.append(ListItem($0))\n            }\n        }\n        .navigationTitle(\"Tasks\")\n    }\n}"
    },
    {
      "timestamp": "7:16",
      "title": "TextFieldLink with a Label",
      "language": "swift",
      "code": "struct ContentView: View {\n    @EnvironmentObject private var model: ItemListModel\n    \n    var body: some View {\n        VStack {\n            TextFieldLink {\n                Label(\n                    \"Add\", \n                    systemImage: \"plus.circle.fill\")\n            } onSubmit: {\n                model.items.append(ListItem($0))\n            }\n        }\n        .navigationTitle(\"Tasks\")\n    }\n}"
    },
    {
      "timestamp": "7:20",
      "title": "TextFieldLink with foregroundStyle modifier",
      "language": "swift",
      "code": "struct ContentView: View {\n    @EnvironmentObject private var model: ItemListModel\n    \n    var body: some View {\n        VStack {\n            TextFieldLink {\n                Label(\n                    \"Add\", \n                    systemImage: \"plus.circle.fill\")\n            } onSubmit: {\n                model.items.append(ListItem($0))\n            }\n            .foregroundStyle(.tint)\n        }\n        .navigationTitle(\"Tasks\")\n    }\n}"
    },
    {
      "timestamp": "7:27",
      "title": "TextFieldLink with buttonStyle modifier",
      "language": "swift",
      "code": "struct ContentView: View {\n    @EnvironmentObject private var model: ItemListModel\n    \n    var body: some View {\n        VStack {\n            TextFieldLink {\n                Label(\n                    \"Add\", \n                    systemImage: \"plus.circle.fill\")\n            } onSubmit: {\n                model.items.append(ListItem($0))\n            }\n            .buttonStyle(.borderedProminent)\n        }\n        .navigationTitle(\"Tasks\")\n    }\n}"
    },
    {
      "timestamp": "7:30",
      "title": "Create the AddItemLink View to encapsulate the style and behavior of the TextFieldLink to add list items",
      "language": "swift",
      "code": "struct AddItemLink: View {\n    @EnvironmentObject private var model: ItemListModel\n    \n    var body: some View {\n        TextFieldLink(prompt: Text(\"New Item\")) {\n            Label(\"Add\",\n                  systemImage: \"plus.circle.fill\")\n        } onSubmit: {\n            model.items.append(ListItem($0))\n        } \n    }\n}"
    },
    {
      "timestamp": "8:38",
      "title": "Add a toolbar item to allow people to add new list items",
      "language": "swift",
      "code": "struct ContentView: View {\n    @EnvironmentObject private var model: ItemListModel\n    \n    var body: some View {\n        List {\n            ForEach($model.items) { $item in\n                ItemRow(item: $item)\n            }\n            \n            if model.items.isEmpty {\n                Text(\"No items to do!\")\n                    .foregroundStyle(.gray)\n            }\n        }\n        .toolbar {\n            AddItemLink()\n        }\n        .navigationTitle(\"Tasks\")\n    }\n}"
    },
    {
      "timestamp": "11:40",
      "title": "Display a modal sheet",
      "language": "swift",
      "code": "struct ItemRow: View {\n    @EnvironmentObject private var model: ItemListModel\n    \n    @Binding var item: ListItem\n    @State private var showDetail = false\n    \n    var body: some View {\n        Button {\n            showDetail = true\n        } label: {\n            HStack {\n                Text(item.description)\n                    .strikethrough(item.isComplete)\n                Spacer()\n                Image(systemName: \"checkmark\").opacity(item.isComplete ? 100 : 0)\n            }\n        }\n        .sheet(isPresented: $showDetail) {\n            ItemDetail(item: $item)\n        }\n    }\n}"
    },
    {
      "timestamp": "11:58",
      "title": "Display a modal sheet with custom toolbar items",
      "language": "swift",
      "code": "struct ItemRow: View {\n    @EnvironmentObject private var model: ItemListModel\n    \n    @Binding var item: ListItem\n    @State private var showDetail = false\n    \n    var body: some View {\n        Button {\n            showDetail = true\n        } label: {\n            HStack {\n                Text(item.description)\n                    .strikethrough(item.isComplete)\n                Spacer()\n                Image(systemName: \"checkmark\").opacity(item.isComplete ? 100 : 0)\n            }\n        }\n        .sheet(isPresented: $showDetail) {\n            ItemDetail(item: $item)\n                .toolbar {\n                    ToolbarItem(placement: .confirmationAction) {\n                        Button(\"Done\") {\n                            showDetail = false\n                        }\n                    }\n                }\n        }\n    }\n}"
    },
    {
      "timestamp": "12:36",
      "title": "Add more properties to the ListItem",
      "language": "swift",
      "code": "struct ListItem: Identifiable, Hashable {\n    \n    let id = UUID()\n    var description: String\n    var estimatedWork: Double = 1.0\n    var creationDate = Date()\n    var completionDate: Date?\n    \n    init(_ description: String) {\n        self.description = description\n    }\n\n    var isComplete: Bool {\n        get {\n            completionDate != nil\n        }\n        set {\n            if newValue {\n                guard completionDate == nil else { return }\n                completionDate = Date()\n            } else {\n                completionDate = nil\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "12:48",
      "title": "Create the ItemDetail View with the Stepper",
      "language": "swift",
      "code": "struct ItemDetail: View {\n    @Binding var item: ListItem\n    \n    var body: some View {\n        Form {\n            Section(\"List Item\") {\n                TextField(\"Item\", text: $item.description, prompt: Text(\"List Item\"))\n            }\n            Section(\"Estimated Work\") {\n                Stepper(value: $item.estimatedWork,\n                        in: (0.0...14.0),\n                        step: 0.5,\n                        format: .number) {\n                    Text(\"\\(item.estimatedWork, specifier: \"%.1f\") days\")\n                }\n            }\n            \n            Toggle(isOn: $item.isComplete) {\n                Text(\"Completed\")\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "13:29",
      "title": "A Stepper with Emoji",
      "language": "swift",
      "code": "// Use a Stepper to edit the stress level of an item\nstruct StressStepper: View {\n    private let stressLevels = [\n        \"ðŸ˜±\", \"ðŸ˜¡\", \"ðŸ˜³\", \"ðŸ™\", \"ðŸ«¤\", \"ðŸ™‚\", \"ðŸ¥³\"\n    ]\n    @State private var stressLevelIndex = 5\n    \n    var body: some View {\n        VStack {\n            Text(\"Stress Level\")\n                .font(.system(.footnote, weight: .bold))\n                .foregroundStyle(.tint)\n            \n            Stepper(value: $stressLevelIndex,\n                    in: (0...stressLevels.count-1)) {\n                Text(stressLevels[stressLevelIndex])\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "14:43",
      "title": "Add a ShareLink to the ItemDetail View",
      "language": "swift",
      "code": "struct ItemDetail: View {\n    @Binding var item: ListItem\n    \n    var body: some View {\n        Form {\n            Section(\"List Item\") {\n                TextField(\"Item\", text: $item.description, prompt: Text(\"List Item\"))\n            }\n            Section(\"Estimated Work\") {\n                Stepper(value: $item.estimatedWork,\n                        in: (0.0...14.0),\n                        step: 0.5,\n                        format: .number) {\n                    Text(\"\\(item.estimatedWork, specifier: \"%.1f\") days\")\n                }\n            }\n            \n            Toggle(isOn: $item.isComplete) {\n                Text(\"Completed\")\n            }\n            \n            ShareLink(item: item.description,\n                      subject: Text(\"Please help!\"),\n                      message: Text(\"(I need some help finishing this.)\"),\n                      preview: SharePreview(\"\\(item.description)\"))\n            .buttonStyle(.borderedProminent)\n            .buttonBorderShape(.roundedRectangle)\n            .listRowInsets(\n                EdgeInsets(top: 0, leading: 0, bottom: 0, trailing: 0)\n            )\n        }\n    }\n}"
    },
    {
      "timestamp": "16:39",
      "title": "Page-style TabView with navigation titles for each page",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        TabView {\n            NavigationStack {\n                ItemList()\n            }\n            NavigationStack {\n                ProductivityChart()\n            }\n        }.tabViewStyle(.page)\n    }\n}"
    },
    {
      "timestamp": "17:20",
      "title": "ChartData struct for aggregate data",
      "language": "swift",
      "code": "/// Aggregate data for charting productivity.\nstruct ChartData {\n    struct DataElement: Identifiable {\n        var id: Date { return date }\n        let date: Date\n        let itemsComplete: Double\n    }\n    \n    /// Create aggregate chart data from list items.\n    /// - Parameter items: An array of list items to aggregate for charting.\n    /// - Returns: The chart data source.\n    static func createData(_ items: [ListItem]) -> [DataElement] {\n        return Dictionary(grouping: items, by: \\.completionDate)\n            .compactMap {\n                guard let date = $0 else { return nil }\n                return DataElement(date: date, itemsComplete: Double($1.count))\n            }\n            .sorted {\n                $0.date < $1.date\n            }\n    }\n}"
    },
    {
      "timestamp": "17:36",
      "title": "Static sample data for chart and basic bar chart",
      "language": "swift",
      "code": "extension ChartData {\n    \n    /// Some static sample data for displaying a `Chart`.\n    static var chartSampleData: [DataElement] {\n        let calendar = Calendar.autoupdatingCurrent\n        var startDateComponents = calendar.dateComponents(\n            [.year, .month, .day], from: Date())\n        startDateComponents.setValue(22, for: .day)\n        startDateComponents.setValue(5, for: .month)\n        startDateComponents.setValue(2022, for: .year)\n        startDateComponents.setValue(0, for: .hour)\n        startDateComponents.setValue(0, for: .minute)\n        startDateComponents.setValue(0, for: .second)\n        let startDate = calendar.date(from: startDateComponents)!\n        \n        let itemsToAdd = [\n            6, 3, 1, 4, 1, 2, 7,\n            5, 2, 0, 5, 2, 3, 9\n        ]\n        var items = [DataElement]()\n        for dayOffset in (0..<itemsToAdd.count) {\n            items.append(DataElement(\n                date: calendar.date(byAdding: .day, value: dayOffset, to: startDate)!,\n                itemsComplete: Double(itemsToAdd[dayOffset])))\n        }\n        \n        return items\n    }\n}\n\nstruct ProductivityChart: View {\n       \n    let data = ChartData.createData(\n        ListItem.chartSampleData)\n             \n    var body: some View {\n        Chart(data) { dataPoint in\n            BarMark(\n                x: .value(\"Date\", dataPoint.date),\n                y: .value(\n                    â€œCompleted\", \n                    dataPoint.itemsComplete)\n            )\n            .foregroundStyle(Color.accentColor)\n        }\n        .navigationTitle(\"Productivity\")\n        .navigationBarTitleDisplayMode(.inline)\n    }\n}"
    },
    {
      "timestamp": "17:50",
      "title": "Chart with chartXAxis modifier",
      "language": "swift",
      "code": "struct ProductivityChart: View {\n       \n    let data = ChartData.createData(\n        ListItem.chartSampleData)\n  \n    private var shortDateFormatStyle = DateFormatStyle(dateFormatTemplate: \"Md\")\n             \n    var body: some View {\n        Chart(data) { dataPoint in\n            BarMark(\n                x: .value(\"Date\", dataPoint.date),\n                y: .value(\n                    â€œCompleted\", \n                    dataPoint.itemsComplete)\n            )\n            .foregroundStyle(Color.accentColor)\n        }\n      \t.chartXAxis {\n            AxisMarks(format: shortDateFormatStyle)\n        }\n        .navigationTitle(\"Productivity\")\n        .navigationBarTitleDisplayMode(.inline)\n    }\n}\n\n/// `ProductivityChart` uses this type to format the dates on the x-axis.\nstruct DateFormatStyle: FormatStyle {\n    enum CodingKeys: CodingKey {\n        case dateFormatTemplate\n    }\n    \n    private var dateFormatTemplate: String\n    private var formatter: DateFormatter\n    \n    init(dateFormatTemplate: String) {\n        self.dateFormatTemplate = dateFormatTemplate\n        formatter = DateFormatter()\n        formatter.locale = Locale.autoupdatingCurrent\n        formatter.setLocalizedDateFormatFromTemplate(dateFormatTemplate)\n    }\n    \n    init(from decoder: Decoder) throws {\n        let container = try decoder.container(keyedBy: CodingKeys.self)\n        dateFormatTemplate = try container.decode(String.self, forKey: .dateFormatTemplate)\n        formatter = DateFormatter()\n        formatter.setLocalizedDateFormatFromTemplate(dateFormatTemplate)\n    }\n    \n    func encode(to encoder: Encoder) throws {\n        var container = encoder.container(keyedBy: CodingKeys.self)\n        try container.encode(dateFormatTemplate, forKey: .dateFormatTemplate)\n    }\n    \n    func format(_ value: Date) -> String {\n        formatter.string(from: value)\n    }\n}"
    },
    {
      "timestamp": "19:05",
      "title": "Add the digitalCrownRotation modifier",
      "language": "swift",
      "code": "struct ProductivityChart: View {\n       \n    let data = ChartData.createData(\n        ListItem.chartSampleData)\n\n    /// The index of the highlighted chart value. This is for crown scrolling.\n    @State private var highlightedDateIndex: Int = 0\n\n    /// The current offset of the crown while it's rotating. This sample sets the offset with\n    /// the value in the DigitalCrownEvent and uses it to show an intermediate\n    /// (between detents) chart value in the view.\n    @State private var crownOffset: Double = 0.0\n\n    @State private var isCrownIdle = true\n  \n    private var chart: some View {\n        Chart(data) { dataPoint in\n            BarMark(\n                x: .value(\"Date\", dataPoint.date),\n                y: .value(\n                    â€œCompleted\", \n                    dataPoint.itemsComplete)\n            )\n            .foregroundStyle(Color.accentColor)\n        }\n      \t.chartXAxis {\n            AxisMarks(format: shortDateFormatStyle)\n        }\n    }\n        \n    var body: some View {\n        chart\n            .focusable()\n            .digitalCrownRotation(\n                detent: $highlightedDateIndex,\n                from: 0,\n                through: data.count - 1,\n                by: 1,\n                sensitivity: .medium\n            ) { crownEvent in\n                isCrownIdle = false\n                crownOffset = crownEvent.offset\n            } onIdle: {\n                isCrownIdle = true\n            }\n            .navigationTitle(\"Productivity\")\n            .navigationBarTitleDisplayMode(.inline)\n    }\n}"
    },
    {
      "timestamp": "21:07",
      "title": "Add a RuleMark to the Chart to show the current Digital Crown position",
      "language": "swift",
      "code": "/// The date value that corresponds to the crown offset.\nprivate var crownOffsetDate: Date {\n    let dateDistance = data[0].date.distance(\n        to: data[data.count - 1].date) * (crownOffset / Double(data.count - 1))\n    return data[0].date.addingTimeInterval(dateDistance)\n}\n\nprivate var chart: some View {\n    Chart(data) { dataPoint in\n        BarMark(\n            x: .value(\"Date\", dataPoint.date),\n            y: .value(\n                \"Completed\", \n                dataPoint.itemsComplete)\n        )\n        .foregroundStyle(Color.accentColor)\n             \n        RuleMark(x: .value(\"Date\", crownOffsetDate))\n            .foregroundStyle(Color.appYellow)\n    }\n    .chartXAxis {\n        AxisMarks(format: shortDateFormatStyle)\n    }\n}"
    },
    {
      "timestamp": "21:37",
      "title": "Add animation to dim the crown position line when the scrolling idle state changes",
      "language": "swift",
      "code": "struct ProductivityChart: View {\n       \n    let data = ChartData.createData(\n        ListItem.chartSampleData)\n\n    /// The index of the highlighted chart value. This is for crown scrolling.\n    @State private var highlightedDateIndex: Int = 0\n\n    /// The current offset of the crown while it's rotating. This sample sets the offset with\n    /// the value in the DigitalCrownEvent and uses it to show an intermediate\n    /// (between detents) chart value in the view.\n    @State private var crownOffset: Double = 0.0\n\n    @State private var isCrownIdle = true\n\n    @State var crownPositionOpacity: CGFloat = 0.2\n  \n    private var chart: some View {\n        Chart(data) { dataPoint in\n            BarMark(\n                x: .value(\"Date\", dataPoint.date),\n                y: .value(\n                    â€œCompleted\", \n                    dataPoint.itemsComplete)\n            )\n            .foregroundStyle(Color.accentColor)\n                     \n            RuleMark(x: .value(\"Date\", crownOffsetDate))\n                .foregroundStyle(Color.appYellow.opacity(crownPositionOpacity))\n        }\n      \t.chartXAxis {\n            AxisMarks(format: shortDateFormatStyle)\n        }\n    }\n             \n    var body: some View {\n        chart\n            .focusable()\n            .digitalCrownRotation(\n                detent: $highlightedDateIndex,\n                from: 0,\n                through: data.count - 1,\n                by: 1,\n                sensitivity: .medium\n            ) { crownEvent in\n                isCrownIdle = false\n                crownOffset = crownEvent.offset\n            } onIdle: {\n                isCrownIdle = true\n            }\n            .onChange(of: isCrownIdle) { newValue in\n                withAnimation(newValue ? .easeOut : .easeIn) {\n                    crownPositionOpacity = newValue ? 0.2 : 1.0\n                }\n            }\n            .navigationTitle(\"Productivity\")\n            .navigationBarTitleDisplayMode(.inline)\n    }\n}"
    },
    {
      "timestamp": "22:14",
      "title": "Add an annotation to the bar chart to display the current value",
      "language": "swift",
      "code": "private func isLastDataPoint(_ dataPoint: ChartData.DataElement) -> Bool {\n    data[chartDataRange.upperBound].id == dataPoint.id\n}\n\nprivate var chart: some View {\n    Chart(chartData) { dataPoint in\n        BarMark(x: .value(\"Date\", dataPoint.date, unit: .day),\n        y: .value(\"Completed\", dataPoint.itemsComplete))\n        .foregroundStyle(Color.accentColor)\n        .annotation(\n            position: isLastDataPoint(dataPoint) ? .topLeading : .topTrailing,\n            spacing: 0\n        ) {\n            Text(\"\\(dataPoint.itemsComplete, format: .number)\")\n                .foregroundStyle(dataPoint.date == crownOffsetDate ? Color.appYellow : Color.clear)\n        }\n\n        RuleMark(x: .value(\"Date\", crownOffsetDate, unit: .day))\n            .foregroundStyle(Color.appYellow.opacity(crownPositionOpacity))\n    }\n    .chartXAxis {\n        AxisMarks(format: shortDateFormatStyle)\n    }\n}"
    },
    {
      "timestamp": "22:44",
      "title": "Make the chart data range scrollable",
      "language": "swift",
      "code": "@State var chartDataRange = (0...6)\n\nprivate func updateChartDataRange() {\n    if (highlightedDateIndex - chartDataRange.lowerBound) < 2, chartDataRange.lowerBound > 0 {\n        let newLowerBound = max(0, chartDataRange.lowerBound - 1)\n        let newUpperBound = min(newLowerBound + 6, data.count - 1)\n        chartDataRange = (newLowerBound...newUpperBound)\n        return\n    }\n    if (chartDataRange.upperBound - highlightedDateIndex) < 2, chartDataRange.upperBound < data.count - 1 {\n        let newUpperBound = min(chartDataRange.upperBound + 1, data.count - 1)\n        let newLowerBound = max(0, newUpperBound - 6)\n        chartDataRange = (newLowerBound...newUpperBound)\n        return\n    }\n}\n\nprivate var chartData: [ChartData.DataElement] {\n    Array(data[chartDataRange.clamped(to: (0...data.count - 1))])\n}\n\nprivate var chart: some View {\n    Chart(chartData) { dataPoint in\n        BarMark(x: .value(\"Date\", dataPoint.date, unit: .day),\n                y: .value(\"Completed\", dataPoint.itemsComplete)\n        )\n        .foregroundStyle(Color.accentColor)\n        .annotation(\n            position: isLastDataPoint(dataPoint) ? .topLeading : .topTrailing,\n            spacing: 0\n        ) {\n            Text(\"\\(dataPoint.itemsComplete, format: .number)\")\n                .foregroundStyle(dataPoint.date == crownOffsetDate ? Color.appYellow : Color.clear)\n        }\n\n        RuleMark(x: .value(\"Date\", crownOffsetDate, unit: .day))\n            .foregroundStyle(Color.appYellow.opacity(crownPositionOpacity))\n    }\n    .chartXAxis {\n        AxisMarks(format: shortDateFormatStyle)\n    }\n}\n\nvar body: some View {\n    chart\n        .focusable()\n        .digitalCrownRotation(\n            detent: $highlightedDateIndex,\n            from: 0,\n            through: data.count - 1,\n            by: 1,\n            sensitivity: .medium\n        ) { crownEvent in\n            isCrownIdle = false\n            crownOffset = crownEvent.offset\n        } onIdle: {\n            isCrownIdle = true\n        }\n        .onChange(of: isCrownIdle) { newValue in\n            withAnimation(newValue ? .easeOut : .easeIn) {\n                crownPositionOpacity = newValue ? 0.2 : 1.0\n            }\n        }\n        .onChange(of: highlightedDateIndex) { newValue in\n            withAnimation {\n                updateChartDataRange()\n            }\n        }\n        .navigationTitle(\"Productivity\")\n        .navigationBarTitleDisplayMode(.inline)\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Building a productivity app for Apple Watch",
        "url": "https://developer.apple.com/documentation/watchos-apps/building_a_productivity_app_for_apple_watch"
      },
      {
        "title": "watchOS apps",
        "url": "https://developer.apple.com/documentation/watchOS-Apps"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2022/10133/4/BBFD71DD-1E5F-4843-861E-0D333BAA1A3F/downloads/wwdc2022-10133_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2022/10133/4/BBFD71DD-1E5F-4843-861E-0D333BAA1A3F/downloads/wwdc2022-10133_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10136",
      "year": "2022",
      "title": "Hello Swift Charts",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10136"
    },
    {
      "id": "10062",
      "year": "2022",
      "title": "Meet Transferable",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10062"
    },
    {
      "id": "10137",
      "year": "2022",
      "title": "Swift Charts: Raise the bar",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10137"
    },
    {
      "id": "10054",
      "year": "2022",
      "title": "The SwiftUI cookbook for navigation",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10054"
    },
    {
      "id": "10052",
      "year": "2022",
      "title": "What's new in SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10052"
    }
  ],
  "extractedAt": "2025-07-18T10:24:57.849Z"
}