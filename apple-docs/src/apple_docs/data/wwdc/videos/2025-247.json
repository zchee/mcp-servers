{
  "id": "247",
  "year": "2025",
  "url": "https://developer.apple.com/videos/play/wwdc2025/247/",
  "title": "What’s new in Xcode 26",
  "speakers": [],
  "duration": "",
  "topics": [
    "Design",
    "Developer Tools"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "Hi, I’m Eliza. I work on Swift Previews. And I’m Chris. I work on Xcode. Developing great apps takes a lot of work, whether it’s writing code, exploring and prototyping new features, debugging, improving performance and more. We’re excited to share with you some of the awesome improvements in Xcode this year to help support you in your app development. We’ll start with some optimizations to Xcode’s download size and performance. Then, we’ll explore improvements in the workspace and source editor, and try out some exciting new code intelligence features. Chris will then talk through some new features in debugging & performance, What’s new in builds, and wrap up with some updates in testing. Let’s get started with optimizations! Over the last few years we’ve been working to make Xcode smaller so you can get your tools even faster and download only the components that you need. This year, Xcode is 24% smaller. Simulator runtimes no longer contain Intel support by default, and the Metal toolchain will only be downloaded if your project needs it.\n\nAltogether, this year’s Xcode has a smaller download size than Xcode 6 did in 2014! We’ve also optimized text input in Xcode this year, improving typing latency in some complex expressions by up to 50%.\n\nWe’ve also made some substantial optimizations to Xcode’s loading performance. It’s now 40% faster to load a workspace. For large projects, this makes a big difference. Which leads us to updates in the workspace and editing. There are tons of enhancements to the source editor in Xcode this year. Let’s start with editor tabs. This year’s Xcode improves the behavior of editor tabs to make them a lot more intuitive.\n\nJust like in Safari, I can open a tab and decide where to go from there, using this new start page.\n\nAnd I can pin a tab to fix it on a particular file. This puts me in control of exactly how many tabs I have. Whether that's just one, one for every file, or a perfectly curated set.\n\nNow, let’s talk about search. When exploring an unfamiliar project, or even navigating a familiar one, it’s crucial to be able to search your code effectively. This year, Xcode has a really cool new search mode called “Multiple Words search” which uses search engine techniques to find clusters of words in your project. In this search mode, I can enter a set of words.\n\nFor example, here, I’m trying to find where in my project I’m creating clipped resizable images.\n\nXcode will now find all the clusters of these words in proximity to each other across your documents, sorting the documents by relevance.\n\nThe clusters can span multiple lines and the search terms can appear in any order, making this a really powerful feature! There’s a big step forward this year for accessibility in Xcode. You can now easily use Voice Control to write Swift code, and you can pronounce the Swift code just as you’d naturally read it aloud. In this mode, Voice Control understands Swift syntax. It will figure out where spaces should appear, whether expressions correspond to operators or should be camel-cased, and so on. To fully appreciate how cool this is, it’s best to see it in action. With Swift Mode for Voice Control, I can navigate and edit my Swift code just by speaking to my Mac. Let’s use this to add a field to our landmark inspector for the landmark’s continent.\n\n“Start listening” “Swift mode” “Select labeled content” “Four” “Go to the end of the line” “New line, new line” “If let continent equals landmark dot continent\" \"Open brace\" “New line” “Labeled content paren quote continent quote comma value colon continent” “Correct quote continent” “One” “Stop listening” Notice that the continent field now appears near the bottom of my preview, and I didn’t touch my keyboard once! Now, let’s talk about iterating on code. Using Previews has always been a great way to quickly iterate on your UI code. This year, we’re introducing a new macro called Playground which you can use to quickly iterate on any code.\n\nAs with previews, you can add a playground inline in your document, and the results of the code execution will appear in their own canvas tab. Let me show you a demo. I’ve noticed a bug in the Landmarks app where landmarks are showing up in the wrong place on the map. I’m going to use a playground to poke around at the landmark struct and see if I can figure out what’s going on.\n\nImporting the Playgrounds module gives me access to the playground macro.\n\nLet’s load a sample landmark so we can examine its data.\n\nIn the canvas, I see an entry for each expression in my playground. I just have one, which is the landmark structure for the Grand Canyon, and I can see the values for each of its properties. Some of the property types have a Quick Look icon. Let’s look more closely at the coordinate property.\n\nOkay, that seems odd... the Grand Canyon shouldn’t be inside a city. I can add another expression to my playground to get more information about the region for this landmark. As I modify the playground, expressions in it are re-run, and the canvas updates automatically.\n\nYeah… the Grand Canyon is definitely not in China. Let’s figure out what’s going on here. When we load landmarks from a file, we use a regular expression to parse the location coordinates from a string. This is the regular expression we’re using. Maybe there’s a problem with it that’s causing our coordinates to be parsed incorrectly? Let’s investigate that in another playground. When I add a new playground I get a new tab in the canvas.\n\nLet's add some code to this playground.\n\nWe’re going to call the function where that regular expression is defined.\n\nI’m using a sample input string, and extracting some computed results into local variables so they're easier to examine. Some types, such as regular expression match results, have custom visualizations in the canvas, and in this case, I can see that Xcode highlights the match range in the original string.\n\nThe match range makes it clear that there was a problem capturing the minus sign. And now the bug makes sense, as the negative longitude would have been parsed as a positive number, putting the Grand Canyon in the wrong place.\n\nI’m going to fix the expression, and if you watch the playground in the canvas while I do this, you’ll see that the results update immediately. I can see in the visualization that the minus sign is now included in the range matched by the regular expression.\n\nAnd if I switch back to the original playground, I see that the Grand Canyon is now in the right place! And that’s Playgrounds. They’re great for understanding existing code as well as for trying out new ideas.\n\nAnd the new #Playground macro is also being open-sourced to bring the experience to Swift developers writing for other platforms. Check out the post on Swift Forums and join in on the conversation! Now, let’s talk about icons. Icon Composer is a new app bundled with Xcode 26.\n\nWith Icon Composer, you can create beautifully designed, sophisticated, multi-layered icons that work across multiple platforms and software versions.\n\nOver the last few years, we’ve made it easier to create icons for all platforms. But this year, icons don’t only differ depending on the platform you’re building for. They now vary in modes, including dark and tinted modes on iOS, iPadOS, and macOS. And there’s a new look for watchOS as well.\n\nNow, all of this can be achieved in one single file using Icon Composer.\n\nYou can take advantage of the full range of our material effects and even add dynamic properties to your layers, like blur, shadow, specular highlights, and translucency. Not only that, the tool is great for creating flat icons that are compatible with previous operating systems, web pages, or anywhere else you need them.\n\nTo learn more about app icons, and how to use Icon Composer, check out “Say hello to the new look of app icons” and “Create app icons with Icon Composer.” Bringing your app to more users around the globe is incredibly valuable. Supporting different languages helps people feel at home in your app. And with string catalogs, localization can be a breeze. String Catalogs have gotten some big enhancements this year, to make life easier for both developers and translators.\n\nFor developers, we’ve added type-safe Swift symbols for localized strings.\n\nDevelopers wanting more precise control over strings can define them directly in the String Catalog, which now produces Swift symbols that can be accessed in code. These symbols even appear as auto-complete suggestions! And to assist translators, String Catalogs can now automatically generate comments that describe string context.\n\nXcode accomplishes this by intelligently analyzing where and how a localized string is used in your project.\n\nIt then generates comments using the on-device model.\n\nFor more on string catalogs, please have a look at the code-along session “Explore localization with Xcode”. Which brings us to intelligence. Xcode is getting some additional exciting new intelligence features. Xcode can now use large language models such as ChatGPT to provide coding assistance. You can ask general questions about Swift — like “tell me about swift concurrency”.\n\nAnd because of the integration with Xcode, the model can take your code into consideration and answer specific questions about your project, or even make changes on your behalf.\n\nIn addition, we’re introducing a handy lighter-weight menu that you can use to automatically apply changes to selected code. When you bring up coding tools, you have quick access to common actions, or you can type a custom query into the text field. Let’s look at these features in more detail. This app has a view that shows my favorite landmark collections, but I’m not familiar with the code, and I don’t know where that’s implemented. So I’m going to ask Xcode.\n\nXcode sends the project context to the model, and it replies with an explanation that describes the relevant source files and what they do. The model can also ask for more information from Xcode about additional context it needs while it’s coming up with an answer.\n\nThe “info” button in the transcript shows us the context that Xcode sent.\n\nThe response also contains links so you can quickly navigate to any mentioned file.\n\nThis looks like the right one. This is a great way to explore an unfamiliar code base.\n\nNow, let’s add a feature! Let’s ask Xcode to add ratings to landmark collections.\n\nHere, I’m using the `@` character to directly reference a symbol we want the model to modify.\n\nTyping the ‘@‘ symbol into my prompt lets me reference symbols, source files, or any issues in my project that I want the response to focus on. This can be useful when you have specific changes in mind. I can even attach files for the query to reference. Images are especially useful, since many large language models can generate code from just a sketch of a user interface. The automatic context and code changes do the right thing out of the box, but if you can also have more control if you want to. This toggle controls whether Xcode includes information about your project with the query. If you were asking a general question about Swift, for example, you might choose to turn off project context. But most of the time you’d want to leave it on. This toggle lets you control whether to automatically apply any code changes in the response. If it’s off, you can review each change before deciding whether to apply it. Okay, it looks like the response is complete and all the changes have been made to my project. I can click to see a summary of the changes that were made — these look good.\n\nI can type a new message to continue the conversation. Let’s ask the model to add that rating to the user interface.\n\nThe model can figure out what ‘it’ refers to here, because new messages preserve the context of earlier queries and replies.\n\nThis change looks pretty good! I can continue making changes in the context of the previous ones. Let’s have a bit of fun and make it go to eleven.\n\nOnce again, the model knows what I mean by “it” here.\n\nTa-da! Now we have 11 stars! By default, changes are applied automatically to your code. But Xcode keeps a snapshot of your code before each change is applied, so you can easily view and unwind them using the modification history in the conversation view. Here I can examine every line of code changed during each stage of the conversation.\n\nI can scrub back and forth through time to apply or revert individual sets of changes. In this case, I’m happy with all the changes so I’ll cancel out of the modification history.\n\nSo far, I’ve been using the code assistant to make changes that affect multiple files in my project. When I want to focus on a particular section of code, I can also use coding tools right from my source editor.\n\nLet’s use coding tools to add a playground that will exercise our Landmark struct. Coding tools has buttons for quick actions to apply to my code, or I can enter a custom query. In this case, let’s select the action to generate a playground. Because the model has access to the context — for newly generated code as well as for existing code — it can create playgrounds that exercise the code in interesting ways. Now we have a playground that lets me inspect a sample landmark! In addition to explaining or modifying code, Xcode is great at helping me fix issues in my code. For example, here I have an error where I’m trying to use a `ForEach` view with a type that doesn’t conform to `Identifiable`. There’s a new option this year to generate a fix — this will bring up the coding assistant.\n\nBecause the model has access to the type declaration as well as the place where the error is detected, it can figure out which file needs to be modified to fix the error. In this case, the fix was to add a protocol conformance in activity.swift.\n\nAnd now the error is resolved. Xcode is also great at fixing other issues. For example, I find I sometimes let deprecation warnings linger in code because they’re not causing immediate problems. Now I can save time by asking Xcode to fix them for me! There are many ways to add a model in Xcode. First, you can enable ChatGPT with just a few clicks. You’ll get a limited number of requests each day, and you can bring your own ChatGPT account for even more requests.\n\nIf you’d like to use another provider, like Anthropic, you can simply enter your API key and interact with models like Claude 4 Opus and Sonnet.\n\nYou can choose which models to show from each provider, and can mark your favorites for quick access. And you can also use local models, running on your Mac or private network, thanks to tools like Ollama and LM Studio! You can add as many providers as you want in Xcode’s preferences.\n\nOnce you’ve configured a set of models, you can quickly switch between them in the coding assistant when beginning a new conversation. So that’s a look through some of the new features in Xcode’s workspace and source editor, and how you can use code intelligence to get more creative and productive. Now, I’ll hand it over to Chris, to tell us about debugging and performance. Thanks, Eliza! Catching bugs and improving your app's performance are crucial steps to providing a great app experience. This year, we have a few exciting updates, starting with the debugger. Debugging Swift concurrency code has gained some great livability improvements in this year’s Xcode. As you step through code running in a Swift task, Xcode now follows execution into asynchronous functions, even if that requires switching threads. And Xcode’s debugger UI will now show task IDs. Here, for example, the current Swift Task is displayed in the backtrace view on the left and in the Program Counter annotation on the right. And in the variables view you’ll see easy-to-read representations of concurrency types, such as Tasks, TaskGroups, and actors. In this example, it’s much easier to see the Task variable’s properties, such as its priority and any child tasks.\n\nXcode 26 makes debugging Swift concurrency code easier than ever. For more information on Swift concurrency see “What’s New in Swift”.\n\nIf you’ve ever added functionality to your app that requires accessing a private resource, like the user’s location or the camera, you may have experienced your app stopping abruptly in the debugger, with an error about a missing “usage description”.\n\n“Usage descriptions” are required when accessing private resources, so the system can include them in an authorization prompt, to help the user know why the app is requesting access. This year’s Xcode now understands when an app has stopped due to a missing usage description and explains what is missing. From the annotation, you can jump directly to documentation to learn more. But the quickest way to fix the issue is to use the new “Add” button, which will take you directly to the Signing & Capabilities editor. The necessary capability will be added for you, as the Signing & Capabilities editor in Xcode 26 now supports editing many capabilities that require usage descriptions, so you can edit them all in one place. Xcode will take care of updating the underlying Info plist, build settings, or entitlements for you.\n\nSo now, all you need to do is enter your usage description. Then you can re-run and verify that the capability now prompts for permission, as expected. Instruments is a powerful tool for analyzing the performance of your apps and ships as part of every Xcode install. For CPU analysis, Instruments contains some powerful tools, providing multiple options for profiling your code’s performance on modern Apple silicon hardware. Previously, Instruments used sampling-based profilers to understand CPU usage, which are great choices for analyzing long-running workloads.\n\nBut what does it mean for a profiler to be sampling based? It literally means that the tool samples the CPUs periodically, expecting that call stacks sampled are responsible for the same relative CPU usage overall.\n\nBut sampling by its very nature is only an approximation of the full workload, which is why it is more practical for long-running workload analysis. In our illustration, the orange sections of execution were not captured by sampling, for example. Recent Apple silicon devices can capture a processor trace where the CPU stores information about the code it runs, including the branches it takes, and the instructions it jumps to. The CPU streams this information to an area on the file system so that it can be analyzed with the Processor Trace instrument.\n\nRather than periodic sampling, Processor Trace captures information about every low-level branching decision the CPU makes, on all running threads, with very little runtime overhead. This means that the Processor Trace timeline can present a high-fidelity visualization of execution flow. Unlike traditional sampling profilers that can miss critical code paths between sampling intervals, this tool reveals every branch taken and function called — including compiler-generated code, like ARC memory management in Swift. Processor Trace is a fundamental shift in how you can measure software performance, with every function call captured, on all threads, with little overhead. Processor Trace was introduced with Xcode 16.3 and is supported by M4 and iPhone 16 devices.\n\nProcessor Trace is great for understanding the execution of your code and where CPU time is being spent. In contrast, the significantly updated CPU Counters instrument will help you understand how your code is interacting with the CPU.\n\nThis tool will help guide you in making microarchitecture optimizations.\n\nCPU Counters now uses preset modes that group related counters together, to provide a guided approach to learning about how your code is handled by the CPU.\n\nThese modes include a general CPU Bottlenecks mode, which is a good starting point for this type of analysis.\n\nCPU Bottlenecks breaks down the CPU's sustainable instruction bandwidth into either useful work, or bottlenecked for one of three broad reasons: Either the CPU had to wait for execution units or memory to become available; Or the CPU couldn’t deliver instructions quickly enough; Or the CPU incorrectly predicted future work and needed to get back on track.\n\nIn addition to the bottleneck analysis approach, the Instruction Characteristics and Metrics modes offer a more traditional use of the counters to get absolute counts of consumption. These let you focus on tuning critical instruction sequences by analyzing branches, cache behavior, and numerical operations directly.\n\nCPU Counters also includes detailed documentation to help understand what the modes and counters represent.\n\nTo learn a lot more about Processor Trace and CPU Counters see “Optimize CPU performance with Instruments”. SwiftUI makes it easier than ever to build highly interactive apps. For the best user experience, performance is critical. In this year’s OS releases we’ve made a number of improvements to SwiftUI performance. For example, Lists can update up to 16 times faster without any additional changes from your app. Even with these improvements, your app still might not be performing as well as you’d like it to, and you’ll want to find out why your views are updating frequently.\n\nTo help with that, the next-generation SwiftUI instrument included with Xcode 26, captures detailed information about the causes and effects of SwiftUI updates. This makes it easier than ever to understand when and why your views update. The timeline gives a quick overview of when SwiftUI is doing work on the main thread, and when individual view updates take a long time and put you at risk of a hitch or hang. The “View Body Updates” summary tells you how many times each view in your app updated.\n\nIf the number of updates to one of your views is much larger than you expect, open the cause-and-effect graph to help understand why.\n\nTo learn more about SwiftUI’s performance improvements, see “What’s new in SwiftUI”. For more information on how to use the SwiftUI instrument, check out “Optimize SwiftUI performance with Instruments”.\n\nPeople love apps they can rely on throughout their day, and a crucial part of that reliability is excellent battery life. While debugging your app, perhaps you've noticed high energy impact in Xcode, signaling a problem. But finding the root cause can be tough.\n\nIn these situations, what you really need is the ability to run your app, reproduce the issue, and record power metrics. The Power Profiler instrument is the perfect tool for this. It lets you profile your app and record power metrics which can then be visualized. The Power Profiler track shows system power usage, correlated with the thermal and charging states of the device, helping to identify unexpected power spikes. The process track shows the impact the application has on various device power subcomponents like CPU, GPU, Display, and Networking.\n\nPower Profiler supports two modes of tracing: Tethered recording, with Instruments directly connected to the target device; And \"passive\" recording, where a trace can be initiated on a device from Developer Settings, without being tethered. The trace can then later be imported into Instruments for analysis. By recording stable workloads, you can use the Power Profiler instrument to observe how your choice of algorithms and APIs affects sustainability of a workload. Learn more by checking out “Profile and optimize power usage in your app”. While Instruments is great for analyzing the performance of your app during development, the Xcode Organizer allows you to monitor the power and performance impact of your shipping apps via metrics and diagnostics.\n\nThe Organizer in Xcode 16 introduced a feature called Trending Insights to Disk Write diagnostics, with a flame icon in the source list. These help call out issues that have increased in impact, that you may want to pay attention to.\n\nIn this year’s Xcode, we’ve taken this one step further by bringing Trending Insights to Hang and Launch diagnostics as well, where the flame icon calls out Hang and Launch times that are trending in the wrong direction. Additionally, the Insights area now provides clarity about the trend by charting the increase across the last 5 app versions. This not only provides a starting point for performance optimizations, but also helps you understand where you could have introduced code that led to the overall increase in impact.\n\nAnd now that you know what to prioritize, you can share a diagnostic report with your colleagues using URL sharing.\n\nAnother area in the Organizer to help you understand how well your app is performing across versions is Metrics. Metrics have been expanded in Xcode 26 with the addition of Recommendations. Metric Recommendations compare your app’s metrics with other sources – including similar apps and your app’s historical data – to provide an important reference point for understanding how well your app is performing across its user base. In this example, our app’s launch time is measured at around 564 milliseconds. However, based on similar apps' metrics, Xcode is recommending that our app’s launch time should be closer to 425 milliseconds, which gives us a clear target to aim for. This year, metric recommendations are available for the Launch Time metric. Apple will enable recommendations for other metrics over time. Next, I’d like to talk about Xcode’s build system. In Xcode 16, we introduced Explicitly Built Modules, enabled for C and Objective-C code. In Xcode 26, we’re excited to announce that we are enabling Explicitly Built Modules for Swift code by default.\n\nWith Explicit Modules, Xcode splits up the processing of each compilation unit into three phases: Scanning, building modules, and finally building the original source code.\n\nThis separation gives the build system better control of module build tasks to optimize the build pipeline.\n\nBuilding explicit modules improves build efficiency and reliability, with more precise and deterministic sharing of modules. It also improves the speed of debugging Swift code, as the debugger can reuse the already built modules. For more information, refer to “Demystify explicitly built modules”.\n\nEarlier this year, Apple open sourced Swift Build, a powerful and extensible build engine that is used by Xcode and Swift Playground, as well as the internal build process for Apple’s own operating systems.\n\nWe've also been working to incorporate Swift Build into Swift Package Manager, to unify the build experience across Swift open source toolchains and Xcode. We’re also adding support for all platforms supported by the Swift ecosystem, including Linux, Windows, Android, and more. You can preview this new implementation on your own packages using the “build-system” option of the Swift command line tool. Or see your changes live in Xcode using the instructions in the Swift Build repository.\n\nFor the first time, the community can contribute to the implementation of the build engine that powers Xcode and the Swift ecosystem. To learn more about Swift Build or get involved in development, check out the repository on GitHub.\n\nIn our interconnected world, users view security as an increasingly critical requirement for applications. Xcode’s new Enhanced Security capability provides your apps with the same protections used in Apple’s apps, such as pointer authentication. You can enable these security settings for your app by adding the “Enhanced Security” capability in the “Signing and Capabilities” editor.\n\nWe recommend enabling it for applications with a significant attack surface, such as social media, messaging, image viewing, and browsing.\n\nGet more details about Enhanced Security in the Apple Developer documentation. Next, let’s talk about Testing. Xcode’s UI testing has had a significant upgrade this year. UI automation recording has been enhanced with a completely new code generation system. This is great news, as I wanted to implement a UI test for Landmarks, to test the Collection editing UI. Let’s use the UI automation recording feature of Xcode 26 to build my test for me. I’ve already got a test target configured for this project and a new test method ready to fill out.\n\nBy placing the cursor in the body of the test method, Xcode reveals a “Start Recording” button in the editor gutter. We can hit that button to start a recording session.\n\nXcode then prompts to confirm and lets me know that the file will be in read-only mode until the recording is complete.\n\nNow, Xcode prepares the session. It launches the app in the simulator, in recording mode.\n\nNow, I can perform the exact interactions that I want my test to perform.\n\nI’ll start by navigating to the “Collections” screen.\n\nAnd notice how Xcode is adding code to my test method for each of my interactions. Very cool! Next, I’ll add a new collection and switch it to “edit” mode.\n\nEditing a collection is the main purpose of this test. So I’ll interact with each of the fields on this screen, to edit the title, description, and add a landmark.\n\nThis one looks perfect! That completes our steps to add and edit a new collection. Finally, as a simple verification of our edit, let’s select the landmark we added to the collection to navigate to its details.\n\nThat’s all we need for this UI test. Back in the source editor, I’ll hit “Stop Recording” in the editor gutter to end the test recording session.\n\nNow, let’s use the test diamond to see our test in action.\n\nNotice how Xcode has generated concise code for all of our interactions. Plus, we get multiple identifier options for many elements.\n\nWe can use those to fine tune how an element is identified in our tests. It’s so much easier to make a new UI test when you can simply perform the interactions in the app that you want the test to perform.\n\nAnd that’s an example of recording a UI test in Xcode 26. Xcode takes care of all the heavy lifting of converting your interactions into the best possible test code. But UI testing code generation doesn’t stop there. The same code generation has been integrated into the test report’s Automation Explorer.\n\nHere, I’ve got a Test Report open, containing a UI test failure. It looks like the test was trying to tap a TextField but couldn’t find one with the specified identifier. On the right, the Automation Explorer contains a full video recording of the test. We can replay the whole test in real time, if we need to.\n\nThe current video frame is showing the point when the failure occurred. We can certainly see a description field in the app’s UI. What’s awesome about UI testing is that Xcode records attributes about every identifiable element while running a test. We can then inspect elements in the Automation Explorer after the fact. So let’s inspect the “description” element. Looking at the element’s details, it has the correct identifier, but its type is actually a Text View, not a Text Field, as the test was expecting. It looks like the app’s UI had been updated to support multi-line descriptions. Helpfully, the correct code snippet to identify this element was generated for us. We can simply copy the code from the popover and update our test to make the correction.\n\nAnd that’s the improved UI testing experience. In addition to enhanced UI recording, this year’s Xcode also has better device support for automated hardware interactions, including hardware keyboard and hardware button presses.\n\nAll together these enhancements make UI testing a much more streamlined experience. So give it a try, add some UI tests to your project today and take advantage of Xcode Cloud to run your tests autonomously. To learn a lot more, please see “Record, replay, and review: UI automation in Xcode”.\n\nUI testing is also great for measuring the responsiveness of your UI, using the “measure” API. In Xcode 26, we’ve expanded the API by adding an XCTHitchMetric so you can now catch hitches in your app during testing. For example, as shown here, you could use XCTHitchMetric to test the scrolling animation performance of your app.\n\nXCTHitchMetric reports multiple metrics for your app’s hitch performance, such as Hitch Time Ratio.\n\nHitch Time Ratio represents the total amount of time your app was hitching over the duration of the measured portion of your test.\n\nFor more information on hitches, see the tech talk “Explore UI animation hitches and the render loop”.\n\nAnother great way to regression test your code is with Runtime API Checks. This year’s Xcode is bringing more Runtime API Checks to tests, configured in the Test Plan configuration editor.\n\nTests can now surface framework runtime issues as well as call out threading problems using the Thread Performance Checker.\n\nThe Thread Performance Checker detects threading issues like priority inversions and non-UI work on the main thread. Here, for example, Thread Performance Checker is notifying us of an API that shouldn’t be called on the main thread if we want to keep our app responsive.\n\nTest Plans also provide an option to fail a test if runtime API checks find any issues. Now your tests can provide you assurance that your code continues to follow API best practices. Those are just some of the new and exciting features this year. Xcode 26 can help you be more efficient while writing code, can guide you as you build new features, and gives you new tools that make it easy to support more platforms and languages. It can help you whether you’re debugging at your desk, inspecting the performance of your app in the wild, or testing your user interfaces.\n\nDownload Xcode 26 to create, build, and debug your code. And use Xcode Cloud to test and distribute your app. Ask us any questions you may have in the Developer Forums. And to learn more, please check out our release notes on developer.apple.com. Thanks for watching!",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "5:25",
      "title": "Using Playgrounds",
      "language": "swift",
      "code": "import Playgrounds"
    },
    {
      "timestamp": "5:30",
      "title": "Using Playgrounds",
      "language": "swift",
      "code": "#Playground {\n  \n}"
    },
    {
      "timestamp": "5:37",
      "title": "Using Playgrounds",
      "language": "swift",
      "code": "let landmark = Landmark.exampleData.first"
    },
    {
      "timestamp": "6:10",
      "title": "Using Playgrounds",
      "language": "swift",
      "code": "let region = landmark?.coordinateRegion"
    },
    {
      "timestamp": "6:33",
      "title": "Regex to scan for floating point numbers",
      "language": "swift",
      "code": "func scanForFloatingPointNumbers() -> [Regex<Substring>.Match] {\n    return self.matches(of: /[0-9]*[.][0-9]+/)\n}"
    },
    {
      "timestamp": "6:49",
      "title": "Adding another playground",
      "language": "swift",
      "code": "let string = \"lon: -113.16096, lat: 36.21904\"\nlet longitude = string.scanForFloatingPointNumbers().first\nlet latitude = string.scanForFloatingPointNumbers().last"
    },
    {
      "timestamp": "7:33",
      "title": "Updated regular expression",
      "language": "swift",
      "code": "func scanForFloatingPointNumbers() -> [Regex<Substring>.Match] {\n    return self.matches(of: /[+-]?[0-9]*[.][0-9]+/)\n}"
    },
    {
      "timestamp": "18:49",
      "title": "Checking for camera authorization",
      "language": "swift",
      "code": "// Checking for camera authorization\n\nvar isCameraAuthorized: Bool {\n    get async {\n        let status = AVCaptureDevice.authorizationStatus(for: .video)\n\n        // Determine if the user previously authorized camera access.\n        var isAuthorized = status == .authorized\n\n        // If the system hasn't determined the user's authorization status,\n        // explicitly prompt them for approval.\n        if status == .notDetermined {\n            isAuthorized = await AVCaptureDevice.requestAccess(for: .video)\n        }\n\n        return isAuthorized\n    }\n}"
    },
    {
      "timestamp": "34:40",
      "title": "Test scrolling animation performance with XCTHitchMetric",
      "language": "swift",
      "code": "// XCTHitchMetric\n\nfunc testScrollingAnimationPerformance() throws {\n    // Custom performance test measure options.\n    let measureOptions = XCTMeasureOptions()\n    measureOptions.invocationOptions = .manuallyStop\n\n    // App being tested.\n    let app = XCUIApplication()\n\n    // Launch app and get reference to scroll view.\n    app.launch()\n    let scrollView = app.scrollViews.firstMatch\n\n    measure(metrics: [XCTHitchMetric(application: app)], options: measureOptions) {\n        scrollView.swipeUp(velocity: .fast)\n        stopMeasuring()\n        scrollView.swipeDown(velocity: .fast)\n    }\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Analyzing CPU usage with the Processor Trace instrument",
        "url": "https://developer.apple.com/documentation/Xcode/analyzing-cpu-usage-with-processor-trace"
      },
      {
        "title": "Enabling enhanced security for your app",
        "url": "https://developer.apple.com/documentation/Xcode/enabling-enhanced-security-for-your-app"
      },
      {
        "title": "Measuring your app’s power use with Power Profiler",
        "url": "https://developer.apple.com/documentation/Xcode/measuring-your-app-s-power-use-with-power-profiler"
      },
      {
        "title": "Understanding and improving SwiftUI performance",
        "url": "https://developer.apple.com/documentation/Xcode/understanding-and-improving-swiftui-performance"
      },
      {
        "title": "Xcode updates",
        "url": "https://developer.apple.com/documentation/Updates/Xcode"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2025/247/5/5455d9cc-d071-4119-84e7-db8eadeaaeb0/downloads/wwdc2025-247_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2025/247/5/5455d9cc-d071-4119-84e7-db8eadeaaeb0/downloads/wwdc2025-247_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "225",
      "year": "2025",
      "title": "Code-along: Explore localization with Xcode",
      "url": "https://developer.apple.com/videos/play/wwdc2025/225"
    },
    {
      "id": "361",
      "year": "2025",
      "title": "Create icons with Icon Composer",
      "url": "https://developer.apple.com/videos/play/wwdc2025/361"
    },
    {
      "id": "308",
      "year": "2025",
      "title": "Optimize CPU performance with Instruments",
      "url": "https://developer.apple.com/videos/play/wwdc2025/308"
    },
    {
      "id": "306",
      "year": "2025",
      "title": "Optimize SwiftUI performance with Instruments",
      "url": "https://developer.apple.com/videos/play/wwdc2025/306"
    },
    {
      "id": "226",
      "year": "2025",
      "title": "Profile and optimize power usage in your app",
      "url": "https://developer.apple.com/videos/play/wwdc2025/226"
    },
    {
      "id": "344",
      "year": "2025",
      "title": "Record, replay, and review: UI automation with Xcode",
      "url": "https://developer.apple.com/videos/play/wwdc2025/344"
    },
    {
      "id": "220",
      "year": "2025",
      "title": "Say hello to the new look of app icons",
      "url": "https://developer.apple.com/videos/play/wwdc2025/220"
    },
    {
      "id": "245",
      "year": "2025",
      "title": "What’s new in Swift",
      "url": "https://developer.apple.com/videos/play/wwdc2025/245"
    },
    {
      "id": "256",
      "year": "2025",
      "title": "What’s new in SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2025/256"
    },
    {
      "id": "10171",
      "year": "2024",
      "title": "Demystify explicitly built modules",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10171"
    }
  ],
  "extractedAt": "2025-07-18T09:34:47.538Z"
}