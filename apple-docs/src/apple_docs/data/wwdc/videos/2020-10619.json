{
  "id": "10619",
  "year": "2020",
  "url": "https://developer.apple.com/videos/play/wwdc2020/10619/",
  "title": "Tap into Game Center: Leaderboards, Achievements, and Multiplayer",
  "speakers": [],
  "duration": "",
  "topics": [
    "Graphics & Games"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "♪ Voiceover: Hello, and welcome to WWDC. Udayan Kale: Hi, everyone. I'm Udayan Kale. I am on the Game Center Engineering team. In this session, we will be talking about all the new features and Games Center leaderboards, achievements, and multiplayer. So let's talk about Game Center leaderboards. I will do a quick recap of Game Center leaderboards and then show you everything that's new this year. Leaderboards have always been an integral part of Game Center. A leaderboard is driven by scores and ranks players based on these scores. Players can view their friend and global ranks and challenge other players to beat their scores. You can share leaderboards across versions of your games on iOS, tvOS, and macOS. Game Center provides a lot of choices when it comes to contributing leaderboards and setting the score format, scoring types, and sort order. Game Center leaderboards have always been the traditional nonexpiring type. They maintain players codes and rankings forever. We now refer to these leaderboards as classic leaderboards. Here are a few examples. A gamer wants to keep track of the overall total number of experience points earned by players, or the most points ever collected, or the shortest time taken to complete a game level. These are all good use cases for classic leaderboards. So what's new this year? We now have a new type of leaderboard called recurring leaderboards. We have also completely redesigned the in-game UI, and we have a new set of APIs to access leaderboard data and submit scores. I will go over the new UI and APIs later. For now, let's look at recurring leaderboards. Recurring leaderboards are short-lived leaderboards that repeat on a periodic basis. These leaderboards would be great if your game wants to support periodic timed events. Here are some good use cases. You want your game to run a fifteen minute competition every hour, or you want to host a one-hour challenge every Sunday at noon, or you just want to run a new leaderboard each week. A recurring leaderboard will give your players a fresh start start every time to complete for top spots. Here is a deeper look at how Game Center recurring leaderboards work. A recurring leaderboard is a sequence of individual time data boards that start and end on a periodic basis. We call each of these individual leaderboards an occurrence. These occurrences are short-lived and do not overlap. Each new occurrence begins only after the current one ends. You configure a recurring leaderboard using a set of parameters in App Store Connect. Initial start date defines when your leaderboard would start creating occurrences. Frequency specifies the rate at which occurrences repeat, and duration specifies the time during which scores can be submitted to an active occurrence. You can introduce a time delay between occurrences using different values for frequency and duration. Each occurrence also maintains information about the start date of the next occurrence. So you know exactly when the next one begins. You can access each occurrence through an instance of the GKLeaderboard class. So let me show you how to configure the examples I mentioned earlier. In the first example you have a 15-minute competition every hour at the top of the hour. You configure this leaderboard with a desired initial startdate, a 60-minute frequency, and a 15-minute duration. The second example describes a one-hour contest every Sunday at noon. You set the start date, a frequency of seven days, and a duration of 60 minutes. The third example shows a recurring leaderboard that runs daily with no gaps between occurrences. And to ensure that occurrences do not overlap, the duration must not be greater than the frequency. Now that you know how recurring leaderboards are configured, let's talk about incorporating leaderboards in your game. The whole purpose of adding leaderboards to your game is to capture scores earned by players and display the scores so players can see their rankings. I will now show you how to submit scores to leaderboards. Submitting scores to a classic leaderboard is easy because a classic leaderboard never ends. You just call the submit score method passing in a score, a context, player, and one or more leaderboard IDs. Context is an optional value that you can associate with this code. The leaderboard will retain either the best score or the most recent score. For recurring leaderboards, scores can only be submitted to the currently active occurrence. You have two ways to submit scores to a recurring leaderboard. The first is to use the same method that we used for classic leaderboards. The score will be posted to the currently active occurrence, if one exists at the time of submission. The second option is to use a method on the GKLeaderboard instance that corresponds to an occurrence. As long as that occurrence is active, score submissions will succeed. You can query the start date and duration properties of GKLeaderboard to determine if the occurrence is active. Game Center defers forwarding scores to the server if the device is offline. The server validates a score based on the time it's received and not when it was earned by the player. So it's possible that an active leaderboard occurrence may have expired when the score reaches the server. Next let's talk about displaying leaderboards in your game. You have two options when it comes to showing leaderboards from within your game: using GameKit's new in-game UI or displaying your own custom UI. I strongly recommend using GameKit's in-game UI, as it's very easy to adopt and does most of the heavy lifting for you. For this, you will use the GKGamesCenterViewController class that you may already be familiar with. In the previous session, I showed you how to invoke Game Center dashboard. I will now show you how to directly display a list of leaderboards from within your game. You can see here, I initialize the GKGameCenterViewController, specifying the leaderboards state. This gives you a list of leaderboards that you see here on the right. At this point, the user can navigate to a particular leaderboard that they are interested in and select it. That will display the scores for that leaderboard. On the scores view, players can see how they rank against friends, recently played, and global players. They can use the filter in the header area to change their time scope for classic leaderboards or the occurrence for recurring leaderboards. And they can scroll to the top of the list by just tapping on the name in the header. You can even deep link to a specific leaderboard to directly display scores. So here, I have initialized GKGameCenterViewController with a leaderboard ID, a player scope, and a time scope. You get the scores view that you see on the right. So you see, adopting Game Center's in-game UI is that easy. But if you want to draw your own UI, you have to load the leaderboards and scores programmatically. We have introduced new APIs to work with leaderboards and scores, and you can read about them in the developer docs. Recurring leaderboards need special handling when dealing with occurrences. When you load a recurring leaderboard, only the current occurrence is loaded. You can use this current occurrence to load a previous one by calling the method, loadPreviousOccurrence, as shown here. Here are some considerations to keep in mind when loading previous occurrences. Game Center keeps expired occurrences around for up to 30 days from their expiry. However, a signed in player can view scores only on the current occurrence and one previous occurrence. The previous occurrence is usually the most recent expired occurrence in which the player submitted a score. In the example shown here, player one can view the scores on the current occurrence 53 and the previous occurrence 50. If a player never submitted a score to an occurrence, or if that occurrence was purged, then the immediate previous occurrence is accessible. So in the case of Player 2, they can view occurrences 53 and 52. If no occurrence is currently active, the most recent occurrence is still considered current for accessing scores. Next let's talk about setting up the leaderboards in App Store Connect. This screen shows the leaderboard for a typical game in App Store Connect. Most of the setup involving leaderboards, sets, and groups is the same as before and is common to both classic and recurring leaderboards. I would now show you the additional configuration you will need for recurring leaderboards. To add a new leaderboard, just click the plus icon next to the section title. When the pop up that shows, choose the type of leaderboard you wish to create. Your game can have just classic leaderboards, or just recurring leaderboards, or a combination of both. Once you select the type of leaderboard, you need to configure it. For both classic and recurring leaderboards, you must populate the section at the top. This is the same as you do today. The section at the bottom is only available for recurring leaderboards. The start date and time specifies when your leaderboard will start creating occurrences. The duration is a time interval during which scores can be submitted to an occurrence, and restart period specifies how frequently new occurrences will be created. The duration and restart period are both specified in minutes, hours, or days. The restart period must be equal to or larger than the duration, so occurrences do not overlap. Once you have configured a leaderboard, you must localize it. Both classic and recurring leaderboards have the same options when adding languages. We strongly recommend that you upload an image for your leaderboard that reflects some aspect of your game. This image is prominently displayed in the in-game UI. So that's it for Game Center leaderboards this year. We cannot wait to see games adopting these new features in various creative ways. Next up is achievements. And for that, let me welcome Dersu. Thank you! Dersu Abolfathi: Thank you, Udayan. Let's talk about achievements in Game Center. So what is an achievement? An achievement is a collectible item indicating the player has successfully reached a particular goal in your game. Achievements have been a fundamental part of Game Center since its inception, as they provide players an additional way of engaging with the game, tracking gameplay progress, and sharing that progress with friends. Players will notice a fresh, new, and consistent look to achievement badges. As the developer, you define the achievements available for players to work towards. An achievement will appear to players in one of four forms: locked, in-progress, completed, or hidden. Before the player has made any progress toward achievement, it will appear locked. Some players will often scan the achievements list and browse locked achievements as a guide for what they should do in your game. In this sense, your achievements list gives you an opportunity to tell users what to think about while playing your game. After you start reporting progress for a user toward some achievement, it will display as in-progress. Once you report 100 percent progress for that achievement, it is considered complete. At this point, the user will see the image tied to the achievement, and it will show up in their list of completed achievements. Last, you can explicitly mark an achievement as hidden until the player has completed it. You might do this if you feel the achievement description itself prematurely reveals aspects of the game's story or plot. Alternatively, consider using hidden achievements to surprise, delight, or humor the player. For example you might include a hidden achievement that rewards the player for failing spectacularly. This year we're bringing achievements to more places, including the Game Center Dashboard on iOS, macOS, and tvOS. The dashboard is a brand new area for players to view Game Center related information for your game. It's accessible straight from your game, and it showcases your game's achievements, personalized according to the player's progress. This means it's as important as ever to make sure your achievements are engaging, accessible, and interesting for players. For some useful tips and best practices for building achievements, we recommend you check out this year's session Design for Game Center. Before finalizing your achievements design, it's important to keep in mind that there are some limits to how many you can include in your game. Your game can have a maximum of 100 achievements, each of which can award up to 100 points, and overall, your game can award up to 1000 points. You want to make sure you make the most of this budget, creating a set of achievements that require a range of skills and dedication to complete. Finally, you should keep these limits in mind when shipping the initial version of your game, as you may want to create new achievements for future updates. After you've designed some achievements, you're probably ready to start integrating them into your game. And there are three simple steps needed to do this. First you'll need to authenticate the local player. Without first authenticating, any API calls you make to GameKit will result in an error. For more on using the local player, refer to the session Tap into Game Center dashboard access point and profile. Next, you need to report the player's progress to GameKit. As long as GameKit maintains a progress of zero for an achievement, it's going to appear to the player as locked. But the most interesting part of achievements happens when the player makes progress in your game. You'll notice in-progress achievements have been completely redesigned. Game Center will present players with this brand new styling, which features a progress circle, enticing them to get back into your game. Unsurprisingly, reporting achievement progress is done through the GKAchievement class. Every achievement has a unique identifier, which you use to initialize the GKAchievement. Anytime the player makes progress towards that achievement, it's important to update that percentComplete property. Finally, you can call the report method to register that change and handle any potential errors. Now, the player will see their achievement progress update anywhere they see this achievement, and they will unlock its imagery if it's completed. Finally, let's talk about how we can show the player their achievements. Achievements have a brand new home in the Game Center in game dashboard. If you integrate the new access point, this dashboard is just one tap away for the player and your game. The Achievements tab is front and center, giving players a one stop shop for viewing all things achievements. Inside this tab the summaries give the player a high-level view of how they're doing in your game. But players can dive deeper, scanning through the achievements they've already collected, as well as previewing the ones they are working on, and some others that you've got in store for them. While the player can reach this page from the dashboard, you can also present it directly with API. Doing so is done using the GKGameCenterViewController. You can initialize it with an achievement state and optionally assign the gameCenterDelegate property on the viewController. With just these few lines of code, You'll guide players into the all-new achievements page for your game. This UI provides a clean and consistent window into your game's achievements, so it will be the preferred experience for the vast majority of games. For those any need to customizer achievements display in their own UI, this can be done using the GKAchievementDescription class. Like GKAchievement, which is what you use to update the player's progress, this class has an identifier, but it also has the achievements title as well as separate descriptions for when the achievement is unachieved and achieved. It's important to note that the title and descriptions associated with this class are localized according to the players' localization preferences. As the game developer, you will make sure that all the relevant translations are included when you set up an achievement in App Store Connect. But when interacting with the achievement descriptions, GameKit will give you strings that are ready to display to the player. And finally there are also APIs for accessing achievement images for the achieved and nonachieved cases. So we've talked a bit about how to design achievements that work well for your game. We've also shown how to work with GameKit to view and update players progress. But before you can submit an achievements-ready build of your game to the App Store, you'll need to configure those achievements in App Store Connect. To do so, go to the Features tab of your games page on App Store Connect. Then after selecting the Game Center section, you'll see an Achievement section. To add an achievement for your game, you can click the plus button. This will bring up the add achievement screen. The achievement ID must be unique to this achievement. And as you saw on the previous code sample, is used to initialize your GKAchievement object. You also have to configure a few attributes such as: point value, whether it's hidden until achieved, and whether the player can earn the achievement multiple times. These values will be reflected in the GKAchievement class we discussed earlier in the session. We can finish adding this achievement and after we're done, our build is ready to deliver to users. Now I'm going to hand it over to Christy to talk about multiplayer gaming.\n\nChristy Warren: Thank you, Dersu. I'm back to talk about multiplayer gaming, using Game Center. First I will give a quick overview of multiplayer. Then I will show our new streamlined UI. Next I will give a quick review of our basic API flows and introduce some new options for the matchmaking UI. Finally I will talk about some changes to privacy and restrictions. We support several types of multiplayer games. Real time, turn based, and server hosted. The basic idea of our APIs is that we take care of as much of the multiplayer as we can for you. For real time, we take care of finding players, connecting to them, and sending data. For turn based, we take care of turn management and storing the data. For server hosted, we deliver you a list of players that you can share with your server. We have various ways to find people to play with. Firstly, we have a really robust Auto-Match system where we can find players and get you into the game fast. All you have to do is hit Start game. You can also invite other players. We have made it super easy to interact with people you have made friends with. We also made it fast to find someone you've just played with, so you can play with them again, even in a different game. We want you to play with whomever you want, so you can invite from your contacts. This is great for developers to bring new players into the game. And finally, we work cross-platform, so your players can play multiplayer on whatever platform they like. As you've just seen, there's a new streamlined UI. This is designed to help your users find other players quickly and get into the game faster. We did this by simplifying the flow and providing improved player suggestions. But why talk about it when we can show you? Here we tap on the multiplayer button, and it brings up our matchmaking UI. Now we tap add player and go invite our friend John B. Next, we'll click on the plus button to bring up contacts and invite Vance. Now we tap invite and start game, and the last player will be automatch. So that's how you set up multiplayer game, using our new flow. So how does matchmaking look like from a coding perspective? Let's take a look at the elements of a real-time multiplayer match. Starting from MyGameController, first I authenticate the player, create a match request, and this is where I set the number of players in a match and I can define people to invite. It could be a friend, another person I recently played with, or someone I discovered nearby, and if appropriate, I can use player groups and attributes to filter the match request, a specific game mode, or other criteria. Now I have a choice, either to use this request for automatching or to present a UI for the player to select other people to invite. So let's say I'm doing automatching. Then I'd simply use the shared GKMatchmaker and provide it with my match request. Game Center will find other players. It's time to play. And you'll use the return match object to send data from player to player. Or, as I said, you could choose to present a GKMatchmakerViewController, given the match request parameters, and let the other players select their own people to invite. Once they've accepted, the game can begin. One more piece, very important, which typically should be done right at app launch is to adopt the GKInviteEventListener protocol. Register with the local player in order to listen for invites coming from other people. And now everything is ready to get started. Turn-based matchmaking follows virtually the same flow, like in this case you adopt a GKTurnBasedEventListener with a couple more methods to implement it. And like before, register with the local player. Then you set up a match request and call findMatchforRequest on the GKTurnedBasedMatch for programmatic matchmaking or you present a GKTurnBasedMatchmaker ViewController. Either way, an important difference with turn-based is that you do not wait for other players to match, but instead, you start playing immediately because it will always be your turn. For iOS 14, we have new options to configure the matchmaking UI. You can set automatch only, if you want players to match up with random other players and get quickly in the game. You can choose nearby only for games like ARKit games where you wish to have players that are in the same room with you. There's a new restriction this year that would enable restricts both the custom message in multiplayer invites as well as voice chat. Here's a new flag: personalizedCommunication Restricted. It lets the app know this, so they can, for example, turn off their voice chat UI. So if your app shows a little microphone for voice chat, and this flag comes back true, then disable the icon for this functionality. In closing, I've talked about the different types of multiplayer, ways to find players, and gave you a glimpse of the new UI. Then I did a quick API review and introduced you to new UI options for a MatchmakerViewController. And finally, I discussed a new privacy restriction. So that's our session on Game Center. Here we've covered leaderboards, achievements, and multiplayer. Here are some resources for you to check out for more depth. You can also see our design talk for more information. So thank you! And have a great WWDC. ♪",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "4:05",
      "title": "Submitting a score",
      "language": "swift",
      "code": "// Use the class method to submit score to one or more leaderboards at once\nGKLeaderboard.submitScore(self.points, context: 0, player: GKLocalPlayer.local,\n    leaderboardIDs: [\"my.leaderboard.id\"]) { error in\n}"
    },
    {
      "timestamp": "4:30",
      "title": "Submitting a score - recurring leaderboard ID",
      "language": "swift",
      "code": "// Use the class method to submit score to one or more leaderboards at once\nGKLeaderboard.submitScore(self.points, context: 0, player: GKLocalPlayer.local,\n    leaderboardIDs: [\"my.recurring.leaderboard.id\"]) { error in\n}"
    },
    {
      "timestamp": "4:48",
      "title": "Submitting to a specific occurrence of a recurring leaderboard",
      "language": "swift",
      "code": "// Submitting to a specific occurrence of a recurring leaderboard\nGKLeaderboard.loadLeaderboards(IDs:[\"my.recurring.leaderboard.id\"]) { (fetchedLBs, error) in\n    if let lb = fetchedLBs?.first {\n       lb.submitScore(self.points, context: 0, player: GKLocalPlayer.local) { error in\n       }\n    }\n}"
    },
    {
      "timestamp": "5:33",
      "title": "Launching in-game UI",
      "language": "swift",
      "code": "// Launching in-game UI\n\n// Display a list of leaderboards\nlet vc = GKGameCenterViewController(\n             state: .leaderboards)\nvc.gameCenterDelegate = self\npresent(vc, animated: true, completion: nil)\n\n\n// Or directly display scores for a specific leaderboard\nlet vc = GKGameCenterViewController(\n             leaderboardID: \"YOUR_ASC_LEADERBOARD_ID\",\n             playerScope: .global,\n             timeScope: .allTime)\nvc.gameCenterDelegate = self\npresent(vc, animated: true, completion: nil)"
    },
    {
      "timestamp": "7:14",
      "title": "Accessing previous occurrence",
      "language": "swift",
      "code": "// Accessing previous occurrence\n\n// Load current occurrence of a recurring leaderboard\nGKLeaderboard.loadLeaderboards(IDs:[\"my.recurring.leaderboard.id\"]) { (fetchedLBs, error) in\n    if let current = fetchedLBs?.first {\n       // Load previous occurrence using the current occurrence\n       current.loadPreviousOccurrence { (prevOccurrence, error) in\n           // Do something with the previous occurrence\n       }\n    }\n}"
    },
    {
      "timestamp": "14:34",
      "title": "Reporting achievement progress",
      "language": "swift",
      "code": "if let achievement = GKAchievement(identifier: identifier) {\n    achievement.percentComplete = percentComplete\n    GKAchievement.report([achievement]) { error in\n        if let error = error {\n            print(\"Error in reporting achievements: \\(error)\")\n        }\n    }\n}"
    },
    {
      "timestamp": "16:05",
      "title": "Displaying Game Center achievements",
      "language": "swift",
      "code": "// Showing the Game Center achievements page\n\nlet viewController = GKGameCenterViewController(state: .achievements)\nviewController.gameCenterDelegate = self\npresent(viewController, animated: true)"
    },
    {
      "timestamp": "23:50",
      "title": "Check if personalized communication is restricted",
      "language": "swift",
      "code": "// Check if personalized communication is restricted\nif GKLocalPlayer.local.personalizedCommunicationRestricted {\n    // Disable UI for Voice chat\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2020/10619/4/05AE01B8-DBEB-4628-B955-167A86ECB3AE/wwdc2020_10619_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2020/10619/4/05AE01B8-DBEB-4628-B955-167A86ECB3AE/wwdc2020_10619_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10065",
      "year": "2022",
      "title": "Plug-in and play: Add Apple frameworks to your Unity game projects",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10065"
    },
    {
      "id": "10064",
      "year": "2022",
      "title": "Reach new players with Game Center dashboard",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10064"
    },
    {
      "id": "10067",
      "year": "2021",
      "title": "Bring Recurring Leaderboards to your game",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10067"
    },
    {
      "id": "10066",
      "year": "2021",
      "title": "What’s new in Game Center: Widgets, friends, and multiplayer improvements",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10066"
    },
    {
      "id": "10145",
      "year": "2020",
      "title": "Design for Game Center",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10145"
    },
    {
      "id": "10618",
      "year": "2020",
      "title": "Tap into Game Center: Dashboard, Access Point, and Profile",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10618"
    }
  ],
  "extractedAt": "2025-07-18T10:34:04.236Z"
}