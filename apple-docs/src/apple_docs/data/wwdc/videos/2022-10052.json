{
  "id": "10052",
  "year": "2022",
  "url": "https://developer.apple.com/videos/play/wwdc2022/10052/",
  "title": "What's new in SwiftUI",
  "speakers": [],
  "duration": "",
  "topics": [
    "SwiftUI & UI Frameworks"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "â™ª instrumental hip hop music â™ª â™ª Hi, I'm Nick. And I'm Franck, and we are SwiftUI engineers. Today, we're going to cover \"What's new in SwiftUI.\" SwiftUI is growing alongside our operating systems, each pushing the bounds of the other. We continue to be amazed and delighted by what you are making with SwiftUI. We take to heart all flavors of feedback from the community. That's why we're especially excited to share what we've focused on this year. With this year's APIs, we've gone deeper. We've made more custom experiences possible. We've introduced some amazing new graphical techniques. We've architected a new SwiftUI app structure, and much more. SwiftUI enabled us to build designs and features that reflect the future of our platforms. From redesigns of classic apps to completely new features to deep system integrations. This comprehensive adoption within Apple further pushes evolution of SwiftUI. Many of these new designs and features are only possible because of how SwiftUI has evolved how we write apps at Apple. Today we're celebrating these APIs,  And we're also celebrating SwiftUI's birthday,  Franck and I are the lucky cochairs of the party-planning committee. Let me tell you about the activities we've got planned for the party. I'll introduce you to a brand-new framework called Swift Charts that allows you to create delightful data visualizations across all of our platforms. I'll show off SwiftUI's data-driven, strongly-typed model for navigation and new window techniques. Franck will take you through a suite of new controls and deeper customizations of existing controls. Then he'll show you how we've brought sharing elegantly into the universe of SwiftUI with the Transferable protocol. Finally, I'll close with whimsical new graphics APIs and advanced new layout APIs. Let's get going with Swift Charts. Swift Charts is a declarative framework for building beautiful state-driven charts. The fundamental design principles that make SwiftUI great and the process of plotting data have been composed harmoniously to create Swift Charts -- a world-class data-visualization framework. This is a bar chart plotting the number of party tasks Franck and I need to complete before the party can start. Swift Charts has built a magnificent, customizable chart from only a few lines of code. Like SwiftUI, Swift Charts picks intelligent defaults. Here, the framework chose satisfyingly round numbers for the y-axis values, and provided a default color for the bar marks.\n\nIf you know SwiftUI, you can already read the declarative, state-driven syntax of Swift Charts. Chart is just some View, and you declare it just like you do lists and tables -- by providing data and then building the chart content with that data. For this chart, I've chosen a BarMark, but if I switch to a LineMark and add a foreground style to group by category, I can see more to the story as Swift Charts draws individual lines for each category and adds a legend to the chart automatically. It's fun to give these charts a little personality. I can add points to the line with the symbol modifier on the LineMark. These modifiers are no different from SwiftUI modifiers. You can even use SwiftUI views within a chart. Like List, the data argument to Chart can instead be passed to a ForEach. This allows adding more marks to the Chart builder, like a RuleMark to show our daily goal.\n\nThe spirit of SwiftUI shines through again, as Swift Charts handles localization, Dark Mode, and Dynamic Type automatically, and of course, works across all of our platforms. If you want to see how to make your own charts, check out \"Hello Swift Charts.\" If you're interested in advanced plotting techniques, follow it up with the \"Raise the bar\" session. Next up, let's talk about navigation and windows. SwiftUI already supports the most common app navigation patterns, such as immersive push-and-pop navigation stacks; expansive, detail-rich split views; and powerful, multi-window experiences.\n\nThis year, SwiftUI has big updates for all three of these patterns. Let's start with stacks. SwiftUI is introducing a new container view, simply called NavigationStack, for supporting push-and-pop-style navigation. A NavigationStack wraps a root content view, like this food inventory list for our party-planning app. As you'd expect, it works great with existing APIs like NavigationLink and navigationTitle(). When we select a link, SwiftUI pushes its detail view on top of the stack. In our app, each detail view contains more links for related food items for quick browsing.\n\nThis approach might be all you need. But there is a new way to present views and have programmatic control over that presented state. If you need control of a navigation stack's state, adopt the new data-driven APIs. The new navigationDestination() modifier lets us associate navigation destinations with specific data types.\n\nAnd this year, we taught NavigationLink a new party trick: instead of a destination view, it can take a value that represents a destination. When tapping on a link, SwiftUI will use its value's type to find the right destination and push it on the stack, just like before. Because we now use data to drive our stack, it's possible to represent the current navigation path as explicit state. In this case, the navigation path is simply an array of all the food items that we've visited. With direct access to this state, it couldn't be easier to add a button for quickly jumping back to the first selected item. As views are pushed onto the stack, items are appended to the selectedFoodItems array. In the button's action, we can just remove all the items from the path except for the first one.\n\nAnd with a tap, we're right back where we started.\n\nNow let's talk about split views for multicolumn navigation. We're introducing another new container called NavigationSplitView for multicolumn navigation. NavigationSplitView can declare two- and three-column layouts. Party Planner uses a simple two-column layout, wrapping a sidebar list of our party-planning tasks and a detail view that changes its content with the selected task. Split views work great with the new value-based NavigationLinks we saw earlier, using the link's value to drive the list's selection. NavigationSplitView will automatically collapse into a stack on smaller-size classes or devices, making it a great tool for building adaptive, multiplatform apps. NavigationSplitView and NavigationStack are designed to work together and can be directly composed to build more complex navigation structures. We use this in the Party Planner app to turn the detail column into its own, self-contained navigation stack, which also shows off the new support for navigation stacks on macOS.\n\nWell, we've talked a lot about food, but I hear that my colleague Curt is cooking up a storm over in his talk, \"The SwiftUI cookbook for navigation.\" Check it out to learn even more about navigation stacks and navigation split views. But for now, let's step outside the box and talk about new scene APIs. You're likely already familiar with WindowGroup, which is a great way to build the main interface of your app, and can generate multiple windows to allow different perspectives into your app's data. New this year, we're adding window, which -- you guessed it -- declares a single, unique window for your app. Here, I've added a Party Budget window that shows the total cost of the party.\n\nBy default the window is available and can be shown by selecting its name in the app's Window menu. But we can make that even easier by assigning a Command-0 keyboard shortcut to open the window. To make sure I stay a budget-conscious party planner, I'll add a toolbar button with an action that also shows this window. Using the environment action openWindow, I can now programmatically open new SwiftUI-managed windows. In fact, we've added a whole suite of new window customizations this year, including modifiers for default size, position, resizability, and more. I don't want the party budget getting in the way, so by default it appears as a small corner window. But if I adjust its position or size, SwiftUI will automatically remember that across app launches. The new standalone window scene is great for little auxiliary windows like this one on the Mac, but Party Planner is a multiplatform app, and we need a better design for smaller screens. For example, on iOS we've chosen to display our budget within a resizable sheet instead. This is possible with the new presentationDetents() modifier. In this case, I configured a resizable sheet that sticks to two different sizes: one at 250 points, and another at a system-defined medium height. It is simple to iterate between platforms this year with multiplatform targets in Xcode powering up your SwiftUI-based apps. One target can be deployed to multiple platforms. Just pick your platform from the usual pull-down menu in Xcode's toolbar. Watch \"What's new in Xcode\" and follow it up with \"Use Xcode to develop a multiplatform app\" to learn more. For the final new scene type, we can turn our attention to the menu bar. With macOS Ventura, you can now build MenuBarExtras entirely in SwiftUI! These can be defined alongside other scene types in your application and will always be shown in the menu bar while your app is running. Or, you can build an entire app using just a MenuBarExtra! These are such a fun way to bring even the simplest of ideas to life on macOS. \"Bring Multiple Windows to your SwiftUI App\" has more detail on how to take advantage of all the new scene types and features. Now that we've got control of windows, I'll pass it over to Franck, to put controls in windows. Franck: Thanks, Nick! This year, we have a variety of enhancements across all our APIs for building interactive content. We have a lot to cover, so let's get this party started with some fun enhancements to forms. macOS Ventura comes with a brand-new System Settings app, that features a streamlined navigation structure, built using the navigation split view and stacks that Nick just walked us through. It also sports a fresh and modern interface style. Settings interfaces are control-heavy, so this style was specifically designed to present forms containing many controls in a consistent and well-organized fashion. We've also adopted this new design within our Party Planner app. Let's take a look. Our Event Details view also features many different types of controls grouped into sections, serving a similar purpose as a settings interface. This makes it a great candidate to adopt the new visual style from System Settings.\n\nYou can enable this design using the new grouped formStyle on macOS. And thanks to the flexibility of SwiftUI's declarative APIs, content and controls within the form will automatically adapt to the new style. For example, sections will visually group their content below their headers; and controls will consistently align their labels and values to the leading and trailing edges. Some controls may adapt their visual appearance as well, such as how toggles display as trailing mini switches for consistent layout and alignment. And since the form itself provides a lot of visual structure, other controls adapt to this context with a lighter-weight visual appearance, and reveal more prominent control backings on rollover. SwiftUI makes it easy to align other types of content to this new style, using the new LabeledContent view, which can be used to build new controls or even just display some read-only information. In this case, we're displaying some text for the location of the event, and SwiftUI automatically adjusts the styling and allows selection of that text.\n\nBut LabeledContent can also wrap any kind of view, like if we wanted to use a custom view for displaying more entire addresses. SwiftUI is now smarter about applying default styling to text in other cases too. It will hierarchically format multiple pieces of text within a control's label to form titles and subtitles. This new form design looks great on macOS, but we can also share a lot of this same code with the iOS version of our app.\n\nYou'll notice some improved designs on iOS as well, like these pop-up menu pickers with a visual style inspired by macOS, but with their interactions and appearance optimized to fit beautifully within a touch-based interface. Of course, the same code works great on iPad's larger screen, and together with the Mac, you can see how SwiftUI's declarative model helps you share code when building shared interfaces, helping you bring the party to every platform. Of course, we're also improving controls beyond just form styles. So let's take a lightning-round tour of some other new control features we're using in the Party Planner app. Let's start with the New Activity page in our iOS app. Text fields can be configured to expand vertically using the new axis parameter, growing their height to fit the text and, if specified, capping their height to the line limit. But the lineLimit modifier now also supports more advanced behaviors, like reserving a minimum amount of space and expanding as more content is added, and then scrolling once the content exceeds the upper limit. Below our text fields, we also see an example of the new MultiDatePicker control, supporting noncontiguous date selection to help us spread our party activities throughout the week.\n\nNow at this point, maybe you're having some mixed feelings about the party theme for this talk. The great news is you can now express those feelings in SwiftUI, using mixed-state controls! Here we have a group of toggles that can be collapsed into a single aggregate toggle. The inner toggles each take a single binding whereas the aggregate Toggle takes a collection of all the bindings displaying a mixed state if their values don't all match.\n\nPickers work the same way. This decoration theme picker changes its value to reflect the currently selected decoration. But if we select multiple decorations, it will show the themes for all them using a mixed-state indicator. Now, let's switch back to our iOS app. We have a few button-style toggles for choosing the event hashtags. We can help differentiate each toggle by simply adding a bordered button style. Button styles like this will now apply to any control that supports a button-like appearance, including toggles, menus, and pickers. Moving on to steppers, you can now provide a format for its value. On macOS, a formatted stepper will display its value in an editable field. And steppers are also now available on watchOS. Apple Watch sports one of my favorite new features: Accessibility Quick Actions, an alternative way to perform actions by clenching your hand. A Quick Action can be defined just like any other UI action, using a button, allowing us to share the same code for both visible buttons and their equivalent Quick Actions. All right, we just covered a lot of different controls, but of course, controls are not the only sources of interactivity. So let's take a look at what's new with larger interactive containers, like tables and lists.\n\nI am excited to share that tables are now supported on iPadOS. As you would expect, tables on iPadOS are defined using the same Table API we introduced last year for macOS, making it easy to share code between platforms. Our Invitations table shows three columns for the name, city, and invitation status of each person, taking advantage of the iPad's large display. But this table will also render appropriately in compact size classes, including on iPhone, showing just the primary column within the smaller screen space. Let's switch contexts and check out this table on macOS. It's looking great! But speaking on contexts, I'd love to add some context menus for performing common actions within the table. This is a job for the new selection-based contentMenu modifier. The modifier takes a selection type, and will be enabled within any compatible table or list that supports selection. Within the menu builder, you are given a collection of the current selection, allowing you to build advanced context menus that can operate on a single selected row, multiple selected rows, or even no row selected, such as when clicking on the empty area of the table. Context menus reveal actions directly within the table, which is great for speed and efficiency. But I would also like to make these actions more discoverable. A great way to improve discoverability is by displaying common actions as buttons in the toolbar, and iPadOS has a new and improved toolbar design to help achieve that extra level of polish. iPad toolbars can now support user customization and reordering, which your app can implement by providing explicit identifiers for each toolbar item, the same API available on macOS. These identifiers allow SwiftUI to automatically save and restore custom toolbar configurations across app launches. Note that on iPadOS, not all toolbar items allow customization. Customizable actions are configured using the new secondaryAction toolbar item placement, which shows up in the center of the toolbar by default, or in an overflow menu in compact-size classes. All right! The word is spreading around and it looks like the number of attendees is growing exponentially. Let's help our table manage the scale by adding support for search. SwiftUI already supports basic search with a searchable modifier. And new this year, search fields can support tokenized inputs and suggestions to help build more structured search queries. To help with filtering results, SwiftUI now supports search scopes, which appear in a scope bar beneath the toolbar on macOS and as a segmented control within the navigation bar on iOS. We have only scratched the surface of what is possible with SwiftUI on iPad this year. Check out the \"SwiftUI on iPad\" series and learn more. Now that we have a bit more control over the event details and logistics, let's share the news and get people even more excited. Sharing content with other people, as well as sharing data across applications are essential parts of many apps. Taking advantage of these features makes your app even more integrated into the workflows of the people who use them. This year we have a few exciting areas to make that even easier. Let's start with PhotosPicker, a new multiplatform and privacy-preserving API for picking photos and videos. Since photos are an essential part of any party, I've added a feature to the Party Planner app that adds fun birthday effects to photos that were taken. The new PhotosPicker view can be placed anywhere in your app, and on activation, presents the standard photos-picking UI to select photos or videos from the user's library. PhotosPicker take a binding to a selected item, which provides access to the actual photo and video data.\n\nIt also has additional rich configuration options, such as filtering the type of content, preferred photo encoding, and more.\n\nThis is the most photogenic cupcake I have ever seen. But one cupcake isn't enough. Let's apply the special effect as we move on. Now that we have our customized photo, we're ready to share it with the new ShareLink API. Each platform has a standard interface for allowing people to share content from your apps. With watchOS 9, you can now also present the share sheet from within your watch apps. The new ShareLink view enables presenting that system share sheet from within your app. You can simply provide it with the content to be shared and a preview to use in the share sheet, and it automatically creates a standard share icon button.\n\nOn tap, it presents the standard share sheet to send off the content. Share links adapt to the context they're applied to, such as in context menus and across platforms. PhotosPicker, ShareLink, and more all take advantage of the new Transferable protocol, a Swift-first declarative way to describe how types are transferred across applications. Transferable types are used to power SwiftUI features like drag-and-drop, which makes it easy to drop images from other apps into the Party Planner gallery. This makes use of the new dropDestination API, which accepts a payload type, in this case, just an image. The completion block provides a collection of the received images together with the drop location.\n\nMany standard types, such as string and image, already conform to Transferable. So it wasn't much work to get the ball rolling in our app, but you can easily take things further and implement Transferable in your own custom types. When it's time to do that, your conformance declares the representations appropriate for your type, such as using Codable support and a custom content type. To learn more about Transferable, other representations, and advanced tips and tricks, check out the \"Meet Transferable\" talk. While we were preparing the cupcakes, Nick was laying out all the supplies. Nick, how's it going over there? Nick: Almost done! I'm arranging these party horns in a completely custom layout, but I'll need a little more time. Let's talk graphics first. ShapeStyle has new APIs to achieve rich graphical effects this year. We'll use these APIs to give this guest card some party pop! Color has a new gradient property that adds a subtle gradient derived from the color. These look great with the system colors.\n\nShapeStyle also got a new shadow modifier. Adding it to the white foreground style adds a shadow to the text and to the symbol. And the detail of this shadow is remarkable. The drop shadow has applied to every element of the Calendar symbol.\n\nWith the whole world of SF Symbols and the new SwiftUI ShapeStyle extensions, you can make some absolutely gorgeous icons.\n\nNow, it's time to bring that grid of SF Symbols to the party. We'll iterate quickly on it using SwiftUI Previews, which has some fantastic improvements this year. Previews have always been a convenient way to see a view in multiple configurations at the same time. With Xcode 14, we're making this easier than ever with preview variants. These let you develop your view in multiple appearances, type sizes, or orientations at the same time without writing any configuration code. We can use that same gradient again, or we can style it as an elliptical gradient to give these images a soft glow. and preview it in dark and light appearances.\n\nPreviews now runs in live mode by default. It can't be a great birthday party without a little dancing, so let's get these SF Symbols dancing. â™ª Electronic dance music â™ª â™ª Those jovial icons demonstrate something profound. SwiftUI has taken text and image animations to the next level. Let's watch that text animate again in slow motion. Text can now be beautifully animated between weights, styles, and even layouts. And the best part: this takes advantage of the same animation APIs used throughout the rest of SwiftUI. Let's close by talking about my absolute favorite part of UI programming, applied geometry -- or as we call it, Layout. SwiftUI has added new ways to lay out views. Grid is a new container view that arranges views in a two-dimensional grid. Grid will measure its subviews up front to enable cells that span multiple columns and enable automatic alignments across rows and columns. In fact, you already got a look at grid earlier.\n\nUsing Grid, GridRow, and the gridCellColumns modifier, you can build up a grid piecemeal. Of course, just like all layouts in SwiftUI, they're built for composition. We introduced SwiftUI's layout model with the first release, providing a toolbox of primitive layout types to achieve some of the most common layouts. Most of the time, you can get the job done with these primitive layout types, but sometimes, sometimes, you want that imperative layout code: the size, the minX, the frame.origin.x minus frame.midX divided by 2 plus 3. It's times like these when you should reach for the new Layout protocol. With it, you have the full power and flexibility we used to implement SwiftUI's stacks and grids to build your own first-class layout abstractions. Using Layout, I built this bespoke seating chart layout for the guests at our birthday party. Should our party guests sit in rows or pods? With the power of Layout, we don't have to choose. Using the Layout protocol, you can build all kinds of efficient layouts, tailored to the specific needs of your view hierarchies. To learn how to adopt Layout and about other new, great layout techniques, check out the \"Compose custom layouts with SwiftUI\" session. I've prepared a taste of Layout especially for you. Using the new AnyLayout type, I can switch between the Grid layout and a custom scattered layout I've written. As this session draws to a close, there's one surprise left: You're invited! â™ª You are invited to celebrate SwiftUI's birthday and all of the new APIs with us this week. There is a lot of detail left to explore in the APIs we covered, and even more APIs that we didn't have time to include. Enjoy the party, and enjoy WWDC 2022. And we are going to enjoy some cake. â™ª instrumental hip hop music â™ª â™ª",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "2:51",
      "title": "Swift Charts: Required models and extensions",
      "language": "swift",
      "code": "import Foundation\nimport SwiftUI\n\n// MARK: - Party Planner Models\nenum PartyTask: String, Identifiable, CaseIterable, Hashable {\n    case food = \"Food\"\n    case music = \"Music\"\n    case supplies = \"Supplies\"\n    case invitations = \"Invitations\"\n    case eventDetails = \"Event Details\"\n    case activities = \"Activities\"\n    case funProjection = \"Fun Projection\"\n    case vips = \"VIPs\"\n    case photosFilter = \"Photos Filter\"\n\n    var name: String { rawValue }\n  \n   var color: Color {\n       switch self {\n       case .food:\n            return palette[0]\n       case .supplies:\n            return palette[1]\n       case .invitations:\n            return palette[2]\n       case .eventDetails:\n            return palette[3]\n       case .funProjection:\n            return palette[4]\n       case .activities:\n            return palette[5]\n       case .vips:\n            return palette[6]\n       case .music:\n            return palette[7]\n       case .photosFilter:\n            return palette[8]\n       }\n    }\n\n    var imageName: String {\n        switch self {\n        case .food:\n            return \"birthday.cake\"\n        case .supplies:\n            return  \"party.popper\"\n        case .invitations:\n            return \"envelope.open\"\n        case .eventDetails:\n            return \"calendar.badge.clock\"\n        case .funProjection:\n            return \"gauge.medium\"\n        case .activities:\n            return \"bubbles.and.sparkles\"\n        case .vips:\n            return \"person.2\"\n        case .music:\n            return  \"music.mic\"\n        case .photosFilter:\n            return \"camera.filters\"\n        }\n    }\n\n    var id: String { rawValue }\n\n    var subtitle: String {\n        switch self {\n        case .food:\n            return \"Apps, 'Zerts and Cakes\"\n        case .supplies:\n            return \"Streamers, Plates, Cups\"\n        case .invitations:\n            return \"Sendable, Non-Transferable\"\n        case .eventDetails:\n            return \"Date, Duration, And Placement\"\n        case .funProjection:\n            return \"Beta â€” How Fun Will Your Party Be?\"\n        case .activities:\n            return \"Dancing, Paired Programing\"\n        case .vips:\n            return \"User Interactive Guests\"\n        case .music:\n            return \"Song Requests & Karaoke\"\n        case .photosFilter:\n            return \"Filtering and Mapping\"\n        }\n    }\n\n    var emoji: String {\n        switch self {\n        case .food:\n            return \"ðŸŽ‚\"\n        case .music:\n            return \"ðŸŽ¤\"\n        case .supplies:\n            return \"ðŸŽ‰\"\n        case .invitations:\n            return \"ðŸ“¨\"\n        case .eventDetails:\n            return \"ðŸ—“\"\n        case .funProjection:\n            return \"ðŸ§­\"\n        case .activities:\n            return \"ðŸ’ƒ\"\n        case .vips:\n            return \"â­ï¸\"\n        case .photosFilter:\n            return \"ðŸ“¸\"\n        }\n    }\n}\n\nprivate let palette: [Color] = [\n    Color(red: 0.73, green: 0.20, blue: 0.20),\n    Color(red: 0.95, green: 0.66, blue: 0.24),\n    Color(red: 0.14, green: 0.29, blue: 0.49),\n    Color(red: 0.46, green: 0.76, blue: 0.67),\n    Color(red: 0.30, green: 0.33, blue: 0.22),\n    Color(red: 0.49, green: 0.55, blue: 0.64),\n    Color(red: 0.92, green: 0.53, blue: 0.30),\n    Color(red: 0.20, green: 0.45, blue: 0.55),\n    Color(red: 0.41, green: 0.45, blue: 0.45),\n    Color(red: 0.87, green: 0.67, blue: 0.61)\n]\n\n// MARK: - Swift Charts Models\n\nstruct RemainingPartyTask: Identifiable {\n    let category: PartyTask\n    let date: Date\n    let remainingCount: Int\n\n    let id = UUID()\n}\n\nlet remainingSupplies: [RemainingPartyTask] = [\n    RemainingPartyTask(category: .supplies, date: .daysAgo(4), remainingCount: 10),\n    RemainingPartyTask(category: .supplies, date: .daysAgo(3), remainingCount: 11),\n    RemainingPartyTask(category: .supplies, date: .daysAgo(2), remainingCount: 9),\n    RemainingPartyTask(category: .supplies, date: .daysAgo(1), remainingCount: 4),\n    RemainingPartyTask(category: .supplies, date: .daysAgo(0), remainingCount: 1),\n]\n\nlet remainingInvitations: [RemainingPartyTask] = [\n    RemainingPartyTask(category: .invitations, date: .daysAgo(4), remainingCount: 14),\n    RemainingPartyTask(category: .invitations, date: .daysAgo(3), remainingCount: 13),\n    RemainingPartyTask(category: .invitations, date: .daysAgo(2), remainingCount: 11),\n    RemainingPartyTask(category: .invitations, date: .daysAgo(1), remainingCount: 6),\n    RemainingPartyTask(category: .invitations, date: .daysAgo(0), remainingCount: 4),\n]\n\nlet remainingActivities: [RemainingPartyTask] = [\n    RemainingPartyTask(category: .activities, date: .daysAgo(4), remainingCount: 6),\n    RemainingPartyTask(category: .activities, date: .daysAgo(3), remainingCount: 7),\n    RemainingPartyTask(category: .activities, date: .daysAgo(2), remainingCount: 4),\n    RemainingPartyTask(category: .activities, date: .daysAgo(1), remainingCount: 2),\n    RemainingPartyTask(category: .activities, date: .daysAgo(0), remainingCount: 1),\n]\n\nlet remainingVenue: [RemainingPartyTask] = [\n    RemainingPartyTask(category: .eventDetails, date: .daysAgo(4), remainingCount: 4),\n    RemainingPartyTask(category: .eventDetails, date: .daysAgo(3), remainingCount: 5),\n    RemainingPartyTask(category: .eventDetails, date: .daysAgo(2), remainingCount: 7),\n    RemainingPartyTask(category: .eventDetails, date: .daysAgo(1), remainingCount: 4),\n    RemainingPartyTask(category: .eventDetails, date: .daysAgo(0), remainingCount: 2)\n]\n\nlet partyTasksRemaining: [RemainingPartyTask] = [remainingVenue,\n                                                remainingActivities,\n                                                remainingInvitations,\n                                                remainingSupplies\n].flatMap { $0 }\n\n// MARK: Date Utilities\n\nextension Date {\n    static func daysAgo(_ daysAgo: Int) -> Date {\n        Calendar.current.date(byAdding: .day, value: -daysAgo, to: Date())!\n    }\n\n    func daysEqual(_ other: Date) -> Bool {\n        Calendar.current.dateComponents([.day], from: self, to: other).day == 0\n    }\n}\n\nextension Date {\n    static let wwdc22: Date = DateComponents(\n        calendar: .autoupdatingCurrent,\n        timeZone: TimeZone(identifier: \"PST\"),\n        year: 2022,\n        month: 6,\n        day: 6,\n        hour: 9,\n        minute: 41,\n        second: 00).date!\n}"
    },
    {
      "timestamp": "2:56",
      "title": "Swift Charts: Bar Chart 1",
      "language": "swift",
      "code": "Chart(partyTasksRemaining) {\n    BarMark(\n        x: .value(\"Date\", $0.date, unit: .day),\n        y: .value(\"Tasks Remaining\", $0.remainingCount)\n    )\n}\n.padding()"
    },
    {
      "timestamp": "3:33",
      "title": "Swift Charts: Bar chart 2",
      "language": "swift",
      "code": "var body: some View {\n    Chart(partyTasksRemaining) {\n        BarMark(\n            x: .value(\"Date\", $0.date, unit: .day),\n            y: .value(\"Tasks Remaining\", $0.remainingCount)\n        )\n    }\n    .padding()\n}"
    },
    {
      "timestamp": "3:53",
      "title": "Swift Charts: LineMark",
      "language": "swift",
      "code": "var body: some View {\n    Chart(partyTasksRemaining) {\n        LineMark(\n            x: .value(\"Date\", $0.date, unit: .day),\n            y: .value(\"Tasks Remaining\", $0.remainingCount)\n        )\n        .foregroundStyle(by: .value(\"Category\", $0.category))\n    }\n    .padding()\n}"
    },
    {
      "timestamp": "4:08",
      "title": "Swift Charts: Line Chart with Symbols",
      "language": "swift",
      "code": "var body: some View {\n    Chart(partyTasksRemaining) {\n        LineMark(\n            x: .value(\"Date\", $0.date, unit: .day),\n            y: .value(\"Tasks Remaining\", $0.remainingCount)\n        )\n        .foregroundStyle(by: .value(\"Category\", $0.category))\n        .symbol(by: .value(\"Category\", $0.category))\n    }\n    .padding()\n}"
    },
    {
      "timestamp": "4:39",
      "title": "Swift Charts: Annotations",
      "language": "swift",
      "code": "var body: some View {\n    Chart {\n        ForEach(partyTasksRemaining) { task in\n            LineMark(\n                x: .value(\"Date\", task.date, unit: .day),\n                y: .value(\"Tasks Remaining\", task.remainingCount)\n            )\n            .foregroundStyle(by: .value(\"Category\", task.category))\n            .symbol(by: .value(\"Category\", task.category))\n            .annotation(position: .leading) {\n                Text(\"\\(task.category.emoji)\")\n            }\n        }\n\n        RuleMark(y: .value(\"Value\", 5))\n            .foregroundStyle(.red)\n            .lineStyle(StrokeStyle(lineWidth: 2.0, dash: [4, 5]))\n            .annotation(position: .top, alignment: .trailing) {\n                VStack(alignment: .trailing) {\n                    Text(\"Today's Goal\")\n                    Text(\"Status: âœ”ï¸Ž\")\n                }\n                .font(.caption)\n                .foregroundColor(.gray)\n                .padding(.trailing, 2)\n            }\n    }\n}"
    },
    {
      "timestamp": "6:15",
      "title": "Food Models",
      "language": "swift",
      "code": "import Foundation\n\n// MARK: Food Models\n\n/// A model representing a food with a price and quantity.\nstruct FoodItem: Hashable, Identifiable, Codable, Equatable {\n    let emoji: String\n    let name: String\n    var description: String = \"\"\n    let price: Decimal\n    var quantity: Int = 0\n    var id: String { name }\n}\n\nlet donut = FoodItem(emoji: \"ðŸ©\", name: \"Doughnut\", description: \"Yeast, Old-fashioned, Cake, and the dubious Apple Fritter\", price: 2.35, quantity: 6)\nlet moonCake = FoodItem(emoji: \"ðŸ¥®\", name: \"Moon Cake\", description: \"Lotus seed paste â€” plenty of crust\", price: 2.20, quantity: 4)\nlet shavedIce = FoodItem(emoji: \"ðŸ§\", name: \"Shaved Ice\", description: \"Shave your own ice!\", price: 3.25, quantity: 1)\nlet cupcake = FoodItem(emoji: \"ðŸ§\", name: \"Cupcake\", description: \"Also goes by the name Cake Nano\", price: 4.00, quantity: 5)\nlet flan = FoodItem(emoji: \"ðŸ®\", name: \"Flan\", description: \"What's in a flan? That which we call milk, eggs, and sugar by any other name would taste just as sweet.\", price: 6.50, quantity: 2)\nlet taffy = FoodItem(emoji: \"ðŸ¬\", name: \"Taffy\", description: \"Freshwater, actually.\", price: 1.00, quantity: 11)\nlet cake = FoodItem(emoji: \"ðŸŽ‚\", name: \"Cake Cake\", description: \"The real deal\", price: 15.00, quantity: 1)\nlet cookie = FoodItem(emoji: \"ðŸª\", name: \"Cookie Cake\", description: \"The ultimate dessert\", price: 4.30, quantity: 1)\n\nlet relatedFoods = [donut, moonCake, shavedIce, cupcake, flan, taffy, cake, cookie]\n\nextension Array where Element: Equatable {\n\n    /// A quick-and-dirty way of getting a random few elements from an Array that don't include a single,\n    /// particular element.\n    /// - Parameters:\n    ///   - count: The number of desired random elements, must be less than `Array.count`\n    ///   - except: Filter out this particular element    \n    func random(_ count: Int, except: Element) -> [Element] {\n        assert(count >= count)\n        var copy = self\n        copy.shuffle()\n        copy.removeAll(where: { $0 == except })\n        return Array(copy[0..<count])\n    }\n}\n\nlet partyFoods = [\n    FoodItem(emoji: \"ðŸ¨\", name: \"Ice Cream\",\n             price: 3.50, quantity: 4),\n    flan,\n    taffy,\n    donut,\n    FoodItem(emoji: \"ðŸ‰\", name: \"Watermelon\",\n             price: 3.65, quantity: 1),\n    FoodItem(emoji: \"ðŸ’\", name: \"Cherries\",\n             price: 8.00, quantity: 1),\n    cupcake,\n    cookie,\n    FoodItem(emoji: \"ðŸ¥\", name: \"Fish Cake\",\n             price: 5.00, quantity: 2),\n    moonCake,\n    cake,\n    FoodItem(emoji: \"ðŸ˜\", name: \"Rice Cracker\",\n             price: 0.25, quantity: 16),\n    FoodItem(emoji: \"ðŸ¥¨\", name: \"Pretzels\",\n             price: 3.00, quantity: 3),\n    shavedIce,\n    FoodItem(emoji: \"ðŸ¥§\", name: \"Apple Pie\",\n             price: 4.10, quantity: 1)\n]"
    },
    {
      "timestamp": "6:21",
      "title": "NavigationStack with view-based NavigationLinks",
      "language": "swift",
      "code": "// MARK: NavigationStack with View-based NavigationLinks\n\nstruct FoodsListView: View {\n    fileprivate var foodItems = partyFoods\n    @State private var selectedFoodItems: [FoodItem] = []\n\n    var body: some View {\n        NavigationStack {\n            List(foodItems) { item in\n                NavigationLink {\n                    FoodDetailView(item: item)\n                } label: {\n                    FoodRow(food: item)\n                }\n            }\n            .navigationTitle(\"Party Food\")\n\n        }\n    }\n}\n\nstruct FoodRow: View {\n    let food: FoodItem\n\n    var body: some View {\n        HStack {\n            Text(food.emoji)\n                .font(.system(size: 15))\n                .foregroundStyle(.secondary)\n            Text(food.name)\n                .font(.caption)\n                .bold()\n            Spacer()\n            Text(\"\\(food.quantity)\")\n        }\n    }\n}\n\nstruct FoodDetailView: View {\n    let item: FoodItem\n\n    var body: some View {\n        ScrollView {\n            VStack {\n                HStack {\n                    Text(item.emoji)\n                        .font(.system(size: 30))\n                    Text(item.name)\n                        .font(.title3)\n                }\n                .padding(.bottom, 4)\n                Text(item.description)\n                    .font(.caption)\n                Divider()\n                RelatedFoodsView(relatedFoods: relatedFoods.random(3, except: item))\n            }\n        }\n    }\n}\n\nstruct RelatedFoodsView: View {\n    @State var relatedFoods: [FoodItem]\n\n    var body: some View {\n        VStack {\n            Text(\"Related Foods\")\n                .background(.background, in: RoundedRectangle(cornerRadius: 2))\n            HStack {\n                ForEach(relatedFoods) { food in                    \n                    NavigationLink {\n                        FoodDetailView(item: food)\n                    } label: { Text(food.emoji) }\n                }\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "6:51",
      "title": "NavigationStack with value-based NavigationLinks",
      "language": "swift",
      "code": "// MARK: NavigationStack with Value-based Navigation Links\n\nstruct FoodsListView: View {\n    fileprivate var foodItems = partyFoods\n    @State private var selectedFoodItems: [FoodItem] = []\n\n    var body: some View {\n        NavigationStack(path: $selectedFoodItems) {\n            List(foodItems) { item in\n                NavigationLink(value: item) {\n                    FoodRow(food: item)\n                }\n            }\n            .navigationTitle(\"Party Food\")\n            .navigationDestination(for: FoodItem.self) { item in\n                FoodDetailView(item: item, path: $selectedFoodItems)\n            }\n        }\n    }\n}\n\nstruct FoodDetailView: View {\n    let item: FoodItem\n    @Binding var path: [FoodItem]\n\n    var body: some View {\n        ScrollView {\n            VStack {\n                HStack {\n                    Text(item.emoji)\n                        .font(.system(size: 30))\n                    Text(item.name)\n                        .font(.title3)\n                }\n                .padding(.bottom, 4)\n                Text(item.description)\n                    .font(.caption)\n                Divider()\n                RelatedFoodsView(relatedFoods: relatedFoods.random(3, except: item))\n                if path.count > 1 {\n                    Button(\"Back to First Item\") { path.removeSubrange(1...) }\n                }\n            }\n        }\n    }\n}\n\nstruct RelatedFoodsView: View {\n    @State var relatedFoods: [FoodItem]\n\n    var body: some View {\n        VStack {\n            Text(\"Related Foods\")\n                .background(.background, in: RoundedRectangle(cornerRadius: 2))\n            HStack {\n                ForEach(relatedFoods) { food in\n                    NavigationLink(value: food) {\n                        Text(food.emoji)\n                    }\n                }\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "8:16",
      "title": "NavigationSplitView",
      "language": "swift",
      "code": "// MARK: NavigationSplitView Demo\n\nstruct PartyPlannerHome: View {\n    @State private var selectedTask: PartyTask?\n\n    var body: some View {\n        NavigationSplitView {\n            List(PartyTask.allCases, selection: $selectedTask) { task in\n                NavigationLink(value: task) {\n                    TaskLabel(task: task)\n                }\n\t\t\t\t\t\t    .listItemTint(task.color)\n            }\n        } detail: {\n            selectedTask.flatMap { $0.color } ?? .white\n        }\n    }\n}\n\nstruct TaskLabel: View {\n    let task: PartyTask\n\n    var body: some View {\n        Label {\n            VStack(alignment: .leading) {\n                Text(task.name)\n                Text(task.subtitle)\n                    .font(.footnote)\n                    .foregroundStyle(.secondary)\n            }\n        } icon: {\n            Image(systemName: task.imageName)\n                .symbolVariant(.circle.fill)\n        }\n    }\n}"
    },
    {
      "timestamp": "9:13",
      "title": "Navigation split and stack composition",
      "language": "swift",
      "code": "struct PartyPlannerHome: View {\n    @State private var selectedTask: PartyTask?\n\n    var body: some View {\n        NavigationSplitView {\n            List(PartyTask.allCases, selection: $selectedTask) { task in\n                NavigationLink(value: task) {\n                    TaskLabel(task: task)\n                }\n                .listItemTint(task.color)\n            }\n        } detail: {\n            if case .food = selectedTask {\n                FoodsListView()\n            } else {\n                selectedTask.flatMap { $0.color } ?? .white\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "10:10",
      "title": "Window",
      "language": "swift",
      "code": "@main\nstruct PartyPlanner: App {\n    var body: some Scene {\n        WindowGroup(\"Party Planner\") {\n            PartyPlannerHome()\n        }\n\n        Window(\"Party Budget\", id: \"budget\") {\n            Text(\"Budget View\")\n        }\n        .keyboardShortcut(\"0\")\n    }\n}"
    },
    {
      "timestamp": "10:42",
      "title": "Open window",
      "language": "swift",
      "code": "struct DetailView: View {\n    @Environment(\\.openWindow) var openWindow\n\n    var body: some View {\n        Text(\"Detail View\")\n            .toolbar {\n                Button {\n                    openWindow(id: \"budget\")\n                } label: {\n                    Image(systemName: \"dollarsign\")\n                }\n            }\n    }\n}"
    },
    {
      "timestamp": "11:00",
      "title": "Window customizations",
      "language": "swift",
      "code": "@main\nstruct PartyPlanner: App {\n    var body: some Scene {\n        WindowGroup(\"Party Planner\") {\n            PartyPlannerHome()\n        }\n\n        Window(\"Party Budget\", id: \"budget\") {\n            Text(\"Budget View\")\n        }\n        .keyboardShortcut(\"0\")\n        .defaultPosition(.topLeading)\n        .defaultSize(width: 220, height: 250)\n    }\n}"
    },
    {
      "timestamp": "11:47",
      "title": "Resizable sheets",
      "language": "swift",
      "code": "struct PartyPlannerHome: View {\n    @State private var selectedTask: PartyTask?\n    @State private var presented: Bool = false\n\n    var body: some View {\n        NavigationSplitView {\n            List(PartyTask.allCases, selection: $selectedTask) { task in\n                NavigationLink(value: task) {\n                    TaskLabel(task: task)\n                }\n                .listItemTint(task.color)\n            }\n        } detail: {\n            if case .food = selectedTask {\n                FoodsListView()\n            } else {\n                selectedTask.flatMap { $0.color } ?? .white\n            }\n        }\n        .sheet(isPresented: $presented) {\n            Text(\"Budget View\")\n                .presentationDetents([.height(250), .medium])\n                .presentationDragIndicator(.visible)\n        }\n    }\n}"
    },
    {
      "timestamp": "12:51",
      "title": "Menu bar extras",
      "language": "swift",
      "code": "@main\nstruct PartyPlanner: App {\n    var body: some Scene {\n        Window(\"Party Budget\", id: \"budget\") {\n            Text(\"Budget View\")\n        }\n\n        MenuBarExtra(\"Bulletin Board\", systemImage: \"quote.bubble\") {\n            BulletinBoard()\n        }\n        .menuBarExtraStyle(.window)\n    }\n}\n\n\n\nprivate let allPosts: [String] = [\n    \"Did you know: On your third birthday, you are celebrating your 4.0 release.\",\n]\n\nstruct BulletinBoard: View {\n\n    @State var currentPostIndex: Int = 0\n\n    var currentPost: String {\n        allPosts[currentPostIndex]\n    }\n\n    var body: some View {\n        VStack(spacing: 16) {\n\n            VStack(spacing: 12) {\n                HStack(alignment: .firstTextBaseline) {\n                    Text(\"â€œ\")\n                        .font(.custom(\"Helvetica\", size: 50).bold())\n                        .baselineOffset(-23)\n                        .foregroundStyle(.tertiary)\n\n                    Text(\"Party Bulletin Board\")\n                        .font(.headline.weight(.semibold))\n                        .foregroundStyle(.secondary)\n\n                    Spacer()\n\n                    Text(\"June 6, 2022\")\n                        .font(.headline.weight(.regular))\n                        .foregroundStyle(.secondary)\n                }\n                .frame(height: 20)\n\n\n                Text(currentPost)\n                    .font(.system(size: 18))\n                    .multilineTextAlignment(.center)\n            }\n            .padding(.bottom, 4)\n\n            Divider()\n\n            HStack {\n                Button {\n\n                } label: {\n                    Label(\"Calendar\", systemImage: \"calendar\")\n                }\n                Button {\n                    currentPostIndex = (currentPostIndex + 1) % allPosts.count\n                } label: {\n                    Text(\"Previous\")\n                        .frame(maxWidth: .infinity)\n                }\n\n                ShareLink(items: [currentPost])\n            }\n            .labelStyle(.iconOnly)\n            .controlSize(.large)\n        }\n        .padding(16)\n    }\n}"
    },
    {
      "timestamp": "12:58",
      "title": "Menu bar extra app",
      "language": "swift",
      "code": "@main\nstruct MessageBoard: App {\n    var body: some Scene {\n        MenuBarExtra(\"Bulletin Board\", systemImage: \"quote.bubble\") {\n            BulletinBoard()\n        }\n        .menuBarExtraStyle(.window)\n    }\n}"
    },
    {
      "timestamp": "14:25",
      "title": "Grouped forms",
      "language": "swift",
      "code": "struct ContentView: View {\n    enum Theme: String, CaseIterable, Identifiable {\n        var id: String { self.rawValue }\n        case blue, gold, black, white\n\n        var swatch: some View {\n            Circle()\n                .fill(color)\n                .overlay {\n                    Circle().stroke(.tertiary)\n                }\n                .frame(width: 15, height: 15)\n        }\n\n        var color: Color {\n            switch self {\n            case .blue: return .blue\n            case .gold: return .yellow\n            case .black: return .black\n            case .white: return .white\n            }\n        }\n    }\n\n    enum ColorScheme: String {\n        case light, dark\n    }\n\n    enum Decoration: String, CaseIterable {\n        case balloon, confetti, inflatables, noisemakers, all, none\n    }\n\n    private let address = \"One Apple Park Way\"\n\n    @State private var date: Date = DateComponents(\n        calendar: .current, timeZone: .current, year: 2022, month: 6, day: 6\n    ).date!\n    @State private var eventDescription: String =\n        \"Come and join us celebrate SwiftUI's birthday party!\\nðŸŽ‰ðŸŽ‚\"\n\n    @State private var scheme: ColorScheme = .light\n    @State private var accent: Theme = .blue\n    @State private var extraGuests = false\n    @State private var spacesCount: Float = 2\n\n    @State private var includeBalloons = false\n    @State private var includeConfetti = false\n    @State private var includeInflatables = false\n    @State private var includeBlowers = false\n\n    @State private var selectedDecorations: [Decoration] = []\n    @State private var decorationThemes: [Decoration: Theme] = [\n        .balloon : .blue,\n        .confetti: .gold,\n        .inflatables: .black,\n        .noisemakers: .white,\n        .none: .black\n    ]\n\n    private var themes: [Binding<Theme>] {\n        if selectedDecorations.count == 0 {\n            return [Binding($decorationThemes[.none])!]\n        }\n        return selectedDecorations.compactMap {\n            Binding($decorationThemes[$0])\n        }\n    }\n\n    var body: some View {\n        Form {\n            Section {\n                LabeledContent(\"Location\", value: address)\n                DatePicker(\"Date\", selection: $date)\n                TextField(\"Description\", text: $eventDescription, axis: .vertical)\n                    .lineLimit(3, reservesSpace: true)\n            }\n\n            Section(\"Vibe\") {\n                Picker(\"Accent color\", selection: $accent) {\n                    ForEach(Theme.allCases) { theme in\n                        Text(theme.rawValue.capitalized).tag(theme)\n                    }\n                }\n                Picker(\"Color scheme\", selection: $scheme) {\n                    Text(\"Light\").tag(ColorScheme.light)\n                    Text(\"Dark\").tag(ColorScheme.dark)\n                }\n                #if os(macOS)\n                .pickerStyle(.inline)\n                #endif\n                Toggle(isOn: $extraGuests) {\n                    Text(\"Allow extra guests\")\n                    Text(\"The more the merrier!\")\n                }\n                if extraGuests {\n                    Stepper(\"Guests limit\", value: $spacesCount, format: .number)\n                }\n            }\n\n            Section(\"Decorations\") {\n                Section {\n                    List(selection: $selectedDecorations) {\n                        DisclosureGroup {\n                            HStack {\n                                Toggle(\"Balloons ðŸŽˆ\", isOn: $includeBalloons)\n                                Spacer()\n                                decorationThemes[.balloon].map { $0.swatch }\n                            }\n                            .tag(Decoration.balloon)\n\n                            HStack {\n                                Toggle(\"Confetti ðŸŽŠ\", isOn: $includeConfetti)\n                                Spacer()\n                                decorationThemes[.confetti].map { $0.swatch }\n                            }\n                            .tag(Decoration.confetti)\n\n                            HStack {\n                                Toggle(\"Inflatables ðŸª…\", isOn: $includeInflatables)\n                                Spacer()\n                                decorationThemes[.inflatables].map { $0.swatch }\n                            }\n                            .tag(Decoration.inflatables)\n\n                            HStack {\n                                Toggle(\"Party Horns ðŸ¥³\", isOn: $includeBlowers)\n                                Spacer()\n                                decorationThemes[.noisemakers].map { $0.swatch }\n                            }\n                            .tag(Decoration.noisemakers)\n                        } label: {\n                            Toggle(\"All Decorations\", isOn: [\n                                $includeBalloons, $includeConfetti,\n                                $includeInflatables, $includeBlowers\n                            ])\n                            .tag(Decoration.all)\n                        }\n                        #if os(macOS)\n                        .toggleStyle(.checkbox)\n                        #endif\n                    }\n\n                    Picker(\"Decoration theme\", selection: themes) {\n                        Text(\"Blue\").tag(Theme.blue)\n                        Text(\"Black\").tag(Theme.black)\n                        Text(\"Gold\").tag(Theme.gold)\n                        Text(\"White\").tag(Theme.white)\n                    }\n                    #if os(macOS)\n                    .pickerStyle(.radioGroup)\n                    #endif\n                }\n            }\n\n        }\n        .formStyle(.grouped)\n    }\n}"
    },
    {
      "timestamp": "15:45",
      "title": "Grouped forms with LabeledContent wrapping a view.",
      "language": "swift",
      "code": "struct ContentView: View {\n    enum Theme: String, CaseIterable, Identifiable {\n        var id: String { self.rawValue }\n        case blue, gold, black, white\n\n        var swatch: some View {\n            Circle()\n                .fill(color)\n                .overlay {\n                    Circle().stroke(.tertiary)\n                }\n                .frame(width: 15, height: 15)\n        }\n\n        var color: Color {\n            switch self {\n            case .blue: return .blue\n            case .gold: return .yellow\n            case .black: return .black\n            case .white: return .white\n            }\n        }\n    }\n\n    enum ColorScheme: String {\n        case light, dark\n    }\n\n    enum Decoration: String, CaseIterable {\n        case balloon, confetti, inflatables, noisemakers, all, none\n    }\n\n    private let location = Location(\n        firstLine: \"One Apple Park Way\", secondLine: \"Cupertino, CA 95014\")\n\n    @State private var date: Date = DateComponents(\n        calendar: .current, timeZone: .current, year: 2022, month: 6, day: 6\n    ).date!\n    @State private var eventDescription: String =\n        \"Come and join us celebrate SwiftUI's birthday party!\\nðŸŽ‰ðŸŽ‚\"\n\n    @State private var scheme: ColorScheme = .light\n    @State private var accent: Theme = .blue\n    @State private var extraGuests = false\n    @State private var spacesCount: Float = 2\n\n    @State private var includeBalloons = false\n    @State private var includeConfetti = false\n    @State private var includeInflatables = false\n    @State private var includeBlowers = false\n\n    @State private var selectedDecorations: [Decoration] = []\n    @State private var decorationThemes: [Decoration: Theme] = [\n        .balloon : .blue,\n        .confetti: .gold,\n        .inflatables: .black,\n        .noisemakers: .white,\n        .none: .black\n    ]\n\n    private var themes: [Binding<Theme>] {\n        if selectedDecorations.count == 0 {\n            return [Binding($decorationThemes[.none])!]\n        }\n        return selectedDecorations.compactMap {\n            Binding($decorationThemes[$0])\n        }\n    }\n\n    var body: some View {\n        Form {\n            Section {\n                LabeledContent(\"Location\") {\n                    AddressView(location)\n                }\n                DatePicker(\"Date\", selection: $date)\n                TextField(\"Description\", text: $eventDescription, axis: .vertical)\n                    .lineLimit(3, reservesSpace: true)\n            }\n\n            Section(\"Vibe\") {\n                Picker(\"Accent color\", selection: $accent) {\n                    ForEach(Theme.allCases) { accent in\n                        Text(accent.rawValue.capitalized).tag(accent)\n                    }\n                }\n                Picker(\"Color scheme\", selection: $scheme) {\n                    Text(\"Light\").tag(ColorScheme.light)\n                    Text(\"Dark\").tag(ColorScheme.dark)\n                }\n                #if os(macOS)\n                .pickerStyle(.inline)\n                #endif\n                Toggle(isOn: $extraGuests) {\n                    Text(\"Allow extra guests\")\n                    Text(\"The more the merrier!\")\n                }\n                if extraGuests {\n                    Stepper(\"Guests limit\", value: $spacesCount, format: .number)\n                }\n            }\n\n            Section(\"Decorations\") {\n                Section {\n                    List(selection: $selectedDecorations) {\n                        DisclosureGroup {\n                            HStack {\n                                Toggle(\"Balloons ðŸŽˆ\", isOn: $includeBalloons)\n                                Spacer()\n                                decorationThemes[.balloon].map { $0.swatch }\n                            }\n                            .tag(Decoration.balloon)\n\n                            HStack {\n                                Toggle(\"Confetti ðŸŽŠ\", isOn: $includeConfetti)\n                                Spacer()\n                                decorationThemes[.confetti].map { $0.swatch }\n                            }\n                            .tag(Decoration.confetti)\n\n                            HStack {\n                                Toggle(\"Inflatables ðŸª…\", isOn: $includeInflatables)\n                                Spacer()\n                                decorationThemes[.inflatables].map { $0.swatch }\n                            }\n                            .tag(Decoration.inflatables)\n\n                            HStack {\n                                Toggle(\"Party Horns ðŸ¥³\", isOn: $includeBlowers)\n                                Spacer()\n                                decorationThemes[.noisemakers].map { $0.swatch }\n                            }\n                            .tag(Decoration.noisemakers)\n                        } label: {\n                            Toggle(\"All Decorations\", isOn: [\n                                $includeBalloons, $includeConfetti,\n                                $includeInflatables, $includeBlowers\n                            ])\n                            .tag(Decoration.all)\n                        }\n                        #if os(macOS)\n                        .toggleStyle(.checkbox)\n                        #endif\n                    }\n\n                    Picker(\"Decoration theme\", selection: themes) {\n                        Text(\"Blue\").tag(Theme.blue)\n                        Text(\"Black\").tag(Theme.black)\n                        Text(\"Gold\").tag(Theme.gold)\n                        Text(\"White\").tag(Theme.white)\n                    }\n                    #if os(macOS)\n                    .pickerStyle(.radioGroup)\n                    #endif\n                }\n            }\n\n        }\n        .formStyle(.grouped)\n    }\n}\n\n\nstruct AddressView: View {\n    private let location: Location\n\n    init(_ location: Location) {\n        self.location = location\n    }\n\n    var body: some View {\n        VStack {\n            Text(location.firstLine)\n            Text(location.secondLine)\n        }\n    }\n}\n\nstruct Location {\n    let firstLine: String\n    let secondLine: String\n}"
    },
    {
      "timestamp": "17:06",
      "title": "Multiline text fields",
      "language": "swift",
      "code": "struct ContentView: View {\n    @State private var activityDates: Set<DateComponents> = [\n        DateComponents(calendar: .current, year: 2022, month: 6, day: 6),\n        DateComponents(calendar: .current, year: 2022, month: 6, day: 9),\n        DateComponents(calendar: .current, year: 2022, month: 6, day: 10)\n    ]\n    @State private var title: String = .init()\n    @State private var description: String = \"\"\"\n                Join us, and let's force unwrap SwiftUl's\n                birthday presents. Note that although\n                this activity is optional, we may have\n                guards at the entry.\n                \"\"\"\n\n    var body: some View {\n        NavigationStack {\n            Form {\n                Section {\n                    TextField(\"Title\", text: $title)\n                    TextField(\"Description\", text: $description, axis: .vertical)\n                }\n                Section(\"Dates\") {\n                    MultiDatePicker(\"Activities Dates\", selection: $activityDates)\n                }\n            }\n            .navigationTitle(\"New Activity\")\n            .toolbar {\n                Button(\"Save\") {}\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "17:20",
      "title": "Multiline text fields with line limit",
      "language": "swift",
      "code": "struct ContentView: View {\n    @State private var activityDates: Set<DateComponents> = [\n        DateComponents(calendar: .current, year: 2022, month: 6, day: 6),\n        DateComponents(calendar: .current, year: 2022, month: 6, day: 9),\n        DateComponents(calendar: .current, year: 2022, month: 6, day: 10)\n    ]\n    @State private var title: String = .init()\n    @State private var description: String = \"\"\"\n                Join us, and let's force unwrap SwiftUl's\n                birthday presents. Note that although\n                this activity is optional, we may have\n                guards at the entry.\n                \"\"\"\n\n    var body: some View {\n        NavigationStack {\n            Form {\n                Section {\n                    TextField(\"Title\", text: $title)\n                    TextField(\"Description\", text: $description, axis: .vertical)\n                  \t\t.lineLimit(5)\n                }\n                Section(\"Dates\") {\n                    MultiDatePicker(\"Activities Dates\", selection: $activityDates)\n                }\n            }\n            .navigationTitle(\"New Activity\")\n            .toolbar {\n                Button(\"Save\") {}\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "17:23",
      "title": "Multiline text fields with line limit range",
      "language": "swift",
      "code": "struct ContentView: View {\n    @State private var activityDates: Set<DateComponents> = [\n        DateComponents(calendar: .current, year: 2022, month: 6, day: 6),\n        DateComponents(calendar: .current, year: 2022, month: 6, day: 9),\n        DateComponents(calendar: .current, year: 2022, month: 6, day: 10)\n    ]\n    @State private var title: String = .init()\n    @State private var description: String = \"\"\"\n                Join us, and let's force unwrap SwiftUl's\n                birthday presents. Note that although\n                this activity is optional, we may have\n                guards at the entry.\n                \"\"\"\n\n    var body: some View {\n        NavigationStack {\n            Form {\n                Section {\n                    TextField(\"Title\", text: $title)\n                    TextField(\"Description\", text: $description, axis: .vertical)\n                  \t\t.lineLimit(5...10)\n                }\n                Section(\"Dates\") {\n                    MultiDatePicker(\"Activities Dates\", selection: $activityDates)\n                }\n            }\n            .navigationTitle(\"New Activity\")\n            .toolbar {\n                Button(\"Save\") {}\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "18:53",
      "title": "ButtonStyle composition & Steppers",
      "language": "swift",
      "code": "struct ContentView: View {\n    enum Theme: String, CaseIterable, Identifiable {\n        var id: String { self.rawValue }\n        case blue, gold, black, white\n\n        var swatch: some View {\n            Circle()\n                .fill(color)\n                .overlay {\n                    Circle().stroke(.tertiary)\n                }\n                .frame(width: 15, height: 15)\n        }\n\n        var color: Color {\n            switch self {\n            case .blue: return .blue\n            case .gold: return .yellow\n            case .black: return .black\n            case .white: return .white\n            }\n        }\n    }\n\n    enum ColorScheme: String {\n        case light, dark\n    }\n\n    enum Decoration: String, CaseIterable {\n        case balloon, confetti, inflatables, noisemakers, all, none\n    }\n\n    private let location = Location(\n        firstLine: \"One Apple Park Way\", secondLine: \"Cupertino, CA 95014\")\n\n    @State private var date: Date = DateComponents(\n        calendar: .current, timeZone: .current, year: 2022, month: 6, day: 6\n    ).date!\n    @State private var eventDescription: String =\n        \"Come and join us celebrate SwiftUI's birthday party!\\nðŸŽ‰ðŸŽ‚\"\n\n    @State private var scheme: ColorScheme = .light\n    @State private var accent: Theme = .blue\n    @State private var extraGuests = false\n    @State private var spacesCount: Float = 2\n\n    @State private var includeBalloons = false\n    @State private var includeConfetti = false\n    @State private var includeInflatables = false\n    @State private var includeBlowers = false\n\n    @State private var swiftastic = false\n    @State private var wwdcParty = true\n    @State private var offTheCharts = true\n    @State private var oneMoreThing = false\n\n    @State private var selectedDecorations: [Decoration] = []\n    @State private var decorationThemes: [Decoration: Theme] = [\n        .balloon : .blue,\n        .confetti: .gold,\n        .inflatables: .black,\n        .noisemakers: .white,\n        .none: .black\n    ]\n\n    private var themes: [Binding<Theme>] {\n        if selectedDecorations.count == 0 {\n            return [Binding($decorationThemes[.none])!]\n        }\n        return selectedDecorations.compactMap {\n            Binding($decorationThemes[$0])\n        }\n    }\n\n    var body: some View {\n        Form {\n            Section {\n                LabeledContent(\"Location\") {\n                    AddressView(location)\n                }\n                DatePicker(\"Date\", selection: $date)\n                TextField(\"Description\", text: $eventDescription, axis: .vertical)\n                    .lineLimit(3, reservesSpace: true)\n            }\n\n            Section(\"Vibe\") {\n                Picker(\"Accent color\", selection: $accent) {\n                    ForEach(Theme.allCases) { accent in\n                        Text(accent.rawValue.capitalized).tag(accent)\n                    }\n                }\n                Picker(\"Color scheme\", selection: $scheme) {\n                    Text(\"Light\").tag(ColorScheme.light)\n                    Text(\"Dark\").tag(ColorScheme.dark)\n                }\n                #if os(macOS)\n                .pickerStyle(.inline)\n                #endif\n                Toggle(isOn: $extraGuests) {\n                    Text(\"Allow extra guests\")\n                    Text(\"The more the merrier!\")\n                }\n                if extraGuests {\n                    Stepper(\"Guests limit\", value: $spacesCount, format: .number)\n                }\n            }\n\n            Section(\"Decorations\") {\n                Section {\n                    List {\n                        DisclosureGroup {\n                            HStack {\n                                Toggle(\"Balloons ðŸŽˆ\", isOn: $includeBalloons)\n                                Spacer()\n                                decorationThemes[.balloon].map { $0.swatch }\n                            }\n                            .tag(Decoration.balloon)\n\n                            HStack {\n                                Toggle(\"Confetti ðŸŽŠ\", isOn: $includeConfetti)\n                                Spacer()\n                                decorationThemes[.confetti].map { $0.swatch }\n                            }\n                            .tag(Decoration.confetti)\n\n                            HStack {\n                                Toggle(\"Inflatables ðŸª…\", isOn: $includeInflatables)\n                                Spacer()\n                                decorationThemes[.inflatables].map { $0.swatch }\n                            }\n                            .tag(Decoration.inflatables)\n\n                            HStack {\n                                Toggle(\"Party Horns ðŸ¥³\", isOn: $includeBlowers)\n                                Spacer()\n                                decorationThemes[.noisemakers].map { $0.swatch }\n                            }\n                            .tag(Decoration.noisemakers)\n                        } label: {\n                            Toggle(\"All Decorations\", isOn: [\n                                $includeBalloons, $includeConfetti,\n                                $includeInflatables, $includeBlowers\n                            ])\n                            .tag(Decoration.all)\n                        }\n                        #if os(macOS)\n                        .toggleStyle(.checkbox)\n                        #endif\n                    }\n\n                    Picker(\"Decoration theme\", selection: themes) {\n                        Text(\"Blue\").tag(Theme.blue)\n                        Text(\"Black\").tag(Theme.black)\n                        Text(\"Gold\").tag(Theme.gold)\n                        Text(\"White\").tag(Theme.white)\n                    }\n                    #if os(macOS)\n                    .pickerStyle(.radioGroup)\n                    #endif\n                }\n            }\n\n            Section(\"Hashtags\") {\n                VStack(alignment: .leading) {\n                    HStack {\n                        Toggle(\"#Swiftastic\", isOn: $swiftastic)\n                        Toggle(\"#WWParty\", isOn: $wwdcParty)\n                    }\n                    HStack {\n                        Toggle(\"#OffTheCharts\", isOn: $offTheCharts)\n                        Toggle(\"#OneMoreThing\", isOn: $oneMoreThing)\n                    }\n                }\n                .toggleStyle(.button)\n                .buttonStyle(.bordered)\n            }\n\n        }\n        .formStyle(.grouped)\n    }\n}\n\nstruct AddressView: View {\n    private let location: Location\n\n    init(_ location: Location) {\n        self.location = location\n    }\n\n    var body: some View {\n        VStack {\n            Text(location.firstLine)\n            Text(location.secondLine)\n        }\n    }\n}\n\nstruct Location {\n    let firstLine: String\n    let secondLine: String\n}"
    },
    {
      "timestamp": "19:33",
      "title": "Accessibility Quick Actions",
      "language": "swift",
      "code": "struct ContentView: View {\n    @State private var isInCart: Bool = false\n\n    var body: some View {\n        VStack(alignment: .leading) {\n            ItemDescriptionView()\n            addToCartButton\n        }\n        .accessibilityQuickAction(style: .prompt) {\n            addToCartButton\n        }\n    }\n\n    var addToCartButton: some View {\n        Button(isInCart ? \"Remove from cart\" : \"Add to cart\") {\n            isInCart.toggle()\n        }\n    }\n}\n\nstruct ItemDescriptionView: View {\n    var body: some View {\n        ScrollView {\n            VStack {\n                HStack {\n                    Text(\"ðŸŽˆ\")\n                        .font(.title2)\n                    Text(\"Balloons\")\n                        .font(.title3)\n                    Spacer()\n                }\n                .padding(.bottom, 4)\n                Text(\n                    \"\"\"\n                    This is perhaps our funniest product! It is made up of a\n                    rubber fabric and comes in various unique colors.\n                    \"\"\")\n                .font(.caption)\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "20:20",
      "title": "Tables on iPadOS",
      "language": "swift",
      "code": "struct ContentView: View {\n    @StateObject private var attendeeStore = AttendeeStore()\n    var body: some View {\n        NavigationStack {\n            Table(attendeeStore.attendees) {\n                TableColumn(\"Name\") { attendee in\n                    AttendeeRow(attendee)\n                }\n                TableColumn(\"City\", value: \\.city)\n                TableColumn(\"Status\") { attendee in\n                    StatusRow(attendee)\n                }\n            }\n            .navigationTitle(\"Invitations\")\n            .toolbar(id: \"toolbar\") {\n                ToolbarItem(id: \"new\", placement: .secondaryAction) {\n                    Button(action: {}) {\n                        Label(\"New Invitation\", systemImage: \"envelope\")\n                    }\n                }\n                ToolbarItem(id: \"edit\", placement: .secondaryAction) {\n                    Button(action: {}) {\n                        Label(\"Edit\", systemImage: \"pencil.circle\")\n                    }\n                }\n                ToolbarItem(id: \"share\", placement: .secondaryAction) {\n                    Button(action: {}) {\n                        Label(\"Share\", systemImage: \"square.and.arrow.up\")\n                    }\n                }\n                ToolbarItem(id: \"tag\", placement: .secondaryAction) {\n                    Button(action: {}) {\n                        Label(\"Tags\", systemImage: \"tag\")\n                    }\n                }\n                ToolbarItem(\n                    id: \"reminder\", placement: .secondaryAction, showsByDefault: false\n                ) {\n                    Button(action: {}) {\n                        Label(\"Set reminder\", systemImage: \"bell\")\n                    }\n                }\n            }\n            .toolbarRole(.editor)\n        }\n    }\n}\n\nclass AttendeeStore: ObservableObject {\n    @Published var attendees: [Attendee] = [/* Default attendees */]\n}\n\n\nstruct Attendee: Identifiable, Hashable {\n    enum Status: String {\n        case accepted, declined, maybe\n\n        func displayText() -> Text {\n            switch self {\n            case .accepted: return Text(\n                \"Accepted \\(Image(systemName: \"person.crop.circle.badge.checkmark\"))\")\n            case .maybe: return Text(\n                \"Maybe \\(Image(systemName: \"person.crop.circle.badge.questionmark\"))\")\n            case .declined: return Text(\n                \"Declined \\(Image(systemName: \"person.crop.circle.badge.minus\"))\")\n            }\n        }\n    }\n    \n    let id = UUID()\n    let memojiName: String\n    let name: String\n    let city: String\n    let status: Status\n\n    init(memojiName: String, name: String, cities: String, status: Status) {\n        self.memojiName = memojiName\n        self.name = name\n        self.city = cities\n        self.status = status\n    }\n}\n\nstruct AttendeeRow: View {\n    let attendee: Attendee\n\n    init(_ attendee: Attendee) {\n        self.attendee = attendee\n    }\n\n    var body: some View {\n        HStack {\n            Image(attendee.memojiName)\n                .resizable()\n                .aspectRatio(contentMode: .fill)\n                #if os(macOS)\n                .frame(width: 20, height: 20)\n                .overlay {\n                    Circle()\n                        .stroke(Color.gray.opacity(0.2), lineWidth: 1)\n                }\n                #else\n                .frame(width: 32, height: 32)\n                .overlay {\n                    RoundedRectangle(cornerRadius: 6)\n                        .stroke(Color.gray.opacity(0.2), lineWidth: 1)\n                }\n                #endif\n            Text(attendee.name)\n        }\n    }\n}\n\nstruct StatusRow: View {\n    let attendee: Attendee\n    init(_ attendee: Attendee) {\n        self.attendee = attendee\n    }\n\n    var body: some View {\n        attendee.status.displayText()\n            .symbolVariant(.fill)\n            .symbolRenderingMode(.multicolor)\n    }\n}"
    },
    {
      "timestamp": "21:12",
      "title": "Context Menu",
      "language": "swift",
      "code": "struct ContentView: View {\n    @StateObject private var attendeeStore = AttendeeStore()\n    @State private var selection = Set<Attendee.ID>()\n\n    var body: some View {\n        NavigationStack {\n            Table(attendeeStore.attendees, selection: $selection) {\n                TableColumn(\"Name\") { attendee in\n                    AttendeeRow(attendee)\n                }\n                TableColumn(\"City\", value: \\.city)\n                TableColumn(\"Status\") { attendee in\n                    StatusRow(attendee)\n                }\n            }\n            .navigationTitle(\"Invitations\")\n            #if os(macOS)\n            .contextMenu(forSelectionType: Attendee.ID.self) { selection in\n                if selection.isEmpty {\n                    Button(\"New Invitation\") { addInvitation() }\n                } else if selection.count == 1 {\n                    Button(\"Mark as VIP\") { markVIPs(selection) }\n                } else {\n                    Button(\"Mark as VIPs\") { markVIPs(selection) }\n                }\n            }\n            #endif\n            .toolbar(id: \"toolbar\") {\n                ToolbarItem(id: \"new\", placement: .secondaryAction) {\n                    Button(action: {}) {\n                        Label(\"New Invitation\", systemImage: \"envelope\")\n                    }\n                }\n                ToolbarItem(id: \"edit\", placement: .secondaryAction) {\n                    Button(action: {}) {\n                        Label(\"Edit\", systemImage: \"pencil.circle\")\n                    }\n                }\n                ToolbarItem(id: \"share\", placement: .secondaryAction) {\n                    Button(action: {}) {\n                        Label(\"Share\", systemImage: \"square.and.arrow.up\")\n                    }\n                }\n                ToolbarItem(id: \"tag\", placement: .secondaryAction) {\n                    Button(action: {}) {\n                        Label(\"Tags\", systemImage: \"tag\")\n                    }\n                }\n                ToolbarItem(\n                    id: \"reminder\", placement: .secondaryAction, showsByDefault: false\n                ) {\n                    Button(action: {}) {\n                        Label(\"Set reminder\", systemImage: \"bell\")\n                    }\n                }\n            }\n            .toolbarRole(.editor)\n        }\n    }\n\n    private func addInvitation() {}\n\n    private func markVIPs(_ items: Set<String>) {}\n}\n\n\nclass AttendeeStore: ObservableObject {\n    @Published var attendees: [Attendee] = [/* Default attendees */]\n}\n\n\nstruct Attendee: Identifiable, Hashable {\n    enum Status: String {\n        case accepted, declined, maybe\n\n        func displayText() -> Text {\n            switch self {\n            case .accepted: return Text(\n                \"Accepted \\(Image(systemName: \"person.crop.circle.badge.checkmark\"))\")\n            case .maybe: return Text(\n                \"Maybe \\(Image(systemName: \"person.crop.circle.badge.questionmark\"))\")\n            case .declined: return Text(\n                \"Declined \\(Image(systemName: \"person.crop.circle.badge.minus\"))\")\n            }\n        }\n    }\n\n    let id = UUID()\n    let memojiName: String\n    let name: String\n    let city: String\n    let status: Status\n\n    init(memojiName: String, name: String, cities: String, status: Status) {\n        self.memojiName = memojiName\n        self.name = name\n        self.city = cities\n        self.status = status\n    }\n}\n\nstruct AttendeeRow: View {\n    let attendee: Attendee\n\n    init(_ attendee: Attendee) {\n        self.attendee = attendee\n    }\n\n    var body: some View {\n        HStack {\n            Image(attendee.memojiName)\n                .resizable()\n                .aspectRatio(contentMode: .fill)\n                #if os(macOS)\n                .frame(width: 20, height: 20)\n                .overlay {\n                    Circle()\n                        .stroke(Color.gray.opacity(0.2), lineWidth: 1)\n                }\n                #else\n                .frame(width: 32, height: 32)\n                .overlay {\n                    RoundedRectangle(cornerRadius: 6)\n                        .stroke(Color.gray.opacity(0.2), lineWidth: 1)\n                }\n                #endif\n            Text(attendee.name)\n        }\n    }\n}\n\nstruct StatusRow: View {\n    let attendee: Attendee\n    init(_ attendee: Attendee) {\n        self.attendee = attendee\n    }\n\n    var body: some View {\n        attendee.status.displayText()\n            .symbolVariant(.fill)\n            .symbolRenderingMode(.multicolor)\n    }\n}"
    },
    {
      "timestamp": "23:17",
      "title": "Search Tokens",
      "language": "swift",
      "code": "struct ContentView: View {\n    public struct AttendeeToken: Identifiable, Equatable, Hashable {\n        enum Guts {\n            case name\n            case location\n            case status\n        }\n\n        let guts: Guts\n        var query: String = .init()\n\n        var id: String {\n            self.systemImage\n        }\n\n        static let allCases: [AttendeeToken] = [.name, .location, .status]\n\n        mutating func displayName(_ query: String) -> String {\n            self.query = query\n            switch guts {\n            case .name: return \"Name contains: \\(query)\"\n            case .location: return \"City contains: \\(query)\"\n            case .status: return \"Status contains: \\(query)\"\n            }\n        }\n\n        var systemImage: String {\n            switch guts {\n            case .name: return \"person\"\n            case .location: return \"location.square\"\n            case .status: return \"person.crop.circle.badge\"\n            }\n        }\n\n        static let name: AttendeeToken = .init(guts: .name)\n        static let location: AttendeeToken = .init(guts: .location)\n        static let status: AttendeeToken = .init(guts: .status)\n    }\n\n    @StateObject private var attendeeStore = AttendeeStore()\n    @State private var selection = Set<Attendee.ID>()\n\n    @State private var tokens: [AttendeeToken] = .init()\n    @State private var query: String = .init()\n\n    var body: some View {\n        NavigationStack {\n            Table(attendeeStore.attendees, selection: $selection) {\n                TableColumn(\"Name\") { attendee in\n                    AttendeeRow(attendee)\n                }\n                TableColumn(\"City\", value: \\.city)\n                TableColumn(\"Status\") { attendee in\n                    StatusRow(attendee)\n                }\n            }\n            .navigationTitle(\"Invitations\")\n            #if os(macOS)\n            .contextMenu(forSelectionType: Attendee.ID.self) { selection in\n                if selection.isEmpty {\n                    Button(\"New Invitation\") { addInvitation() }\n                } else if selection.count == 1 {\n                    Button(\"Mark as VIP\") { markVIPs(selection) }\n                } else {\n                    Button(\"Mark as VIPs\") { markVIPs(selection) }\n                }\n            }\n            #endif\n            .searchable(text: $query, tokens: $tokens) { token in\n                Label(token.query, systemImage: token.systemImage)\n            } suggestions: {\n                suggestions\n            }\n            .toolbar(id: \"toolbar\") {\n                ToolbarItem(id: \"new\", placement: .secondaryAction) {\n                    Button(action: {}) {\n                        Label(\"New Invitation\", systemImage: \"envelope\")\n                    }\n                }\n                ToolbarItem(id: \"edit\", placement: .secondaryAction) {\n                    Button(action: {}) {\n                        Label(\"Edit\", systemImage: \"pencil.circle\")\n                    }\n                }\n                ToolbarItem(id: \"share\", placement: .secondaryAction) {\n                    Button(action: {}) {\n                        Label(\"Share\", systemImage: \"square.and.arrow.up\")\n                    }\n                }\n                ToolbarItem(id: \"tag\", placement: .secondaryAction) {\n                    Button(action: {}) {\n                        Label(\"Tags\", systemImage: \"tag\")\n                    }\n                }\n                ToolbarItem(\n                    id: \"reminder\", placement: .secondaryAction, showsByDefault: false\n                ) {\n                    Button(action: {}) {\n                        Label(\"Set reminder\", systemImage: \"bell\")\n                    }\n                }\n            }\n            .toolbarRole(.editor)\n        }\n    }\n\n    @ViewBuilder\n    private var suggestions: some View {\n        ForEach(attendeeStore.attendees) {\n            Text($0.name)\n                .foregroundColor(.black)\n        }\n\n        if !query.isEmpty {\n            ForEach(AttendeeToken.allCases) { token in\n                var _token = token\n                Label(_token.displayName(query), systemImage: _token.systemImage)\n                    .searchCompletion(_token)\n            }\n        }\n    }\n\n    private func addInvitation() {}\n\n    private func markVIPs(_ items: Set<String>) {}\n}\n\nclass AttendeeStore: ObservableObject {\n    @Published var attendees: [Attendee] = [/* Default attendees */]\n}\n\nstruct Attendee: Identifiable, Hashable {\n    enum Status: String {\n        case accepted, declined, maybe\n\n        func displayText() -> Text {\n            switch self {\n            case .accepted: return Text(\n                \"Accepted \\(Image(systemName: \"person.crop.circle.badge.checkmark\"))\")\n            case .maybe: return Text(\n                \"Maybe \\(Image(systemName: \"person.crop.circle.badge.questionmark\"))\")\n            case .declined: return Text(\n                \"Declined \\(Image(systemName: \"person.crop.circle.badge.minus\"))\")\n            }\n        }\n    }\n\n    let id = UUID()\n    let memojiName: String\n    let name: String\n    let city: String\n    let status: Status\n\n    init(memojiName: String, name: String, cities: String, status: Status) {\n        self.memojiName = memojiName\n        self.name = name\n        self.city = cities\n        self.status = status\n    }\n}\n\nstruct AttendeeRow: View {\n    let attendee: Attendee\n\n    init(_ attendee: Attendee) {\n        self.attendee = attendee\n    }\n\n    var body: some View {\n        HStack {\n            Image(attendee.memojiName)\n                .resizable()\n                .aspectRatio(contentMode: .fill)\n                #if os(macOS)\n                .frame(width: 20, height: 20)\n                .overlay {\n                    Circle()\n                        .stroke(Color.gray.opacity(0.2), lineWidth: 1)\n                }\n                #else\n                .frame(width: 32, height: 32)\n                .overlay {\n                    RoundedRectangle(cornerRadius: 6)\n                        .stroke(Color.gray.opacity(0.2), lineWidth: 1)\n                }\n                #endif\n            Text(attendee.name)\n        }\n    }\n}\n\nstruct StatusRow: View {\n    let attendee: Attendee\n    init(_ attendee: Attendee) {\n        self.attendee = attendee\n    }\n\n    var body: some View {\n        attendee.status.displayText()\n            .symbolVariant(.fill)\n            .symbolRenderingMode(.multicolor)\n    }\n}"
    },
    {
      "timestamp": "23:28",
      "title": "Search scopes",
      "language": "swift",
      "code": "struct ContentView: View {\n    enum AttendanceScope {\n        case inPerson\n        case online\n    }\n\n    public struct AttendeeToken: Identifiable, Equatable, Hashable {\n        enum Guts {\n            case name\n            case location\n            case status\n        }\n\n        let guts: Guts\n        var query: String = .init()\n\n        var id: String {\n            self.systemImage\n        }\n\n        static let allCases: [AttendeeToken] = [.name, .location, .status]\n\n        mutating func displayName(_ query: String) -> String {\n            self.query = query\n            switch guts {\n            case .name: return \"Name contains: \\(query)\"\n            case .location: return \"City contains: \\(query)\"\n            case .status: return \"Status contains: \\(query)\"\n            }\n        }\n\n        var systemImage: String {\n            switch guts {\n            case .name: return \"person\"\n            case .location: return \"location.square\"\n            case .status: return \"person.crop.circle.badge\"\n            }\n        }\n\n        static let name: AttendeeToken = .init(guts: .name)\n        static let location: AttendeeToken = .init(guts: .location)\n        static let status: AttendeeToken = .init(guts: .status)\n    }\n\n    @StateObject private var attendeeStore = AttendeeStore()\n    @State private var selection = Set<Attendee.ID>()\n\n    @State private var tokens: [AttendeeToken] = .init()\n    @State private var query: String = .init()\n    @State private var scope: AttendanceScope = .inPerson\n\n    var body: some View {\n        NavigationStack {\n            Table(attendeeStore.attendees, selection: $selection) {\n                TableColumn(\"Name\") { attendee in\n                    AttendeeRow(attendee)\n                }\n                TableColumn(\"City\", value: \\.city)\n                TableColumn(\"Status\") { attendee in\n                    StatusRow(attendee)\n                }\n            }\n            .navigationTitle(\"Invitations\")\n            #if os(macOS)\n            .contextMenu(forSelectionType: Attendee.ID.self) { selection in\n                if selection.isEmpty {\n                    Button(\"New Invitation\") { addInvitation() }\n                } else if selection.count == 1 {\n                    Button(\"Mark as VIP\") { markVIPs(selection) }\n                } else {\n                    Button(\"Mark as VIPs\") { markVIPs(selection) }\n                }\n            }\n            #endif\n            .searchable(\n                text: $query, tokens: $tokens, scope: $scope\n            ) { token in\n                Label(\n                    token.query,\n                    systemImage: token.systemImage)\n            } scopes: {\n                Text(\"In Person\").tag(AttendanceScope.inPerson)\n                Text(\"Online\").tag(AttendanceScope.online)\n            } suggestions: {\n                suggestions\n            }\n            .toolbar(id: \"toolbar\") {\n                ToolbarItem(id: \"new\", placement: .secondaryAction) {\n                    Button(action: {}) {\n                        Label(\"New Invitation\", systemImage: \"envelope\")\n                    }\n                }\n                ToolbarItem(id: \"edit\", placement: .secondaryAction) {\n                    Button(action: {}) {\n                        Label(\"Edit\", systemImage: \"pencil.circle\")\n                    }\n                }\n                ToolbarItem(id: \"share\", placement: .secondaryAction) {\n                    Button(action: {}) {\n                        Label(\"Share\", systemImage: \"square.and.arrow.up\")\n                    }\n                }\n                ToolbarItem(id: \"tag\", placement: .secondaryAction) {\n                    Button(action: {}) {\n                        Label(\"Tags\", systemImage: \"tag\")\n                    }\n                }\n                ToolbarItem(\n                    id: \"reminder\", placement: .secondaryAction, showsByDefault: false\n                ) {\n                    Button(action: {}) {\n                        Label(\"Set reminder\", systemImage: \"bell\")\n                    }\n                }\n            }\n            .toolbarRole(.editor)\n        }\n    }\n\n    @ViewBuilder\n    private var suggestions: some View {\n        ForEach(attendeeStore.attendees) {\n            Text($0.name)\n                .foregroundColor(.black)\n        }\n\n        if !query.isEmpty {\n            ForEach(AttendeeToken.allCases) { token in\n                var _token = token\n                Label(_token.displayName(query), systemImage: _token.systemImage)\n                    .searchCompletion(_token)\n            }\n        }\n    }\n\n    private func addInvitation() {}\n\n    private func markVIPs(_ items: Set<String>) {}\n}\n\nclass AttendeeStore: ObservableObject {\n    @Published var attendees: [Attendee] = [/* Default attendees */]\n}\n\n\nstruct Attendee: Identifiable, Hashable {\n    enum Status: String {\n        case accepted, declined, maybe\n\n        func displayText() -> Text {\n            switch self {\n            case .accepted: return Text(\n                \"Accepted \\(Image(systemName: \"person.crop.circle.badge.checkmark\"))\")\n            case .maybe: return Text(\n                \"Maybe \\(Image(systemName: \"person.crop.circle.badge.questionmark\"))\")\n            case .declined: return Text(\n                \"Declined \\(Image(systemName: \"person.crop.circle.badge.minus\"))\")\n            }\n        }\n    }\n\n    let id = UUID()\n    let memojiName: String\n    let name: String\n    let city: String\n    let status: Status\n\n    init(memojiName: String, name: String, cities: String, status: Status) {\n        self.memojiName = memojiName\n        self.name = name\n        self.city = cities\n        self.status = status\n    }\n}\n\nstruct AttendeeRow: View {\n    let attendee: Attendee\n\n    init(_ attendee: Attendee) {\n        self.attendee = attendee\n    }\n\n    var body: some View {\n        HStack {\n            Image(attendee.memojiName)\n                .resizable()\n                .aspectRatio(contentMode: .fill)\n                #if os(macOS)\n                .frame(width: 20, height: 20)\n                .overlay {\n                    Circle()\n                        .stroke(Color.gray.opacity(0.2), lineWidth: 1)\n                }\n                #else\n                .frame(width: 32, height: 32)\n                .overlay {\n                    RoundedRectangle(cornerRadius: 6)\n                        .stroke(Color.gray.opacity(0.2), lineWidth: 1)\n                }\n                #endif\n            Text(attendee.name)\n        }\n    }\n}\n\nstruct StatusRow: View {\n    let attendee: Attendee\n    init(_ attendee: Attendee) {\n        self.attendee = attendee\n    }\n\n    var body: some View {\n        attendee.status.displayText()\n            .symbolVariant(.fill)\n            .symbolRenderingMode(.multicolor)\n    }\n}"
    },
    {
      "timestamp": "24:45",
      "title": "PhotosPicker",
      "language": "swift",
      "code": "import PhotosUI\nimport CoreTransferable\n\nstruct ContentView: View {\n    @ObservedObject var viewModel: FilterModel = .shared\n    \n    var body: some View {\n        NavigationStack {\n            Gallery()\n                .navigationTitle(\"Birthday Filter\")\n                .toolbar {\n                    PhotosPicker(\n                        selection: $viewModel.imageSelection,\n                        matching: .images\n                    ) {\n                        Label(\"Pick a photo\", systemImage: \"plus.app\")\n                    }\n                    Button {\n                        viewModel.applyFilter()\n                    } label: {\n                        Label(\"Apply Filter\", systemImage: \"camera.filters\")\n                    }\n                }\n        }\n    }\n}\n\nstruct Gallery: View {\n    @ObservedObject var viewModel: FilterModel = .shared\n\n    var body: some View {\n        VStack {\n            switch viewModel.imageState {\n            case .success(let image):\n                image\n                    .resizable()\n                    .aspectRatio(contentMode: .fill)\n                    .draggable(image)\n            case .loading:\n                ProgressView()\n            case .empty:\n                Text(\"No Photo \\(Image(systemName: \"photo\"))\")\n                    .font(.title2)\n                    .fontWeight(.semibold)\n                Text(\"Drag and drop a photo or press\\n \\(Image(systemName: \"plus.app\")) to choose a photo manually.\")\n                    .foregroundColor(.secondary)\n                    .multilineTextAlignment(.center)\n            case .failure:\n                Image(systemName: \"exclamationmark.triangle.fill\")\n                    .font(.system(size: 40))\n                    .foregroundColor(.white)\n            }\n        }\n        .padding()\n    }\n}\n\n@MainActor\nclass FilterModel: ObservableObject {\n    static let shared = FilterModel()\n\n    enum ImageState {\n        case empty, loading(Progress), success(Image), failure(Error)\n    }\n\n    @Published private(set) var processedImage: Image?\n    @Published var imageState: ImageState = .empty\n    @Published var imageSelection: PhotosPickerItem? = nil {\n        didSet {\n            if let imageSelection = imageSelection {\n                let progress = loadTransferable(from: imageSelection)\n                imageState = .loading(progress)\n            } else {\n                imageState = .empty\n            }\n        }\n    }\n\n    func applyFilter() { /* Apply your filter */ }\n\n    private func loadTransferable(from imageSelection: PhotosPickerItem) -> Progress {\n        return imageSelection.loadTransferable(type: Image.self) { result in\n            DispatchQueue.main.async {\n                guard imageSelection == self.imageSelection else { return }\n                switch result {\n                case .success(let image?):\n                    self.imageState = .success(image)\n                case .success(nil):\n                    self.imageState = .empty\n                case .failure(let error):\n                    self.imageState = .failure(error)\n                }\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "25:51",
      "title": "ShareLink",
      "language": "swift",
      "code": "import PhotosUI\nimport CoreTransferable\n\nstruct ContentView: View {\n    @ObservedObject var viewModel: FilterModel = .shared\n\n    var body: some View {\n        NavigationStack {\n            Gallery()\n                .navigationTitle(\"Birthday Filter\")\n                .toolbar {\n                    PhotosPicker(\n                        selection: $viewModel.imageSelection,\n                        matching: .images\n                    ) {\n                        Label(\"Pick a photo\", systemImage: \"plus.app\")\n                    }\n                    Button {\n                        viewModel.applyFilter()\n                    } label: {\n                        Label(\"Apply Filter\", systemImage: \"camera.filters\")\n                    }\n                    if let item = viewModel.processedImage {\n                        ShareLink(\n                            item: item, preview: SharePreview(\"Birthday Effects\"))\n                    }\n                }\n        }\n    }\n}\n\nstruct Gallery: View {\n    @ObservedObject var viewModel: FilterModel = .shared\n\n    var body: some View {\n        VStack {\n            switch viewModel.imageState {\n            case .success(let image):\n                image\n                    .resizable()\n                    .aspectRatio(contentMode: .fill)\n                    .draggable(image)\n            case .loading:\n                ProgressView()\n            case .empty:\n                Text(\"No Photo \\(Image(systemName: \"photo\"))\")\n                    .font(.title2)\n                    .fontWeight(.semibold)\n                Text(\"Drag and drop a photo or press\\n \\(Image(systemName: \"plus.app\")) to choose a photo manually.\")\n                    .foregroundColor(.secondary)\n                    .multilineTextAlignment(.center)\n            case .failure:\n                Image(systemName: \"exclamationmark.triangle.fill\")\n                    .font(.system(size: 40))\n                    .foregroundColor(.white)\n            }\n        }\n        .padding()\n    }\n}\n\n@MainActor\nclass FilterModel: ObservableObject {\n    static let shared = FilterModel()\n\n    enum ImageState {\n        case empty, loading(Progress), success(Image), failure(Error)\n    }\n\n    @Published private(set) var processedImage: Image?\n    @Published var imageState: ImageState = .empty\n    @Published var imageSelection: PhotosPickerItem? = nil {\n        didSet {\n            if let imageSelection = imageSelection {\n                let progress = loadTransferable(from: imageSelection)\n                imageState = .loading(progress)\n            } else {\n                imageState = .empty\n            }\n        }\n    }\n\n    func applyFilter() { /* Apply your filter */}\n\n    private func loadTransferable(from imageSelection: PhotosPickerItem) -> Progress {\n        return imageSelection.loadTransferable(type: Image.self) { result in\n            DispatchQueue.main.async {\n                guard imageSelection == self.imageSelection else { return }\n                switch result {\n                case .success(let image?):\n                    self.imageState = .success(image)\n                case .success(nil):\n                    self.imageState = .empty\n                case .failure(let error):\n                    self.imageState = .failure(error)\n                }\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "26:17",
      "title": "Context Menu",
      "language": "swift",
      "code": "import PhotosUI\nimport CoreTransferable\n\nstruct ContentView: View {\n    @ObservedObject var viewModel: FilterModel = .shared\n\n    var body: some View {\n        NavigationStack {\n            Gallery()\n                .navigationTitle(\"Birthday Filter\")\n                .toolbar {\n                    PhotosPicker(\n                        selection: $viewModel.imageSelection,\n                        matching: .images\n                    ) {\n                        Label(\"Pick a photo\", systemImage: \"plus.app\")\n                    }\n                    if let item = viewModel.processedImage {\n                        ShareLink(\n                            item: item, preview: SharePreview(\"Birthday Effects\"))\n                    }\n                    Button {\n                        viewModel.applyFilter()\n                    } label: {\n                        Label(\"Apply Filter\", systemImage: \"camera.filters\")\n                    }\n                }\n                .contextMenu {\n                    Button {\n                        viewModel.applyFilter()\n                    } label: {\n                        Label(\"Apply Filter\", systemImage: \"camera.filters\")\n                    }\n                    if let item = viewModel.processedImage {\n                        ShareLink(\n                            item: item, preview: SharePreview(\"Birthday Effects\"))\n                    }\n                    Button(role: .destructive) {\n                        viewModel.deleteCurrentPhoto()\n                    } label: {\n                        Label(\"Delete\", systemImage: \"trash\")\n                    }\n                }\n        }\n    }\n}\n\nstruct Gallery: View {\n    @ObservedObject var viewModel: FilterModel = .shared\n\n    var body: some View {\n        VStack {\n            switch viewModel.imageState {\n            case .success(let image):\n                image\n                    .resizable()\n                    .aspectRatio(contentMode: .fill)\n                    .draggable(image)\n            case .loading:\n                ProgressView()\n            case .empty:\n                Text(\"No Photo \\(Image(systemName: \"photo\"))\")\n                    .font(.title2)\n                    .fontWeight(.semibold)\n                Text(\"Drag and drop a photo or press\\n \\(Image(systemName: \"plus.app\")) to choose a photo manually.\")\n                    .foregroundColor(.secondary)\n                    .multilineTextAlignment(.center)\n            case .failure:\n                Image(systemName: \"exclamationmark.triangle.fill\")\n                    .font(.system(size: 40))\n                    .foregroundColor(.white)\n            }\n        }\n        .padding()\n    }\n}\n\n@MainActor\nclass FilterModel: ObservableObject {\n    static let shared = FilterModel()\n\n    enum ImageState {\n        case empty, loading(Progress), success(Image), failure(Error)\n    }\n\n    @Published private(set) var processedImage: Image?\n    @Published var imageState: ImageState = .empty\n    @Published var imageSelection: PhotosPickerItem? = nil {\n        didSet {\n            if let imageSelection = imageSelection {\n                let progress = loadTransferable(from: imageSelection)\n                imageState = .loading(progress)\n            } else {\n                imageState = .empty\n            }\n        }\n    }\n\n    func applyFilter() { /* Apply your filter */}\n\n    func deleteCurrentPhoto() {}\n\n    private func loadTransferable(from imageSelection: PhotosPickerItem) -> Progress {\n        return imageSelection.loadTransferable(type: Image.self) { result in\n            DispatchQueue.main.async {\n                guard imageSelection == self.imageSelection else { return }\n                switch result {\n                case .success(let image?):\n                    self.imageState = .success(image)\n                case .success(nil):\n                    self.imageState = .empty\n                case .failure(let error):\n                    self.imageState = .failure(error)\n                }\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "26:50",
      "title": "Drop destination",
      "language": "swift",
      "code": "import PhotosUI\nimport CoreTransferable\n\nstruct ContentView: View {\n    @ObservedObject var viewModel: FilterModel = .shared\n\n    var body: some View {\n        NavigationStack {\n            Gallery()\n                .navigationTitle(\"Birthday Filter\")\n                .toolbar {\n                    PhotosPicker(\n                        selection: $viewModel.imageSelection,\n                        matching: .images\n                    ) {\n                        Label(\"Pick a photo\", systemImage: \"plus.app\")\n                    }\n                    if let item = viewModel.processedImage {\n                        ShareLink(\n                            item: item, preview: SharePreview(\"Birthday Effects\"))\n                    }\n                    Button {\n                        viewModel.applyFilter()\n                    } label: {\n                        Label(\"Apply Filter\", systemImage: \"camera.filters\")\n                    }\n                }\n                .contextMenu {\n                    Button {\n                        viewModel.applyFilter()\n                    } label: {\n                        Label(\"Apply Filter\", systemImage: \"camera.filters\")\n                    }\n                    if let item = viewModel.processedImage {\n                        ShareLink(\n                            item: item, preview: SharePreview(\"Birthday Effects\"))\n                    }\n                    Button(role: .destructive) {\n                        viewModel.deleteCurrentPhoto()\n                    } label: {\n                        Label(\"Delete\", systemImage: \"trash\")\n                    }\n                }\n                .dropDestination(payloadType: Image.self) { receivedImages, location in\n                    guard let image = receivedImages.first else {\n                        return false\n                    }\n                    viewModel.imageState = .success(image)\n                    return true\n                }\n        }\n    }\n}\n\nstruct Gallery: View {\n    @ObservedObject var viewModel: FilterModel = .shared\n\n    var body: some View {\n        VStack {\n            switch viewModel.imageState {\n            case .success(let image):\n                image\n                    .resizable()\n                    .aspectRatio(contentMode: .fill)\n                    .draggable(image)\n            case .loading:\n                ProgressView()\n            case .empty:\n                Text(\"No Photo \\(Image(systemName: \"photo\"))\")\n                    .font(.title2)\n                    .fontWeight(.semibold)\n                Text(\"Drag and drop a photo or press\\n \\(Image(systemName: \"plus.app\")) to choose a photo manually.\")\n                    .foregroundColor(.secondary)\n                    .multilineTextAlignment(.center)\n            case .failure:\n                Image(systemName: \"exclamationmark.triangle.fill\")\n                    .font(.system(size: 40))\n                    .foregroundColor(.white)\n            }\n        }\n        .padding()\n    }\n}\n\n@MainActor\nclass FilterModel: ObservableObject {\n    static let shared = FilterModel()\n\n    enum ImageState {\n        case empty, loading(Progress), success(Image), failure(Error)\n    }\n\n    @Published private(set) var processedImage: Image?\n    @Published var imageState: ImageState = .empty\n    @Published var imageSelection: PhotosPickerItem? = nil {\n        didSet {\n            if let imageSelection = imageSelection {\n                let progress = loadTransferable(from: imageSelection)\n                imageState = .loading(progress)\n            } else {\n                imageState = .empty\n            }\n        }\n    }\n\n    func applyFilter() { /* Apply your filter */}\n\n    func deleteCurrentPhoto() {}\n\n    private func loadTransferable(from imageSelection: PhotosPickerItem) -> Progress {\n        return imageSelection.loadTransferable(type: Image.self) { result in\n            DispatchQueue.main.async {\n                guard imageSelection == self.imageSelection else { return }\n                switch result {\n                case .success(let image?):\n                    self.imageState = .success(image)\n                case .success(nil):\n                    self.imageState = .empty\n                case .failure(let error):\n                    self.imageState = .failure(error)\n                }\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "28:15",
      "title": "Shape Styles: CalendarIcon",
      "language": "swift",
      "code": "struct CalendarIcon: View {\n    var body: some View {\n        VStack {\n            Image(systemName: \"calendar\")\n                .font(.system(size: 80, weight: .medium))\n            Text(\"June 6\")\n        }\n        .background(in: Circle().inset(by: -20))\n        .backgroundStyle(\n            .blue\n            .gradient\n        )\n        .foregroundStyle(.white.shadow(.drop(radius: 1, y: 1.5)))\n        .padding(20)\n    }\n}"
    },
    {
      "timestamp": "28:49",
      "title": "Shape Styles: Icon Grid",
      "language": "swift",
      "code": "struct Icon: View {\n    let systemSymbolName: String\n    let color: Color\n    let shadow: ShadowStyle\n    var foregroundColor: Color = .white\n\n    var body: some View {\n        VStack {\n            Image(systemName: systemSymbolName)\n                .resizable()\n                .aspectRatio(1.0, contentMode: .fit)\n                .padding(2)\n        }\n        .background(in: Circle().inset(by: -20))\n        .backgroundStyle(\n            color\n            .gradient\n        )\n        .foregroundStyle(foregroundColor.shadow(shadow))\n        .padding(20)\n    }\n}\n\nprivate let dropStyle = ShadowStyle.drop(radius: 1, y: 1.5)\nprivate let innerStyle = ShadowStyle.inner(radius: 1.5)\n\nlet icons: [Icon]  = [\n    Icon(systemSymbolName: \"person\", color: .red, shadow: dropStyle),\n    Icon(systemSymbolName: \"basketball\", color: .orange, shadow: dropStyle),\n    Icon(systemSymbolName: \"globe.central.south.asia\", color: .yellow, shadow: innerStyle),\n    Icon(systemSymbolName: \"carrot\", color: .green, shadow: innerStyle, foregroundColor: .orange),\n    Icon(systemSymbolName: \"sailboat\", color: .mint, shadow: innerStyle),\n    Icon(systemSymbolName: \"figure.open.water.swim\", color: .teal, shadow: dropStyle),\n    Icon(systemSymbolName: \"ladybug.fill\", color: .cyan, shadow: innerStyle),\n    Icon(systemSymbolName: \"calendar\", color: .blue, shadow: dropStyle),\n    Icon(systemSymbolName: \"moon.stars\", color: .indigo, shadow: dropStyle),\n    Icon(systemSymbolName: \"brain.head.profile\", color: .purple, shadow: innerStyle),\n    Icon(systemSymbolName: \"birthday.cake\", color: .pink, shadow: dropStyle),\n    Icon(systemSymbolName: \"house.circle.fill\", color: .white, shadow: dropStyle),\n    Icon(systemSymbolName: \"lizard\", color: .brown, shadow: dropStyle),\n    Icon(systemSymbolName: \"flag.checkered\", color: .black, shadow: dropStyle),\n    Icon(systemSymbolName: \"character.book.closed\", color: .gray, shadow: dropStyle),\n]\n\nstruct IconGrid: View {\n    var body: some View {\n        Grid(horizontalSpacing: 16, verticalSpacing: 16) {\n            ForEach(0..<3) { i in\n                GridRow {\n                    ForEach(0..<5) { j in\n                        icons[i * 5 + j]\n                    }\n                }\n            }\n        }\n        .background(.black.opacity(0.8))\n    }\n}"
    },
    {
      "timestamp": "29:07",
      "title": "Graphics: Dancing symbol grid",
      "language": "swift",
      "code": "// MARK: - Dancing Symbol Grid\n\nstruct SymbolSquare: View {\n    let color: Color\n    let imageName: String\n    var image: some View {\n        Image(systemName: imageName)\n            .resizable()\n            .aspectRatio(contentMode: .fit)\n            .padding()\n            .frame(maxWidth: .infinity, maxHeight: .infinity)\n    }\n\n    var body: some View {\n        image\n            .background {\n                RoundedRectangle(cornerRadius: 6, style: .continuous)\n                    .fill(\n                        .ellipticalGradient(\n                            color\n                                .gradient\n                        )\n                    )\n            }\n    }\n}\n\n/// If `true`, the party will commence. \nprivate let startTheParty = false\n\nprivate let partySymbols = [\"party.popper\", \"balloon\", \"balloon.2\", \"birthday.cake\"]\n\nstruct DancingSymbolSquare: View {\n    let color: Color\n    let imageName: String\n  \n    /// Allows staggered dancing â€”Â doesn't look quite as nice.\n    let seed: Int\n    private let timer = Timer.publish(every: 0.234378662, on: .main, in: .default)\n    @State private var cancellable: Cancellable? = nil\n    @State private var heavy = false\n    @State var fontSize = 20 as CGFloat\n\n    var body: some View {\n        SymbolSquare(color: color, imageName: imageName)\n            .font(.body.weight(heavy ? .black : .thin))\n            .onReceive(timer) { date in\n                if heavy {\n                    withAnimation(.easeOut(duration: 0.468757324 - 0.1)) {\n                        heavy.toggle()\n                    }\n                } else {\n                    withAnimation(.easeIn(duration: 0.1)) {\n                        heavy.toggle()\n                    }\n                }\n            }\n            .onAppear {\n                if startTheParty {\n                    DispatchQueue.main.asyncAfter(deadline: .now()  + Double(seed) * 0.25) {\n                        cancellable = timer.connect()\n                    }\n                }\n            }\n            .drawingGroup(opaque: true)\n    }\n}\n\nstruct SymbolGrid: View {\n    var body: some View {\n        Grid {\n            GridRow {\n                DancingSymbolSquare(color: .yellow, imageName:partySymbols[0], seed: 0)\n                DancingSymbolSquare(color: .green, imageName: partySymbols[1], seed: 0)\n            }\n\n            GridRow {\n                DancingSymbolSquare(color: .indigo, imageName: partySymbols[2], seed: 0)\n                DancingSymbolSquare(color: .purple, imageName: partySymbols[3],  seed: 0)\n            }\n        }\n        .frame(maxWidth: .infinity, maxHeight: .infinity)\n    }\n}"
    },
    {
      "timestamp": "30:15",
      "title": "Graphics: Text transitions",
      "language": "swift",
      "code": "struct TextTransitionsView: View {\n    @State private var expandMessage = true\n    private let mintWithShadow: AnyShapeStyle = AnyShapeStyle(Color.mint.shadow(.drop(radius: 2)))\n    private let primaryWithoutShadow: AnyShapeStyle = AnyShapeStyle(Color.primary.shadow(.drop(radius: 0)))\n\n    var body: some View {\n        Text(\"Happy Birthday SwiftUI!\")\n            .font(expandMessage ? .largeTitle.weight(.heavy) : .body)\n            .foregroundStyle(expandMessage ? mintWithShadow : primaryWithoutShadow)\n            .onTapGesture { withAnimation { expandMessage.toggle() }}\n            .frame(maxWidth: expandMessage ? 160 : 250)\n            .drawingGroup()\n            .padding(20)\n            .background(.pink.opacity(0.3), in: RoundedRectangle(cornerRadius: 6))\n    }\n}"
    },
    {
      "timestamp": "31:16",
      "title": "Layout: Grid",
      "language": "swift",
      "code": "struct VIPDetailView: View {\n    var body: some View {\n        Grid {\n            GridRow {\n                NameHeadline()\n                    .gridCellColumns(2)\n            }\n            GridRow {\n                CalendarIcon()\n                SymbolGrid()\n            }\n        }\n        .frame(width: 300, height: 300)\n    }\n}\n\nstruct NameHeadline: View {\n    var body: some View {\n        HStack {\n            Color.green.background(in: RoundedRectangle(cornerRadius: 8))\n                .frame(maxWidth: .infinity, maxHeight: .infinity)\n            VStack(alignment: .leading) {\n                Text(\"Franck Ndame Mpouli\")\n                    .font(.title2)\n                    .foregroundStyle(.shadow(.drop(radius: 2, y: 3)))\n                Text(\"Party Planning Committee\").bold()\n            }\n        }\n        .padding()\n        .frame(maxWidth: .infinity, maxHeight: .infinity)\n        .background(\n            .white.gradient,\n            in: RoundedRectangle(cornerRadius: 12, style: .continuous)\n        )\n    }\n}\n\nstruct CalendarIcon: View {\n    var body: some View {\n        VStack {\n            Image(systemName: \"calendar\")\n                .font(.system(size: 80, weight: .medium))\n            Text(\"June 6\")\n        }\n        .background(in: Circle().inset(by: -20))\n        .backgroundStyle(\n            .blue\n            .gradient\n        )\n        .foregroundStyle(.white.shadow(dropStyle))\n        .padding(20)\n        .frame(maxWidth: .infinity, maxHeight: .infinity)\n    }\n}"
    },
    {
      "timestamp": "32:04",
      "title": "Layout: Seating Chart Layout",
      "language": "swift",
      "code": "// MARK: Custom Table Layout\n\nprivate let tableSize = CGSize(width: 130, height: 90)\nprivate let guestSize = CGSize(width: 40, height: 40)\n\n/// Which of 6 tables this view represents\nprivate struct TableViewLayoutKey: LayoutValueKey {\n    static let defaultValue: Int? = nil\n}\n\nextension View {\n    fileprivate func tableViewLayoutKey(_ value: Int) -> some View  {\n        return layoutValue(key: TableViewLayoutKey.self, value: value)\n    }\n}\n\n/// Which of 36 guests this view represents\nprivate struct GuestViewLayoutKey: LayoutValueKey {\n    static let defaultValue: Int? = 0\n}\n\nextension View {\n\n    /// Guests 1 - 36\n    fileprivate func guestViewLayoutKey(_ value: Int) -> some View  {\n        return layoutValue(key: GuestViewLayoutKey.self, value: value)\n    }\n}\n\nlet initials = [\n\"Ju\",\n\"As\",\n\"Ma\",\n\"As\",\n\"Ly\",\n\"Ga\",\n\"Ni\",\n\"Ar\",\n\"Ca\",\n\"Do\",\n\"Je\",\n\"Ca\",\n\"Em\",\n\"Ma\",\n\"Ze\",\n\"Jo\",\n\"Da\",\n\"Sh\",\n\"Sa\",\n\"Pl\",\n\"Pa\",\n\"Sc\",\n\"Ma\",\n\"Je\",\n\"Li\",\n\"Ma\",\n\"Ta\",\n\"Je\",\n\"Cu\",\n\"Lu\",\n\"Ra\",\n\"Na\",\n\"Sa\",\n\"Pa\",\n\"Le\",\n\"Pi\",\n]\n\nstruct SeatingChartView: View {\n\n    /// If true, the guests will be positioned in \"pods\" of tables. No table will touch another table. Otherwise\n    /// the guests will side in two longs rows.\n    @State private var usePods = true\n\n    var body: some View {\n        ZStack(alignment: .bottomTrailing) {\n            GeometryReader { proxy in\n                SeatingLayout(usePods: usePods).callAsFunction {\n                    TableView(tableNumber: 1)\n                    TableView(tableNumber: 2)\n                    TableView(tableNumber: 3)\n                    TableView(tableNumber: 4)\n                    TableView(tableNumber: 5)\n                    TableView(tableNumber: 6)\n                    ForEach(1..<37) { i in\n                        SeatedGuestOption2(guestNumber: i - 1)\n                    }\n                }\n                .animation(.default, value: proxy.size)\n            }\n            .background(.black.opacity(0.13))\n            Picker(\"Arrangement\", selection: $usePods.animation()) {\n                Text(\"Pods\").tag(true)\n                Text(\"Rows  \").tag(false)\n            }\n            .fixedSize()\n            .pickerStyle(.segmented)\n            .padding()\n        }\n    }\n}\n\n/// heh.\nstruct TableView: View {\n    let tableNumber: Int\n\n    var body: some View {\n        ZStack(alignment: .bottomTrailing) {\n            HStack {\n                Image(systemName: \"table.furniture\")\n                    .background(.quaternary.shadow(.inner(radius: 1, y: 1.5)),\n                                in: Circle().inset(by: -8))\n                    .padding(5)\n                Text(\"Table \\(tableNumber)\")\n            }\n            .foregroundStyle(.secondary)\n            .padding(8)\n            .frame(width: tableSize.width, height: tableSize.height)\n            #if os(macOS) || os(iOS)\n            .background(.regularMaterial.shadow(.drop(radius: 1, y: 1.5)),\n                        in: RoundedRectangle(cornerRadius: 12, style: .continuous))\n            #endif\n        }\n\n        .tableViewLayoutKey(tableNumber)\n    }\n}\n\nprivate let colors: [Color] = [\n    .red, .orange, .yellow, .green, .mint, .teal, .cyan, .blue,\n    .indigo, .purple, .pink, .gray, .black, .white, .brown,\n    .red, .orange, .yellow, .green, .mint, .teal, .cyan, .blue,\n    .indigo, .purple, .pink, .gray, .black, .white, .brown, .red,\n    .orange, .yellow, .green, .mint, .teal, .cyan\n]\n\nstruct SeatedGuest: View {\n\n    let guestNumber: Int\n\n    var body: some View {\n        Image(systemName: \"person\")\n            .resizable()\n            .aspectRatio(contentMode: .fit)\n            .padding(9)\n            .background(in: Circle())\n            .backgroundStyle(\n                colors[guestNumber].gradient\n            )\n            .foregroundStyle(guestNumber == 13 ? .black : .white)\n            .frame(width: 40, height: 40)\n            .guestViewLayoutKey(guestNumber + 1)\n    }\n}\n\nstruct SeatedGuestOption2: View {\n    let guestNumber: Int\n\n    var body: some View {\n        Circle()\n            .stroke(colors[guestNumber], style: StrokeStyle(lineWidth: 3))\n            .background(.white.gradient, in: Circle())\n            .frame(width: guestSize.width, height: guestSize.height)\n            .guestViewLayoutKey(guestNumber + 1)\n            .overlay {\n                Text(initials[guestNumber])\n                    .foregroundColor(.secondary)\n                    .font(.callout)\n\n            }\n    }\n}\n\nstruct SeatingChartView_Previews: PreviewProvider {\n    static var previews: some View {\n        SeatingChartView()\n            .frame(width: 600, height: 600)\n    }\n}\n\nstruct SeatingLayout: Layout {\n\n    /// If true, the guests will be positioned in \"pods\" of tables. No table will touch another table. Otherwise\n    /// the guests will side in two longs rows.\n    let usePods: Bool\n\n    struct Cache {\n        ///  The width proposed to the view. We assume a certain height, otherwise, overlapping views\n        var width: CGFloat?\n    }\n\n    func sizeThatFits(\n        proposal: ProposedViewSize,\n        subviews: LayoutSubviews,\n        cache: inout Cache\n    ) -> CGSize {\n        cache.width = proposal.width\n        return proposal.replacingUnspecifiedDimensions()\n    }\n\n    func makeCache(subviews: Subviews) -> Cache { Cache() }\n\n    func placeSubviews(in bounds: CGRect,\n                       proposal: ProposedViewSize,\n                       subviews: Subviews,\n                       cache: inout Cache) {\n        guard let width = cache.width else { return }\n\n        /// Helper function: Place 6 guests around all edges of a table.\n        func seat(_ guests: [LayoutSubview], around table: CGRect) {\n            guests[0].place(\n                at: .init(\n                    x: table.origin.x + 3 - guestSize.width,\n                    y: table.origin.y + (table.height / 2.0) - (guestSize.height / 2.0)),\n                proposal: .infinity)\n            guests[1].place(\n                at: .init(\n                    x: table.origin.x + (table.width / 4.0) - guestSize.width / 2.0,\n                    y: table.origin.y + 5 - guestSize.height),\n                proposal: .infinity)\n            guests[2].place(\n                at: .init(\n                    x: table.origin.x + table.width * 0.75 - guestSize.width / 2.0,\n                    y: table.origin.y + 5 - guestSize.height),\n                proposal: .infinity)\n            guests[3].place(\n                at: .init(\n                    x: table.maxX - 5,\n                    y: table.origin.y + (table.height / 2.0) - (guestSize.height / 2.0)),\n                proposal: .infinity)\n            guests[4].place(\n                at: .init(\n                    x: table.origin.x + table.width * 0.75 - guestSize.width / 2.0,\n                    y: table.maxY - 5),\n                proposal: .infinity)\n            guests[5].place(\n                at: .init(\n                    x: table.origin.x + (table.width / 4.0) - guestSize.width / 2.0,\n                    y: table.maxY - 5),\n                proposal: .infinity)\n        }\n\n        /// Helper function: Place 6 guests, dining hall style (not along the shorter sides of a table)\n        func seat(_ guests: [LayoutSubview], along table: CGRect) {\n            guests[0].place(\n                at: .init(\n                    x: table.minX + tableSize.width / 3 - guestSize.width - 4,\n                    y: table.origin.y + 5 - guestSize.height),\n                proposal: .infinity)\n            guests[1].place(\n                at: .init(\n                    x: table.minX + tableSize.width * 2/3 - guestSize.width - 4,\n                    y: table.origin.y + 5 - guestSize.height),\n                proposal: .infinity)\n            guests[2].place(\n                at: .init(\n                    x: table.minX + tableSize.width - guestSize.width - 4,\n                    y: table.origin.y + 5 - guestSize.height),\n                proposal: .infinity)\n            guests[3].place(\n                at: .init(\n                    x: table.minX + tableSize.width / 3 - guestSize.width - 4,\n                    y: table.maxY - 5),\n                proposal: .infinity)\n            guests[4].place(\n                at: .init(\n                    x: table.minX + tableSize.width * 2/3 - guestSize.width - 4,\n                    y: table.maxY - 5),\n                proposal: .infinity)\n            guests[5].place(\n                at: .init(\n                    x: table.minX + tableSize.width - guestSize.width - 4,\n                    y: table.maxY - 5),\n                proposal: .infinity)\n        }\n\n        // Get tables\n        let table1 = subviews.first(where: { $0[TableViewLayoutKey.self] == 1 })!\n        let table2 = subviews.first(where: { $0[TableViewLayoutKey.self] == 2 })!\n        let table3 = subviews.first(where: { $0[TableViewLayoutKey.self] == 3 })!\n        let table4 = subviews.first(where: { $0[TableViewLayoutKey.self] == 4 })!\n        let table5 = subviews.first(where: { $0[TableViewLayoutKey.self] == 5 })!\n        let table6 = subviews.first(where: { $0[TableViewLayoutKey.self] == 6 })!\n\n        // Get guests\n        let table1Guests = subviews\n            .filter {\n                guard let guestNumber = $0[GuestViewLayoutKey.self] else { return false }\n                return guestNumber >= 1 && guestNumber <= 6\n            }\n        let table2Guests = subviews\n            .filter {\n                guard let guestNumber = $0[GuestViewLayoutKey.self] else { return false }\n                return guestNumber >= 7 && guestNumber <= 12\n            }\n        let table3Guests = subviews\n            .filter {\n                guard let guestNumber = $0[GuestViewLayoutKey.self] else { return false }\n                return guestNumber >= 13 && guestNumber <= 18\n            }\n        let table4Guests = subviews\n            .filter {\n                guard let guestNumber = $0[GuestViewLayoutKey.self] else { return false }\n                return guestNumber >= 19 && guestNumber <= 24\n            }\n        let table5Guests = subviews\n            .filter {\n                guard let guestNumber = $0[GuestViewLayoutKey.self] else { return false }\n                return guestNumber >= 25 && guestNumber <= 30\n            }\n        let table6Guests = subviews\n            .filter {\n                guard let guestNumber = $0[GuestViewLayoutKey.self] else { return false }\n                return guestNumber >= 31 && guestNumber <= 36\n            }\n\n        if usePods {\n            let table1Origin = CGPoint(x: 60, y: 120)\n            let table2Origin = CGPoint(x: 200, y: 280)\n            let table3Origin = CGPoint(x: 50, y: 450)\n            let table4Origin = CGPoint(x: 300, y: 120)\n            let table5Origin = CGPoint(x: 440, y: 280)\n            let table6Origin = CGPoint(x: 290, y: 450)\n            table1.place(at: table1Origin, proposal: .infinity)\n            table2.place(at: table2Origin, proposal: .infinity)\n            table3.place(at: table3Origin, proposal: .infinity)\n            table4.place(at: table4Origin, proposal: .infinity)\n            table5.place(at: table5Origin, proposal: .infinity)\n            table6.place(at: table6Origin, proposal: .infinity)\n            seat(table1Guests, around: CGRect(origin: table1Origin, size: tableSize))\n            seat(table2Guests, around: CGRect(origin: table2Origin , size: tableSize))\n            seat(table3Guests, around: CGRect(origin: table3Origin, size: tableSize))\n            seat(table4Guests, around: CGRect(origin: table4Origin, size: tableSize))\n            seat(table5Guests, around: CGRect(origin: table5Origin , size: tableSize))\n            seat(table6Guests, around: CGRect(origin: table6Origin, size: tableSize))\n        } else {\n            let table1Origin = CGPoint(x: width / 2.0 - 6 - tableSize.width * 1.5, y: 130)\n            let table2Origin = CGPoint(x: table1Origin.x + tableSize.width + 6, y: 130)\n            let table3Origin = CGPoint(x: table2Origin.x + tableSize.width + 6, y: 130)\n            let table4Origin = CGPoint(x: width / 2.0 - 6 - tableSize.width * 1.5, y: 360)\n            let table5Origin = CGPoint(x: table1Origin.x + tableSize.width + 6, y: 360)\n            let table6Origin = CGPoint(x: table2Origin.x + tableSize.width + 6, y: 360)\n            table1.place(at: table1Origin, proposal: .infinity)\n            table2.place(at: table2Origin, proposal: .infinity)\n            table3.place(at: table3Origin, proposal: .infinity)\n            table4.place(at: table4Origin, proposal: .infinity)\n            table5.place(at: table5Origin, proposal: .infinity)\n            table6.place(at: table6Origin, proposal: .infinity)\n            seat(table1Guests, along: CGRect(origin: table1Origin, size: tableSize))\n            seat(table2Guests, along: CGRect(origin: table2Origin , size: tableSize))\n            seat(table3Guests, along: CGRect(origin: table3Origin, size: tableSize))\n            seat(table4Guests, along: CGRect(origin: table4Origin, size: tableSize))\n            seat(table5Guests, along: CGRect(origin: table5Origin , size: tableSize))\n            seat(table6Guests, along: CGRect(origin: table6Origin, size: tableSize))\n        }\n    }\n}"
    },
    {
      "timestamp": "32:50",
      "title": "AnyLayout invitation",
      "language": "swift",
      "code": "import SwiftUI\nimport GameplayKit\nimport Combine\n\n@main\nstruct InvitationApp: App {\n    var body: some Scene {\n        WindowGroup {\n            PolygonDesignerView()\n                .environmentObject(PolygonModel())\n            #if os(iOS)\n                .statusBar(hidden: true)\n            #endif\n                .edgesIgnoringSafeArea(.all)\n        }\n    }\n}\n\n// MARK: Views\n\n/// A view that arranges polygons in a grid, or a custom, scattered layout.\nprivate struct DynamicPolygonView: View {\n    @EnvironmentObject var model: PolygonModel\n    @Binding var cycleLayouts: Bool\n\n    private var sideLength: Int {\n        Int(CGFloat(model.polygonGeometries.count).squareRoot())\n    }\n\n    /// Timer whose ticking dictates how often to regenerate and animate-to a new scattered layout.\n    /// - Note: The layout will only transition if `cycleLayouts` is `true`.\n    private let layoutChangingTimer = Timer\n        .publish(every: 1.2, on: .current, in: .default).autoconnect()\n\n    /// Animation used to transition layouts\n    private let animation = Animation.easeInOut(duration: 1.3)\n\n    /// Timer that ticks at 128 beats per minute, matching the beat of the song in the WWDC session.\n    let musicBeatTimer = Timer\n        .publish(every: 0.234378662, tolerance: 0,  on: .main, in: .default)\n\n    @State private var musicBeatTimerCancellable: (any Cancellable)? = nil\n\n    /// Whether or not the font should be rendered heavy.\n    @State private var heavy: Bool = false\n\n    @State private var scatteredLayout = newScatteredLayout(\n        Date(timeIntervalSince1970: 0)\n    )\n\n    /// By providing a seed value, the `ScatteredLayout` struct will know when to bust its cache and\n    /// generate new layout data.\n    private static func newScatteredLayout(_ seed: Date) -> ScatteredLayout {\n        ScatteredLayout(count: PolygonModel.total,\n                        seed: seed.timeIntervalSinceReferenceDate,\n                        textAvoidanceRect: CGRect(\n                            x: 152,\n                            y: 245,\n                            width: 220,\n                            height: 40)\n        )\n    }\n\n    var body: some View {\n        let layout = model.usesGridLayout\n        ? AnyLayout(Grid(alignment: .center,\n                         horizontalSpacing: 0,\n                         verticalSpacing: 0))\n        : AnyLayout(scatteredLayout)\n\n        ZStack(alignment: .center) {\n            Label(title:  {\n                Text(\"You're Invited\")\n            }, icon: { Image(systemName: \"party.popper.fill\")})\n            .font(.system(size:100).weight(heavy ? .black : .thin))\n            .onTapGesture {\n                musicBeatTimerCancellable = musicBeatTimer.connect()\n            }\n            .zIndex(-1)\n\n            layout {\n                ForEach((0..<sideLength), id: \\.self) { row in\n                    GridRow { // GridRow is a no-op in non-Grid layouts\n                        ForEach((0..<sideLength), id: \\.self) { column in\n                            let polygon = model\n                                .polygonGeometries[sideLength * row + column]\n                            PolygonView(polygonGeometry: polygon)\n                                .polygonViewLayoutKey(polygon)\n                        }\n                    }\n                }\n            }\n        }\n        .drawingGroup()\n        .frame(maxWidth: .infinity, maxHeight: .infinity)\n        .onReceive(musicBeatTimer) { date in\n            if heavy {\n                // Transitioning to a thin font happens slowly\n                withAnimation(.easeOut(duration: 0.468757324 - 0.1)) {\n                    heavy.toggle()\n                }\n            } else {\n                // Transitioning to thick happens quickly, to give the\n                // appearance of a \"strong\" downbeat\n                withAnimation(.easeIn(duration: 0.1)) {\n                    heavy.toggle()\n                }\n            }\n        }\n        .onReceive(layoutChangingTimer) { date in\n            guard cycleLayouts else { return }\n            withAnimation(animation) {\n                scatteredLayout = DynamicPolygonView.newScatteredLayout(date)\n            }\n\n        }\n    }\n}\n\nprivate struct PolygonDesignerView: View {\n    @EnvironmentObject var model: PolygonModel\n    @State var cycleLayouts = false\n    @State var hideDesignerView = true\n\n    var body: some View {\n        ZStack(alignment: .bottom) {\n            DynamicPolygonView(cycleLayouts: $cycleLayouts)\n                .onTapGesture(count: 2) {\n                    withAnimation {\n                        hideDesignerView.toggle()\n                    }\n                }\n            ControlView(cycleLayouts: $cycleLayouts)\n                .padding()\n                .background(.thickMaterial)\n                .offset(CGSize(width: 0, height: hideDesignerView ? 300 : 0))\n        }\n    }\n}\n\n/// Tunes the parameters of a `PolygonModel`\nprivate struct ControlView: View {\n\n    /// The instance `self` tunes the parameters of.\n    @EnvironmentObject var model: PolygonModel\n\n    /// Can be used by a parent view to cycle through instances of layouts.\n    @Binding var cycleLayouts: Bool\n\n    var body: some View {\n        VStack {\n            Button(\"Reset\", action: model.reset)\n            let layout = HStack()\n            layout {\n                Toggle(\"Tiled\", isOn: Binding(get: {\n                    model.tiled\n                }, set: { tile in\n                    // After toggled, wait 5 seconds, then transition back to a\n                    // scattered layout\n                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {\n                        withAnimation(.linear(duration: 1.4)) {\n                            model.usesGridLayout = false\n                            model.drawAsRandomPolygons = true\n                        }\n                    }\n\n                    withAnimation(.linear(duration: 1.8)) {\n                        model.usesGridLayout = tile\n                        model.drawAsRandomPolygons = !tile\n                    }\n                }))\n\n                Toggle(\"Cycle Layouts\", isOn: $cycleLayouts)\n            }\n        }\n        .padding(2)\n    }\n}\n\n// MARK: PolygonView\n\n/// Wraps a ``Polygon`` shape applying a fill.\nprivate struct PolygonView: View {\n    var polygonGeometry: PolygonGeometry\n\n    var body: some View {\n        Polygon(polygonGeometry: polygonGeometry)\n            .fill(polygonGeometry.color)\n    }\n}\n\n/// A Polygon shape that supports any number of sides as defined by `polygonGeometry`\nprivate struct Polygon: Shape {\n    var polygonGeometry: PolygonGeometry\n\n    typealias AnimatableData = AnimatableVector\n\n    var animatableData: AnimatableVector {\n        get { polygonGeometry.vectorPath }\n        set { polygonGeometry.points = newValue.points }\n    }\n\n    func path(in rect: CGRect) -> Path {\n        // Scale up the shape's path to fill as much space as it is given\n        let path = polygonGeometry.path\n        let boundingRect = path.boundingRect\n\n        let xScale = rect.width / boundingRect.width\n        let yScale = rect.height / boundingRect.height\n\n        let translate = CGAffineTransform(\n            translationX: -boundingRect.origin.x * xScale,\n            y: -boundingRect.origin.y * yScale\n        )\n        let scale = CGAffineTransform(scaleX: xScale, y: yScale)\n        return path.applying(scale.concatenating(translate))\n    }\n\n    func sizeThatFits(_ proposal: ProposedViewSize) -> CGSize {\n        if proposal == .infinity {\n            // If proposed infinite space, use the preferred, absolute size.\n            return CGSize(width: polygonGeometry.sideLength,\n                          height: polygonGeometry.sideLength)\n        } else {\n            // If we don't have infinite space, assume we've been given all the\n            // space the parent view can afford, and take all of it.\n            return proposal.replacingUnspecifiedDimensions()\n        }\n    }\n}\n\n// MARK: ScatteredLayout\n\nprivate struct PolygonViewLayoutKey: LayoutValueKey {\n    static let defaultValue: PolygonGeometry? = nil\n}\n\nextension View {\n    fileprivate func polygonViewLayoutKey(_ value: PolygonGeometry)\n    -> some View {\n        return layoutValue(key: PolygonViewLayoutKey.self, value: value)\n    }\n}\n\n/// ScatteredLayout assumes a certain standard size and lays out its views\n/// (tagged with `PolygonViewLayoutKey` data) such that they don't collide\n/// within that size. As the size grows, the shapes stay the same size,\n/// but get farther or closer.\nprivate struct ScatteredLayout: Layout {\n\n    /// Cache data for a `ScatteredLayout`.\n    struct Cache {\n\n        /// Maps a `PolygonGeometry.id` to its position in a `standardSize`\n        /// coordinate space.\n        var rects: [UUID: CGRect]\n\n        /// Used as a cache buster.\n        var seed: TimeInterval?\n    }\n\n    /// The smallest size a view using this layout can be.\n    private let minimumBaseSize: CGSize\n\n    /// The base coordinate system this view assumes when laying out.\n    private let standardSize: CGSize = CGSize(width: 500, height: 500)\n\n    /// Clients can pass a value here and polygons won't be placed in that rect.\n    var textAvoidanceRect: CGRect = .zero\n\n    /// If different, we've been requested to bust the cache, and create a new\n    /// one.\n    /// - Note the cache can persist across different instances of a\n    ///  `ScatteredLayout`\n    private let seed: TimeInterval\n\n    func sizeThatFits(\n        proposal: ProposedViewSize,\n        subviews: LayoutSubviews,\n        cache: inout Cache\n    ) -> CGSize {\n        let proposedSize = proposal\n            .replacingUnspecifiedDimensions(by: minimumBaseSize)\n        return CGSize(\n            width: proposedSize.width\n                .clamped(\n                    to: minimumBaseSize.width..<CGFloat.greatestFiniteMagnitude\n                ),\n            height: proposedSize.height\n                .clamped(\n                    to: minimumBaseSize.height..<CGFloat.greatestFiniteMagnitude\n                )\n        )\n    }\n\n    init(count: Int, seed: TimeInterval, textAvoidanceRect: CGRect = .zero) {\n        self.seed = seed\n        minimumBaseSize = CGSize(width: CGFloat(count), height: CGFloat(count))\n        self.textAvoidanceRect = textAvoidanceRect\n    }\n\n    func makeCache(subviews: Subviews) -> Cache {\n        var cache: Cache =  Cache(rects: [:], seed: self.seed)\n        var placedPolygons: [CGRect] = []\n\n        for subview in subviews {\n\n            guard let polygon = subview[PolygonViewLayoutKey.self] else {\n                // This is the title text view, skip it.\n                continue\n            }\n\n            var subviewsPreferredSize = subview.sizeThatFits(.infinity)\n            var counter = 20\n\n            while counter > 0 {\n                counter -= 1\n                let randomX = CGFloat.random(in: 0..<standardSize.width)\n                let randomY: CGFloat\n                if randomX > textAvoidanceRect.minX\n                    && randomX < textAvoidanceRect.maxX {\n                    // Pick from either above or below the avoidance rect\n                    if Bool.random() {\n                        randomY = CGFloat.random(\n                            in: 0..<textAvoidanceRect.minY\n                        )\n                    } else {\n                        randomY = CGFloat.random(\n                            in: textAvoidanceRect.maxY..<standardSize.height\n                        )\n                    }\n                } else {\n                    randomY = CGFloat.random(in: 0..<standardSize.height)\n                }\n\n                let origin = CGPoint(x: randomX, y: randomY)\n                let rect = CGRect(origin: origin, size: subviewsPreferredSize)\n\n                if placedPolygons.allSatisfy({ placed in\n                    !placed.intersects(rect)\n                }) && !rect.intersects(textAvoidanceRect) {\n                    // The shape found a non-overlapping place to be. Lock in\n                    // it's position\n                    placedPolygons.append(rect)\n                    cache.rects[polygon.id] =\n                    CGRect(origin: origin,\n                           size: subviewsPreferredSize)\n                    break\n                } else  {\n                    if (counter == 0) {\n                        if rect.intersects(textAvoidanceRect) {\n                            subviewsPreferredSize = .zero\n                        }\n                        placedPolygons.append(rect)\n                        cache.rects[polygon.id] =\n                        CGRect(origin: origin,\n                               size: subviewsPreferredSize)\n                    }\n                }\n            }\n        }\n        return cache\n    }\n\n    func placeSubviews(in bounds: CGRect,\n                       proposal: ProposedViewSize,\n                       subviews: Subviews,\n                       cache: inout Cache) {\n        // We have the frame value cached (via makeCache())\n        // for every view to be placed in a `standardSize` coordinate system.\n        // Now we need to map that `standardSize` to the size was proposed.\n        let proposedSize = proposal\n            .replacingUnspecifiedDimensions(by: minimumBaseSize)\n        let xProposedToBaseRatio = proposedSize.width / standardSize.width\n        let yProposedToBaseRatio = proposedSize.height / standardSize.height\n\n        for subview in subviews {\n            guard let uuid = subview[PolygonViewLayoutKey.self]?.id, let rect =\n                    cache.rects[uuid] else {\n                let desiredSize = subview.sizeThatFits(.zero)\n                let centered = desiredSize.centered(in: bounds)\n                subview.place(\n                    at: centered.origin,\n                    proposal: ProposedViewSize(\n                        width: desiredSize.width,\n                        height: desiredSize.height\n                    )\n                )\n                continue\n            }\n\n            let mappedPoint = CGPoint(x: rect.origin.x * xProposedToBaseRatio,\n                                      y: rect.origin.y * yProposedToBaseRatio)\n\n            subview.place(at: mappedPoint,\n                          proposal: ProposedViewSize(width: rect.size.width,\n                                                     height:rect.size.height)\n            )\n        }\n    }\n\n    func updateCache(_ cache: inout Cache, subviews: Subviews) {\n\n        // Bust the cache if we've been given a new seed value\n        // or if our subviews have been swapped out from underneath us.\n        if self.seed != cache.seed\n            || !cache.rects.contains(where: { (key: UUID, value: CGRect) in\n                subviews.first?[PolygonViewLayoutKey.self]?.id == key\n            })  {\n            cache = makeCache(subviews: subviews)\n            return\n        }\n    }\n\n}\n\n/// This struct facilitates animation of point-based `Path`s so long as said\n/// source and destination `Path` have an equal number of vertices.\nprivate struct AnimatableVector: VectorArithmetic {\n\n    static var zero: AnimatableVector = AnimatableVector(points: [])\n\n    private(set) var points: [CGPoint]\n\n    var magnitudeSquared: Double {\n        let squared = points.map { point in\n            CGPoint(x: point.x * point.x, y: point.y * point.y)\n        }\n        let sumOfSquares = squared.map { point in // dot product?\n            sqrt(point.x + point.y)\n        }\n        let sum = sumOfSquares.reduce(0, +)\n        return Double(sum)\n    }\n\n    /// Facilitates a valid `.zero` value, no matter the dimension of the vector\n    subscript(safe index: Int) -> CGPoint {\n        return (self.points.count <= index) ? .zero : points[index]\n    }\n\n    static func - (lhs: AnimatableVector, rhs: AnimatableVector)\n    -> AnimatableVector {\n        let negated = rhs.points.map { CGPoint(x: -$0.x, y: -$0.y) }\n        return lhs + AnimatableVector(points: negated)\n    }\n\n    static func + (lhs: AnimatableVector, rhs: AnimatableVector)\n    -> AnimatableVector {\n        var output: [CGPoint] = []\n        for i in 0..<lhs.points.count {\n            output.append(CGPoint(x: lhs[safe: i].x + rhs[safe: i].x,\n                                  y:lhs[safe: i].y + rhs[safe: i].y ))\n        }\n        return AnimatableVector(points: output)\n    }\n\n    mutating func scale(by rhs: Double) {\n        points = points.map { CGPoint(x: $0.x * CGFloat(rhs),\n                                      y: $0.y * CGFloat(rhs)) }\n    }\n}\n\n// MARK: Random Polygon Generation & Geometry\n\nprivate let mean: Float = 10\nprivate let deviation: Float = 3\nprivate let gaussian = GKGaussianDistribution(\n    randomSource: GKARC4RandomSource(),\n    mean: mean,\n    deviation: deviation)\n\n/// Factory type for creating points describing a random Polygon\nprivate struct PolygonGeometry: Identifiable, Equatable, Hashable {\n\n    /// The horizontal and vertical side lengths of the polygon's bounding box.\n    let sideLength: CGFloat\n\n    /// A constant count of the total points that comprise this\n    /// `PolygonGeometry`'s path. Clients can set `points` to a new value, but\n    /// the new value should have the same `count` for smooth `Path` animations\n    let numberOfVertices: Int\n\n    /// Supports animation of point-based `Path`s by providing an array of\n    /// points that can be interpolated.\n    var vectorPath: AnimatableVector {\n        AnimatableVector(points: points)\n    }\n\n    /// If `false`, this instance will present itself as a rectangular shape\n    /// (not necessarily with 4 vertices) that fills available space.\n    private(set) var drawsAsPolygon: Bool = true\n\n    /// Points describing the `Path` used to render `self`.\n    var points: [CGPoint] {\n        willSet {\n            assert(points.count == polygonPathPoints.count)\n        }\n    }\n\n    /// Delineate the path of the random polygon.\n    private let polygonPathPoints: [CGPoint]\n\n    let color: Color = [\n        Color(red: 0.73, green: 0.20, blue: 0.20),\n        Color(red: 0.95, green: 0.66, blue: 0.24),\n        Color(red: 0.14, green: 0.29, blue: 0.49),\n        Color(red: 0.46, green: 0.76, blue: 0.67),\n        Color(red: 0.30, green: 0.33, blue: 0.22),\n        Color(red: 0.49, green: 0.55, blue: 0.64),\n        Color(red: 0.92, green: 0.53, blue: 0.30),\n        Color(red: 0.20, green: 0.45, blue: 0.55),\n        Color(red: 0.41, green: 0.45, blue: 0.45),\n        Color(red: 0.87, green: 0.67, blue: 0.61)\n    ].randomElement()!\n\n    private var spikiness: CGFloat = 0.2\n    private var irregularity: CGFloat = 0.2\n\n    let id = UUID()\n\n    /// Owning `Shape` instances should use this to draw.\n    var path: Path { Path(from: points) }\n\n    init(pointsVector: [CGPoint], sideLength: CGFloat) {\n        self.numberOfVertices = pointsVector.count\n        self.points = pointsVector\n        self.polygonPathPoints = points\n        self.sideLength = sideLength\n    }\n\n    func drawn(asRandomizedPolygon: Bool) -> Self {\n        var copy = self\n        copy.drawsAsPolygon = asRandomizedPolygon\n        copy.points = asRandomizedPolygon\n        ? copy.polygonPathPoints\n        : CGRect(x: 0, y: 0, width: 1, height: 1)\n            .pointSequence(of: copy.numberOfVertices)\n        return copy\n    }\n\n    func hash(into hasher: inout Hasher) {\n        hasher.combine(id)\n    }\n}\n\n/// A namespace around functionality to generate a  path drawn in a 1x1 square\n/// with configurable \"irregularity\" and \"spikiness\".\n/// The closer both are to zero, the closer the generated polygon is to a\n/// [regular polygon](https://mathworld.wolfram.com/RegularPolygon.html)\nprivate enum UnitPolygonGeometryFactory {\n\n    /// The maximum possible radius. A value of 0.5 restricts the algorithm\n    /// to the unit square.\n    private static let maxRadius: CGFloat = 0.5\n\n    /// A â€” by no means definitive â€” algorithm for creating an arbitrary\n    /// polygon of `vertexCount` vertices\n    /// - Parameters:\n    ///   - vertexCount: How many vertices (and edges) the polygon will have\n    ///   - irregularity: A subjective term for how \"irregular\" the polygon is.\n    ///   A fully regular polygon has all equal sides, assuming 0 `spikinesss`.\n    ///   - spikiness: A subjective term for how \"spiky\" the polygon is.\n    ///   A polygon with high spikiness will have more vertices closer and\n    ///   farther from where the vertex would be on a regular polygon.\n    /// - Returns: An array of points representing the point-based path of\n    /// the polygon\n    static func random(vertexCount: Int,\n                       irregularity: CGFloat = 0.2,\n                       spikiness: CGFloat = 0.2)\n    -> [CGPoint] {\n\n        let floatVertices = CGFloat(vertexCount)\n\n        // Irregularity is how much we're willing to allow the angular steps to\n        // vary from \"perfect\". For example, in a regular (all sides equal)\n        // six-sided polygon, each angular step is 2ðœ‹ / 6. Irregularity\n        // defines the range that value can take, centered around a mean of\n        // 2ðœ‹ / 6. We accept an irregularity between 0 and 1, and then\n        // scale it for how much that represents out of a circle's radians.\n        let scaledIrregularity = irregularity * 2.0 * CGFloat.pi / floatVertices\n\n        // Spikiness describes how often we want to see values that are very\n        // far from where a vertex of a regular polygon would be. For example,\n        // a high positive spikiness might push a vertex radially very far from\n        // the center, leading to a big \"spike\". Meanwhile, a spikiness of 0\n        // will yield more circular polygons.\n        let denormalizedSpikiness = spikiness * maxRadius\n\n        let gaussian = GKGaussianDistribution(\n            randomSource: GKARC4RandomSource(),\n            mean: Float(maxRadius * 1024),\n            deviation: Float(denormalizedSpikiness * 1024))\n\n        // Generate the angular steps\n        var raidanAngleSteps: [CGFloat] = []\n\n        // Both of these measured in radians\n        let minimumSliceWidth =\n        (2.0 * CGFloat.pi / floatVertices) - scaledIrregularity\n        let maximumSliceWidth =\n        (2.0 * CGFloat.pi / floatVertices) + scaledIrregularity\n\n        var sum: CGFloat = 0\n\n        for _ in (0..<vertexCount) {\n            let radians = CGFloat\n                .random(in: minimumSliceWidth...maximumSliceWidth)\n            raidanAngleSteps.append(radians)\n            sum += radians\n        }\n\n        // Re-divide these steps so the point 0 and n+1 are the same.\n        // I.e. if the random angle generation from the above loop yielded\n        // more or less than 2ðœ‹ radians, reapportion those divisions to sum to\n        // 2ðœ‹.\n        let k = sum / (2 * CGFloat.pi)\n        (0..<vertexCount).forEach { i in\n            raidanAngleSteps[i] /= k\n        }\n\n        let maximumPossibleGaussianSample = CGFloat(\n            gaussian.mean + Float(denormalizedSpikiness * 1024)*3\n        )\n\n        // Finally, make all of the normalized points within a 1x1 square\n        // Unlike the unit circle of traditional geometry, because (0, 0) is in\n        // the top left, (0.5, 0.5) is in the middle. Thus, positively\n        // incrementing the angle moves us clockwise around the circle\n        var points: [CGPoint] = []\n        let center = CGPoint(x: maxRadius, y: maxRadius)\n        var cumulativeAngle: CGFloat = 0.0\n        for i in (0..<Int(vertexCount)) {\n\n            // * 2 to keep the sample <= 0.5 (`maxRadius)\n            let radiusForPoint = CGFloat(gaussian.nextInt())\n            / (maximumPossibleGaussianSample * 2)\n\n            let x = center.x + radiusForPoint * cos(cumulativeAngle)\n            let y = center.y + radiusForPoint * sin(cumulativeAngle)\n            points.append(CGPoint(x: x, y: y))\n\n            cumulativeAngle += raidanAngleSteps[i]\n        }\n        return points\n    }\n}\n\n// MARK: Observable Polygon Model\n\n/// A `PolygonModel` describes a collection of randomized ``Polygons`` that\n/// can be laid out by `AnyLayout` type.\nprivate class PolygonModel: ObservableObject {\n\n    static let total = (maxSides - minSides + 1) * polygonsPerSideCount\n\n    /// The minimum sides the randomly generated sides will have\n    private static let minSides = 4\n\n    /// The maximum sides the randomly generated sides will have\n    private static let maxSides = 7\n\n    /// The number of randomly generated polygons to make _per side length_.\n    private static let polygonsPerSideCount = 32\n\n    /// All `PolygonGeometry`s that are laid out with `scatteredLayout`\n    @Published var polygonGeometries: [PolygonGeometry] = makeGeometries()\n\n    /// If `true`, `self` is expressing a grid layout with rectangular tiles.\n    var tiled: Bool { usesGridLayout && !drawAsRandomPolygons }\n\n    /// If `true`, ignore `scatteredLayout` and instead use a `Grid` layout\n    @Published var usesGridLayout: Bool = false\n\n    /// If `true`, `polygonGeometries` draw themselves as randomized polygons.\n    /// If false, a rectangle that fills all available space.\n    @Published var drawAsRandomPolygons: Bool = true {\n        didSet {\n            polygonGeometries = polygonGeometries.map {\n                $0.drawn(asRandomizedPolygon: drawAsRandomPolygons)\n            }\n        }\n    }\n\n    /// Tunable by clients to experiment with different values.\n    let spikiness: CGFloat = 0.2\n    /// Tunable by clients to experiment with different values.\n    let irregularity: CGFloat = 0.2\n\n    /// Creates many ``PolygonGeometry`` instances with the given parameters.\n    /// - Parameters:\n    ///   - irregularity: A subjective term for how \"irregular\" the polygon is.\n    ///   A fully regular polygon has all equal sides, assuming 0 `spikinesss`.\n    ///   - spikiness: A subjective term for how \"spiky\" the polygon is.\n    ///   A polygon with high spikiness will have more vertices closer and\n    ///   farther from where the vertex would be on a regular polygon.\n    /// - Returns: An array of `n` polygons where `n` is defined by the\n    ///  `PolygonModel` class.\n    private static func makeGeometries(\n        irregularity: CGFloat = 0.3,\n        spikiness: CGFloat = 0.3) -> [PolygonGeometry] {\n            var scales: Array<CGFloat> = polygonSizeRatios\n                .reduce(into: []) { partialResult, sizeRatio in\n                    let (size, percentage) = sizeRatio\n                    let scalesToMake = Int(ceil(percentage * CGFloat(total)))\n                    partialResult.append(contentsOf: (0..<scalesToMake)\n                        .map { _ in CGFloat.random(in: size.sizeRange) })\n                }.shuffled()\n\n            return (minSides...maxSides).flatMap { vertexCount in\n                return (0..<polygonsPerSideCount).map { _ in\n                    let unitPolygon = UnitPolygonGeometryFactory\n                        .random(vertexCount: vertexCount,\n                                irregularity: irregularity,\n                                spikiness: spikiness)\n                    let polygonGeometry = PolygonGeometry(\n                        pointsVector: unitPolygon,\n                        sideLength: scales.removeFirst())\n                    return polygonGeometry\n                }\n            }.shuffled()\n        }\n\n    /// Complete remove and regenerate all model data.\n    func reset() {\n        polygonGeometries.removeAll(keepingCapacity: true)\n        polygonGeometries = PolygonModel.makeGeometries(\n            irregularity: irregularity,\n            spikiness: spikiness\n        )\n    }\n}\n\nprivate extension PolygonModel {\n\n    /// Use a sampling of various sized polygons\n    enum PieceSize: Hashable {\n        case tiny\n        case small\n        case medium\n        case large\n\n        /// The range for the side length of the bounding rect of a polygon\n        var sizeRange: ClosedRange<CGFloat> {\n            switch self {\n            case .tiny:\n                return 16.0...25.0\n            case .small:\n                return 25.0...40.0\n            case .medium:\n                return 40.0...50.0\n            case .large:\n                return 50.0...65.0\n            }\n        }\n    }\n\n    /// This dictionary denotes the ratio of sizes to use.\n    /// - warning: Should sum to 100.\n    private static let polygonSizeRatios: [PieceSize: CGFloat] =\n    [\n        .large: 0.15,\n        .medium: 0.25,\n        .small: 0.25,\n        .tiny: 0.35\n    ]\n}\n\n// MARK: - Utility Extensions\n\nextension FloatingPoint {\n\n    /// - returns an instance of `Self` clamped to the ``ClosedRange``.\n    func clamped(to limits: ClosedRange<Self>) -> Self {\n        return min(max(self, limits.lowerBound), limits.upperBound)\n    }\n\n    /// - returns an instance of `Self` clamped to the ``Range``.\n    /// - note the value returned will be less than the provided upper bound, as\n    ///  is dictated by ``Range``.\n    func clamped(to limits: Range<Self>) -> Self {\n        return min(max(self, limits.lowerBound), limits.upperBound.nextDown)\n    }\n}\n\nextension CGRect {\n\n    /// Creates a rectangular sequence of `vertexCount `points denoting a\n    /// rectangular path.\n    /// - note This is helpful for animating a `Path` composed of `vertexCount`\n    /// points into a ``Rectangle``.\n    func pointSequence(of vertexCount: Int) -> [CGPoint] {\n        // Start at a random corner. When many Polygons are using this\n        // animation at once, if they all start at the same corner, an\n        // unnatural uniformity of motion emerges.\n        var startingPercent = [0, 0.25, 0.5, 0.75].randomElement()!\n        var points: [CGPoint] = []\n\n        let extraPoints = vertexCount - 4\n        let (groups, remainder) = extraPoints\n            .quotientAndRemainder(dividingBy: 3)\n\n        for edge in 0...3 {\n            points.append(pointAlongPerimeter(at: startingPercent))\n            for i in (0..<(edge == 3 ? remainder : groups)) {\n                points.append(pointAlongPerimeter(\n                    at: startingPercent + 0.25\n                    / CGFloat(groups + 1) * CGFloat(i)))\n            }\n            startingPercent += 0.25\n            startingPercent.formTruncatingRemainder(dividingBy: 1)\n        }\n        assert(points.count == vertexCount)\n        return points\n    }\n\n    /// Returns the ``CGPoint`` that is `percent` along the path of `self`,\n    /// with 0% mapping to the top-left corner, progressing clockwise.\n    /// E.g. 50% would map to the bottom right corner if and only if `self` is\n    ///  a square.\n    /// - Parameters:\n    ///   - percent: A percentage between `0.0` and `1.0`\n    private func pointAlongPerimeter(at percent: CGFloat) -> CGPoint {\n        let perimeter = size.width * 2 + size.height * 2\n\n        // Mark the four corners as percentages around the rect. For example,\n        /// these values for a square would be 25%, 50%, 75%, 100%\n        let topRight = size.width / perimeter\n        let bottomRight = topRight + (size.height / perimeter)\n        let bottomLeft = bottomRight + (size.width / perimeter)\n        let topLeft = 1.0\n\n        switch percent {\n        case 0..<topRight:\n            return CGPoint(\n                x: percent / topRight * size.width,\n                y: minY)\n        case topRight..<bottomRight:\n            return CGPoint(\n                x: maxX,\n                y: (percent - topRight)\n                / (bottomRight - topRight) * size.height)\n        case bottomRight..<bottomLeft:\n            return CGPoint(\n                x: maxX - ((percent - bottomRight) / (bottomLeft - bottomRight)\n                           * size.width),\n                y: maxY)\n        case bottomLeft...topLeft:\n            return CGPoint(\n                x: minX,\n                y: maxY - (percent - bottomLeft) / (topLeft - bottomLeft)\n                * size.height\n            )\n        default:\n            preconditionFailure(\"Invalid percentage requested\")\n        }\n    }\n}\n\n/// Returns a new `CGRect` with the same size as `self`, but centered in `other`\n/// vertically, and horizontally.\nextension CGSize {\n    func centered(in other: CGRect) -> CGRect {\n        CGRect(x: other.midX - width / 2.0,\n               y: other.midY - height / 2.0,\n               width: width,\n               height: height)\n    }\n}\n\nextension Path {\n    /// Convenience for initializing a `Path` from an array of `CGPoint`s given\n    /// the first point element is the `Path`'s first point.\n    init(from points: [CGPoint]) {\n        self.init()\n        self.addLines(points)\n        self.closeSubpath()\n    }\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "SwiftUI",
        "url": "https://developer.apple.com/documentation/SwiftUI"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2022/10052/5/241B4005-877E-40CD-91AA-4CE0714BB2E6/downloads/wwdc2022-10052_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2022/10052/5/241B4005-877E-40CD-91AA-4CE0714BB2E6/downloads/wwdc2022-10052_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10061",
      "year": "2022",
      "title": "Bring multiple windows to your SwiftUI app",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10061"
    },
    {
      "id": "10133",
      "year": "2022",
      "title": "Build a productivity app for Apple Watch",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10133"
    },
    {
      "id": "10056",
      "year": "2022",
      "title": "Compose custom layouts with SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10056"
    },
    {
      "id": "10095",
      "year": "2022",
      "title": "Enhance collaboration experiences with Messages",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10095"
    },
    {
      "id": "10136",
      "year": "2022",
      "title": "Hello Swift Charts",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10136"
    },
    {
      "id": "10093",
      "year": "2022",
      "title": "Integrate your custom collaboration app with Messages",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10093"
    },
    {
      "id": "10062",
      "year": "2022",
      "title": "Meet Transferable",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10062"
    },
    {
      "id": "10137",
      "year": "2022",
      "title": "Swift Charts: Raise the bar",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10137"
    },
    {
      "id": "110343",
      "year": "2022",
      "title": "SwiftUI on iPad: Add toolbars, titles, and more",
      "url": "https://developer.apple.com/videos/play/wwdc2022/110343"
    },
    {
      "id": "10058",
      "year": "2022",
      "title": "SwiftUI on iPad: Organize your interface",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10058"
    },
    {
      "id": "10054",
      "year": "2022",
      "title": "The SwiftUI cookbook for navigation",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10054"
    },
    {
      "id": "110371",
      "year": "2022",
      "title": "Use Xcode to develop a multiplatform app",
      "url": "https://developer.apple.com/videos/play/wwdc2022/110371"
    },
    {
      "id": "110427",
      "year": "2022",
      "title": "What's new in Xcode",
      "url": "https://developer.apple.com/videos/play/wwdc2022/110427"
    },
    {
      "id": "10009",
      "year": "2022",
      "title": "Whatâ€™s new in iPad app design",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10009"
    },
    {
      "id": "110929",
      "year": "2022",
      "title": "WWDC22 Day 1 recap",
      "url": "https://developer.apple.com/videos/play/wwdc2022/110929"
    }
  ],
  "extractedAt": "2025-07-18T10:53:32.067Z"
}